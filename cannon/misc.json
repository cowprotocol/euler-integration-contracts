{
  "artifacts": {
    "CowEvcClosePositionWrapper": {
      "contractName": "CowEvcClosePositionWrapper",
      "sourceName": "src/CowEvcClosePositionWrapper.sol",
      "abi": [
        {
          "type": "constructor",
          "inputs": [
            {
              "name": "_evc",
              "type": "address",
              "internalType": "address"
            },
            {
              "name": "_settlement",
              "type": "address",
              "internalType": "contract ICowSettlement"
            }
          ],
          "stateMutability": "nonpayable"
        },
        {
          "type": "function",
          "name": "AUTHENTICATOR",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address",
              "internalType": "contract ICowAuthentication"
            }
          ],
          "stateMutability": "view"
        },
        {
          "type": "function",
          "name": "DOMAIN_SEPARATOR",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bytes32",
              "internalType": "bytes32"
            }
          ],
          "stateMutability": "view"
        },
        {
          "type": "function",
          "name": "DOMAIN_TYPE_HASH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bytes32",
              "internalType": "bytes32"
            }
          ],
          "stateMutability": "view"
        },
        {
          "type": "function",
          "name": "EVC",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address",
              "internalType": "contract IEVC"
            }
          ],
          "stateMutability": "view"
        },
        {
          "type": "function",
          "name": "NONCE_NAMESPACE",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256",
              "internalType": "uint256"
            }
          ],
          "stateMutability": "view"
        },
        {
          "type": "function",
          "name": "PARAMS_TYPE_HASH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bytes32",
              "internalType": "bytes32"
            }
          ],
          "stateMutability": "view"
        },
        {
          "type": "function",
          "name": "SETTLEMENT",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address",
              "internalType": "contract ICowSettlement"
            }
          ],
          "stateMutability": "view"
        },
        {
          "type": "function",
          "name": "encodePermitData",
          "inputs": [
            {
              "name": "params",
              "type": "tuple",
              "internalType": "struct CowEvcClosePositionWrapper.ClosePositionParams",
              "components": [
                {
                  "name": "owner",
                  "type": "address",
                  "internalType": "address"
                },
                {
                  "name": "account",
                  "type": "address",
                  "internalType": "address"
                },
                {
                  "name": "deadline",
                  "type": "uint256",
                  "internalType": "uint256"
                },
                {
                  "name": "borrowVault",
                  "type": "address",
                  "internalType": "address"
                },
                {
                  "name": "collateralVault",
                  "type": "address",
                  "internalType": "address"
                },
                {
                  "name": "collateralAmount",
                  "type": "uint256",
                  "internalType": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bytes",
              "internalType": "bytes"
            }
          ],
          "stateMutability": "view"
        },
        {
          "type": "function",
          "name": "evcInternalSettle",
          "inputs": [
            {
              "name": "settleData",
              "type": "bytes",
              "internalType": "bytes"
            },
            {
              "name": "wrapperData",
              "type": "bytes",
              "internalType": "bytes"
            },
            {
              "name": "remainingWrapperData",
              "type": "bytes",
              "internalType": "bytes"
            }
          ],
          "outputs": [],
          "stateMutability": "nonpayable"
        },
        {
          "type": "function",
          "name": "getApprovalHash",
          "inputs": [
            {
              "name": "params",
              "type": "tuple",
              "internalType": "struct CowEvcClosePositionWrapper.ClosePositionParams",
              "components": [
                {
                  "name": "owner",
                  "type": "address",
                  "internalType": "address"
                },
                {
                  "name": "account",
                  "type": "address",
                  "internalType": "address"
                },
                {
                  "name": "deadline",
                  "type": "uint256",
                  "internalType": "uint256"
                },
                {
                  "name": "borrowVault",
                  "type": "address",
                  "internalType": "address"
                },
                {
                  "name": "collateralVault",
                  "type": "address",
                  "internalType": "address"
                },
                {
                  "name": "collateralAmount",
                  "type": "uint256",
                  "internalType": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bytes32",
              "internalType": "bytes32"
            }
          ],
          "stateMutability": "view"
        },
        {
          "type": "function",
          "name": "getInbox",
          "inputs": [
            {
              "name": "owner",
              "type": "address",
              "internalType": "address"
            },
            {
              "name": "subaccount",
              "type": "address",
              "internalType": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address",
              "internalType": "address"
            }
          ],
          "stateMutability": "nonpayable"
        },
        {
          "type": "function",
          "name": "getInboxAddressAndDomainSeparator",
          "inputs": [
            {
              "name": "owner",
              "type": "address",
              "internalType": "address"
            },
            {
              "name": "subaccount",
              "type": "address",
              "internalType": "address"
            }
          ],
          "outputs": [
            {
              "name": "creationAddress",
              "type": "address",
              "internalType": "address"
            },
            {
              "name": "domainSeparator",
              "type": "bytes32",
              "internalType": "bytes32"
            }
          ],
          "stateMutability": "view"
        },
        {
          "type": "function",
          "name": "getInboxCreationCode",
          "inputs": [],
          "outputs": [
            {
              "name": "creationCode",
              "type": "bytes",
              "internalType": "bytes"
            }
          ],
          "stateMutability": "pure"
        },
        {
          "type": "function",
          "name": "isHashPreApproved",
          "inputs": [
            {
              "name": "owner",
              "type": "address",
              "internalType": "address"
            },
            {
              "name": "hash",
              "type": "bytes32",
              "internalType": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool",
              "internalType": "bool"
            }
          ],
          "stateMutability": "view"
        },
        {
          "type": "function",
          "name": "name",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string",
              "internalType": "string"
            }
          ],
          "stateMutability": "view"
        },
        {
          "type": "function",
          "name": "preApprovedHashes",
          "inputs": [
            {
              "name": "",
              "type": "address",
              "internalType": "address"
            },
            {
              "name": "",
              "type": "bytes32",
              "internalType": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256",
              "internalType": "uint256"
            }
          ],
          "stateMutability": "view"
        },
        {
          "type": "function",
          "name": "setPreApprovedHash",
          "inputs": [
            {
              "name": "hash",
              "type": "bytes32",
              "internalType": "bytes32"
            },
            {
              "name": "approved",
              "type": "bool",
              "internalType": "bool"
            }
          ],
          "outputs": [],
          "stateMutability": "nonpayable"
        },
        {
          "type": "function",
          "name": "validateWrapperData",
          "inputs": [
            {
              "name": "wrapperData",
              "type": "bytes",
              "internalType": "bytes"
            }
          ],
          "outputs": [],
          "stateMutability": "pure"
        },
        {
          "type": "function",
          "name": "wrappedSettle",
          "inputs": [
            {
              "name": "settleData",
              "type": "bytes",
              "internalType": "bytes"
            },
            {
              "name": "chainedWrapperData",
              "type": "bytes",
              "internalType": "bytes"
            }
          ],
          "outputs": [],
          "stateMutability": "nonpayable"
        },
        {
          "type": "event",
          "name": "CowEvcPositionClosed",
          "inputs": [
            {
              "name": "owner",
              "type": "address",
              "indexed": true,
              "internalType": "address"
            },
            {
              "name": "account",
              "type": "address",
              "indexed": false,
              "internalType": "address"
            },
            {
              "name": "borrowVault",
              "type": "address",
              "indexed": true,
              "internalType": "address"
            },
            {
              "name": "collateralVault",
              "type": "address",
              "indexed": true,
              "internalType": "address"
            },
            {
              "name": "collateralAmount",
              "type": "uint256",
              "indexed": false,
              "internalType": "uint256"
            },
            {
              "name": "repaidAmount",
              "type": "uint256",
              "indexed": false,
              "internalType": "uint256"
            },
            {
              "name": "leftoverAmount",
              "type": "uint256",
              "indexed": false,
              "internalType": "uint256"
            }
          ],
          "anonymous": false
        },
        {
          "type": "event",
          "name": "PreApprovedHash",
          "inputs": [
            {
              "name": "owner",
              "type": "address",
              "indexed": true,
              "internalType": "address"
            },
            {
              "name": "hash",
              "type": "bytes32",
              "indexed": true,
              "internalType": "bytes32"
            },
            {
              "name": "approved",
              "type": "bool",
              "indexed": false,
              "internalType": "bool"
            }
          ],
          "anonymous": false
        },
        {
          "type": "event",
          "name": "PreApprovedHashConsumed",
          "inputs": [
            {
              "name": "owner",
              "type": "address",
              "indexed": true,
              "internalType": "address"
            },
            {
              "name": "hash",
              "type": "bytes32",
              "indexed": true,
              "internalType": "bytes32"
            }
          ],
          "anonymous": false
        },
        {
          "type": "error",
          "name": "AlreadyConsumed",
          "inputs": [
            {
              "name": "owner",
              "type": "address",
              "internalType": "address"
            },
            {
              "name": "hash",
              "type": "bytes32",
              "internalType": "bytes32"
            }
          ]
        },
        {
          "type": "error",
          "name": "Create2AddressMismatch",
          "inputs": [
            {
              "name": "expectedAddress",
              "type": "address",
              "internalType": "address"
            }
          ]
        },
        {
          "type": "error",
          "name": "Create2EmptyBytecode",
          "inputs": []
        },
        {
          "type": "error",
          "name": "FailedDeployment",
          "inputs": []
        },
        {
          "type": "error",
          "name": "HashNotApproved",
          "inputs": [
            {
              "name": "owner",
              "type": "address",
              "internalType": "address"
            },
            {
              "name": "hash",
              "type": "bytes32",
              "internalType": "bytes32"
            }
          ]
        },
        {
          "type": "error",
          "name": "InsufficientBalance",
          "inputs": [
            {
              "name": "balance",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "needed",
              "type": "uint256",
              "internalType": "uint256"
            }
          ]
        },
        {
          "type": "error",
          "name": "InsufficientDebt",
          "inputs": [
            {
              "name": "expectedMinDebt",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "actualDebt",
              "type": "uint256",
              "internalType": "uint256"
            }
          ]
        },
        {
          "type": "error",
          "name": "InvalidCallback",
          "inputs": []
        },
        {
          "type": "error",
          "name": "InvalidSettleData",
          "inputs": [
            {
              "name": "invalidSettleData",
              "type": "bytes",
              "internalType": "bytes"
            }
          ]
        },
        {
          "type": "error",
          "name": "NoSwapOutput",
          "inputs": [
            {
              "name": "inboxForSwap",
              "type": "address",
              "internalType": "address"
            }
          ]
        },
        {
          "type": "error",
          "name": "NotASolver",
          "inputs": [
            {
              "name": "unauthorized",
              "type": "address",
              "internalType": "address"
            }
          ]
        },
        {
          "type": "error",
          "name": "OperationDeadlineExceeded",
          "inputs": [
            {
              "name": "validToTimestamp",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "currentTimestamp",
              "type": "uint256",
              "internalType": "uint256"
            }
          ]
        },
        {
          "type": "error",
          "name": "SubaccountMustBeControlledByOwner",
          "inputs": [
            {
              "name": "subaccount",
              "type": "address",
              "internalType": "address"
            },
            {
              "name": "owner",
              "type": "address",
              "internalType": "address"
            }
          ]
        },
        {
          "type": "error",
          "name": "Unauthorized",
          "inputs": [
            {
              "name": "msgSender",
              "type": "address",
              "internalType": "address"
            }
          ]
        },
        {
          "type": "error",
          "name": "UnexpectedRepayResult",
          "inputs": [
            {
              "name": "expectedRepayAmount",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "actualRepaidAmount",
              "type": "uint256",
              "internalType": "uint256"
            }
          ]
        },
        {
          "type": "error",
          "name": "UnusedPermitSignature",
          "inputs": []
        }
      ],
      "bytecode": "0x6101c0806040523461035f576040816134db80380380916100208285610464565b83398101031261035f57602061003582610487565b9101516001600160a01b038116919082810361035f57608052604051632335c76b60e01b8152602081600481865afa90811561036b575f91610422575b5060a052803b156103dd5760018060a01b031660c052306101005260405160208101907f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f82527f781a7b11c2c4e9a1d12221a40aa1a48cf1b151eb5ed51dad548bf57058db006460408201527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc660608201524660808201523060a082015260a0815261011f60c082610464565b51902060e05261018052600154600181811c911680156103d3575b60208210146103bf57601f811161038a575b507f45756c657220455643202d20436c6f736520506f736974696f6e00000000003460015560405160c081016001600160401b03811182821017610376576040525f815260208101905f825260408101905f8252606081015f815260a060808301925f845201925f8452604051945f602087015260018060a01b03905116604086015251606085015260018060a01b03905116608084015260018060a01b0390511660a08301525160c082015260c0815261020860e082610464565b51610120526002610160527f3cdbf47d3b4f755805c36069980ae18f367b382cf0593fa0378ad50c1c5d1fd861014052608051604051634daa966160e11b815290602090829060049082906001600160a01b03165afa90811561036b575f9161032d575b506101a05260405161303f908161049c82396080518181816110440152611d2f015260a051818181610ed00152610f6b015260c0518181816101f001528181610d5301528181611994015281816120870152612229015260e0518181816109c601526117f001526101005181818161090b0152818161205701526121f9015261012051816117bc015261014051818181610bf001526117990152610160518181816114d901526118e70152610180518161172501526101a0518161035a0152f35b90506020813d602011610363575b8161034860209383610464565b8101031261035f5761035990610487565b5f61026c565b5f80fd5b3d915061033b565b6040513d5f823e3d90fd5b634e487b7160e01b5f52604160045260245ffd5b601a81111561014c5760015f52601f60205f20910160051c5f5b8181106103b257505061014c565b5f838201556001016103a4565b634e487b7160e01b5f52602260045260245ffd5b90607f169061013a565b60405162461bcd60e51b815260206004820152601660248201527f455643206164647265737320697320696e76616c6964000000000000000000006044820152606490fd5b90506020813d60201161045c575b8161043d60209383610464565b8101031261035f57516001600160a01b038116810361035f575f610072565b3d9150610430565b601f909101601f19168101906001600160401b0382119082101761037657604052565b51906001600160a01b038216820361035f5756fe60806040526004361015610011575f80fd5b5f3560e01c8063036b54641461014457806306fdde031461013f5780630c8116701461013a5780630e8d8126146101355780631f4975b8146101305780633644e5151461012b57806343d00ebf146101265780635b0e555614610121578063756fe4811461011c5780637e829b31146101175780639f83a1a714610112578063a5a763b11461010d578063a70354a114610108578063af42b62214610103578063b1e3d3a9146100fe578063c0993eea146100f9578063c6186181146100f4578063d20e71e7146100ef5763ef0fe245146100ea575f80fd5b61102f565b610eff565b610ebb565b610e81565b610e55565b610d82565b610d3e565b610cd4565b610c91565b610bd9565b610b91565b610a54565b610a1f565b6109af565b610974565b61092e565b6108f4565b610801565b61017a565b9181601f84011215610176578235916001600160401b038311610176576020838186019501011161017657565b5f80fd5b34610176576060366003190112610176576004356001600160401b038111610176576101aa903690600401610149565b906024356001600160401b038111610176576101ca903690600401610149565b90916044356001600160401b038111610176576101eb903690600401610149565b9390927f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03163303610757575f5c61022a363661108e565b602081519101200361074857610242915f805d6112b3565b509160608301926004602061026f610263610263885160018060a01b031690565b6001600160a01b031690565b6040516338d52e0f60e01b815292839182905afa8015610586576102e7915f91610719575b5085516001600160a01b0391821695916102b091610263911681565b6020848101805160405163d283e75f60e01b81526001600160a01b0390911660048201529099909490928591829081906024820190565b03915afa928315610586575f936106f8575b50835161031e90610263906001600160a01b03168a516001600160a01b03169061136c565b608085018051909a919691906001600160a01b031693873b15610176576040516302cb8fcf60e11b81526001600160a01b0395861660048201527f000000000000000000000000000000000000000000000000000000000000000090951660248601525f1960448601525f85606481838c5af1948515610586576103a7956106e4575b50611cd8565b86516103bd90610263906001600160a01b031681565b6040516370a0823160e01b81526001600160a01b03851660048201529390602090859060249082905afa938415610586575f946106c3575b506040516370a0823160e01b81526001600160a01b038216600482015293602085602481895afa948515610586575f956106a2575b5084156106865780610615575b50839180851161058b575b508551875160405163047b201f60e11b81526001600160a01b039283166004820152968216602488015260448701849052166064860152602090859060849082905f905af1908115610586576104c8610552927fb7da3f2bd8ad3b81a0a78be2894148169f2266690d7846f43aaf75588f5a0438965f91610557575b5082808214611265565b61051a8160a06105116105036104f56104e7895160018060a01b031690565b9c516001600160a01b031690565b9a516001600160a01b031690565b9b516001600160a01b031690565b95015195611258565b604080516001600160a01b03988916815260208101969096528501919091526060840152908416958416949093169281906080820190565b0390a4005b610579915060203d60201161057f575b61057181836107a8565b81019061123b565b5f6104be565b503d610567565b61110d565b8351919250906001600160a01b0316906105a58186611258565b91833b156101765760405163686dc35960e01b81526001600160a01b03888116600483015291909116602482015260448101929092525f8260648183875af1918215610586576020926105fb575b509190610442565b806106095f61060f936107a8565b8061076a565b5f6105f3565b88516001600160a01b031688516001600160a01b0316833b156101765760405163686dc35960e01b81526001600160a01b0392831660048201529116602482015260448101919091525f8160648183865af18015610586571561043757806106095f610680936107a8565b5f610437565b63f787820760e01b5f526001600160a01b03821660045260245ffd5b6106bc91955060203d60201161057f5761057181836107a8565b935f61042a565b6106dd91945060203d60201161057f5761057181836107a8565b925f6103f5565b806106095f6106f2936107a8565b5f6103a1565b61071291935060203d60201161057f5761057181836107a8565b915f6102f9565b61073b915060203d602011610741575b61073381836107a8565b810190611226565b5f610294565b503d610729565b63f7a632f560e01b5f5260045ffd5b63472511eb60e11b5f523360045260245ffd5b5f91031261017657565b634e487b7160e01b5f52604160045260245ffd5b60c081019081106001600160401b038211176107a357604052565b610774565b90601f801991011681019081106001600160401b038211176107a357604052565b805180835260209291819084018484015e5f828201840152601f01601f1916010190565b9060206107fe9281815201906107c9565b90565b34610176575f366003190112610176576040515f6001548060011c90600181169081156108ea575b6020831082146108d65782855260208501919081156108bd575060011461086b575b6108678461085b818603826107a8565b604051918291826107ed565b0390f35b60015f9081529250907fb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf65b8184106108a95750500161085b8261084b565b805484840152602090930192600101610896565b60ff191682525090151560051b01905061085b8261084b565b634e487b7160e01b5f52602260045260245ffd5b91607f1691610829565b34610176575f3660031901126101765760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b34610176575f36600319011261017657610867610d216040519061095560208201836107a8565b8082526122e960208301396040519182916020835260208301906107c9565b34610176576020366003190112610176576004356001600160401b038111610176576109a76109ad913690600401610149565b906112b3565b005b34610176575f3660031901126101765760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b6001600160a01b0381160361017657565b604090600319011261017657600435610a12816109e9565b906024356107fe816109e9565b34610176576020610a41610a32366109fa565b6001600160a01b03929161136c565b16604051908152f35b8015150361017657565b3461017657604036600319011261017657600435602435610a7481610a4a565b335f525f60205260405f20825f526020527fc7a17c84cfc6bd62e248dc40d0d98f59040bcfbba3ed5cfe5a87aac90152ca7460405f205414610b7a578015610b3357335f908152602081905260409020610b0190610adc9084905b905f5260205260405f2090565b7ffdeb67b02819f1ab9c0e57355ac925e9fe35883f75ef41b364cd780799c5998a9055565b604051901515815233907fc96db6e691f7453f4a948b101f35561af4e2acf852cd1b95698ba775717a816a90602090a3005b335f908152602081905260409020610b7590610b50908490610acf565b7fc7a17c84cfc6bd62e248dc40d0d98f59040bcfbba3ed5cfe5a87aac90152ca749055565b610b01565b5063ae9c304b60e01b5f523360045260245260445ffd5b3461017657604036600319011261017657600435610bae816109e9565b6001600160a01b03165f90815260208181526040808320602435845282529182902054915191825290f35b34610176575f3660031901126101765760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b60405190610c226080836107a8565b565b60c09060031901126101765760405190610c3d82610788565b81600435610c4a816109e9565b8152602435610c58816109e9565b60208201526044356040820152606435610c71816109e9565b6060820152608435610c82816109e9565b608082015260a060a435910152565b346101765760c036600319011261017657610867610cc0610cb136610c24565b610cba816114c7565b50611685565b6040519182916020835260208301906107c9565b3461017657604036600319011261017657600435610cf1816109e9565b6024359060018060a01b03165f525f60205260405f20905f5260205260207ffdeb67b02819f1ab9c0e57355ac925e9fe35883f75ef41b364cd780799c5998a60405f205414604051908152f35b34610176575f366003190112610176576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b3461017657610d99610d93366109fa565b906116d0565b505060405160208101907f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f82527f5ded6f32275d04598307fdd0376cd6b84c395e7c443fc9c56c4d33bbed4812c560408201527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6606082015246608082015260018060a01b03831660a082015260a08152610e3560c0826107a8565b519020604080516001600160a01b03939093168352602083019190915290f35b346101765760c0366003190112610176576020610e79610e7436610c24565b61178e565b604051908152f35b34610176575f3660031901126101765760206040517f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f8152f35b34610176575f366003190112610176576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b34610176576040366003190112610176576004356001600160401b03811161017657610f2f903690600401610149565b6024356001600160401b03811161017657610f4e903690600401610149565b6040516302cc250d60e01b815233600482015293916020856024817f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165afa948515610586576109ad95610fb3915f91611000575b503390611118565b610ff882610fe5610fe0610fd9610fd3610fcd8588611140565b906111bc565b60f01c90565b61ffff1690565b611206565b610ff081838661114e565b9590946111a4565b94909361181d565b611022915060203d602011611028575b61101a81836107a8565b8101906110f8565b5f610fab565b503d611010565b34610176575f366003190112610176576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b6001600160401b0381116107a357601f01601f191660200190565b91909161109a81611073565b6110a760405191826107a8565b809382825282116101765781815f9384602080950137010152565b9291926110ce82611073565b916110dc60405193846107a8565b829481845281830111610176578281602093845f960137010152565b9081602091031261017657516107fe81610a4a565b6040513d5f823e3d90fd5b156111205750565b6363546f7f60e01b5f9081526001600160a01b0391909116600452602490fd5b906002116101765790600290565b909291928360021161017657831161017657600201916001190190565b906014116101765790601490565b909291928360141161017657831161017657601401916013190190565b906004116101765790600490565b90939293848311610176578411610176578101920390565b356001600160f01b03198116929190600282106111d7575050565b6001600160f01b031960029290920360031b82901b16169150565b634e487b7160e01b5f52601160045260245ffd5b600201908160021161121457565b6111f2565b9190820180921161121457565b9081602091031261017657516107fe816109e9565b90816020910312610176575190565b5f1981019190821161121457565b9190820391821161121457565b1561126e575050565b6304fc1ea960e41b5f5260045260245260445ffd5b6040519061129082610788565b5f60a0838281528260208201528260408201528260608201528260808201520152565b906112bc611283565b50810181810360e081126101765760c01361017657604051916112de83610788565b80356112e9816109e9565b835260208101356112f9816109e9565b6020840152604081013560408401526060810135611316816109e9565b60608401526080810135611329816109e9565b608084015260a081013560a084015260c0810135906001600160401b03821161017657019080601f8301121561017657816020611368933591016110c2565b9091565b90611376916116d0565b823b1561138c575b50506001600160a01b031690565b8151156113f45781516001600160a01b03926020015ff51680156113e0576001600160a01b038216036113c0575f8061137e565b63f050016760e01b5f9081526001600160a01b0391909116600452602490fd5b3d6105865763b06ebf3d60e01b5f5260045ffd5b631328927760e21b5f5260045ffd5b6001600160401b0381116107a35760051b60200190565b9061142482611403565b61143160405191826107a8565b8281528092611442601f1991611403565b015f5b81811061145157505050565b6040519060808201918083106001600160401b038411176107a3576020926040525f81525f838201525f604082015260608082015282828601015201611445565b80511561149f5760200190565b634e487b7160e01b5f52603260045260245ffd5b805182101561149f5760209160051b010190565b6114d090611def565b906115026114fd7f000000000000000000000000000000000000000000000000000000000000000061124a565b61141a565b82519092906001600160a01b031660208201805190916115bd9161154291611532916001600160a01b0316610d93565b505092516001600160a01b031690565b60808401516115939060a0906001600160a01b031695015160405163a9059cbb60e01b60208201526001600160a01b039095166024860152604485015283606481015b03601f1981018552846107a8565b6115ad61159e610c13565b6001600160a01b039095168552565b6001600160a01b03166020840152565b5f604083015260608201526115d183611492565b526115db82611492565b50600190565b602081016020825282518091526040820191602060408360051b8301019401925f915b83831061161357505050505090565b9091929394602080611664600193603f19868203018752608060608b51878060a01b038151168452878060a01b038682015116868501526040810151604085015201519181606082015201906107c9565b97019301930191939290611604565b805191908290602001825e015f815290565b60206115856116b36116c294610e746107fe9560405194859163305ab9e960e21b88840152602483016115e1565b60405194859284840190611673565b9081520380845201826107a8565b604051611773926001600160a01b03169161178b919061178190610d216116fa60208201856107a8565b8084526122e960208501396040519030602083015260018060a01b0316604082015260018060a01b037f0000000000000000000000000000000000000000000000000000000000000000166060820152606081526117596080826107a8565b60405195869161176d602084018096611673565b90611673565b03601f1981018652856107a8565b8351902082611dfb565b92565b604290601f190180517f000000000000000000000000000000000000000000000000000000000000000082527f0000000000000000000000000000000000000000000000000000000000000000602001822091526040519061190160f01b82527f0000000000000000000000000000000000000000000000000000000000000000600283015260228201522090565b611884611892929561186095976118726118378a886112b3565b97909a604051998a97602089019c8d62dad51960e21b9052606060248b015260848a0191611beb565b87810360231901604489015291611beb565b84810360231901606486015291611beb565b03601f1981018452836107a8565b8351602085015160408601516001600160a01b03808416976001600160681b0319606095861b81169792851696958a959294926118d79287928a92901b168a14611e25565b845115611b86575b61196961190b7f000000000000000000000000000000000000000000000000000000000000000061141a565b9861192a858b8561191b836114c7565b9a908b15611b78578c93612023565b90845190205f5d611939610c13565b308152933060208601525f6040860152606085015261195781611e8b565b93611962828c6114b3565b52896114b3565b508315611b70575b9161198a91611990938a611983611e70565b928b6121c7565b91611e99565b84527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031693843b15610176575f6119e3916040518093819263305ab9e960e21b8352600483016115e1565b038183895af1801561058657611b5c575b505115611a02575b50505050565b60405163b03c130d60e01b81526001600160681b0319929092166004830152306024830152602082604481865afa918215610586575f92611b3b575b5060016001600160a01b03858318161b8216611add575b8314159081611ad0575b50611a6c575b80806119fc565b803b1561017657604051634fae231560e11b81526001600160a01b039290921660048301523060248301525f60448301819052908290606490829084905af1801561058657611abc575b80611a65565b806106095f611aca936107a8565b5f611ab6565b600191501615155f611a5f565b823b1561017657604051634fae231560e11b81526001600160a01b03821660048201523060248201525f604482018190528160648183885af1801561058657611b27575b50611a55565b806106095f611b35936107a8565b5f611b21565b611b5591925060203d60201161057f5761057181836107a8565b905f611a3e565b806106095f611b6a936107a8565b5f6119f4565b5f9350611971565b611b80611e70565b93612023565b611b98611b928461178e565b85611eaf565b611ba6428242811015611e52565b6118df565b356bffffffffffffffffffffffff19811692919060148210611bcb575050565b6bffffffffffffffffffffffff1960149290920360031b82901b16169150565b908060209392818452848401375f828201840152601f01601f1916010190565b9290611c24906107fe9593604086526040860191611beb565b926020818503910152611beb565b356001600160e01b0319811692919060048210611c4d575050565b6001600160e01b031960049290920360031b82901b16169150565b91909115611c74575050565b611c986040519283926360de6df360e11b8452602060048501526024840191611beb565b0390fd5b908092918237015f815290565b3d15611cd3573d90611cba82611073565b91611cc860405193846107a8565b82523d5f602084013e565b606090565b91909280155f14611d725750508181611d1b8282611cf85f978897611196565b6313d79a0b60e01b916001600160e01b031991611d1491611c32565b1614611c68565b611d2a60405180938193611c9c565b0390827f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165af1611d61611ca9565b9015611d6a5750565b602081519101fd5b8080611d93611d8d611d87611d99958761116b565b90611bab565b60601c90565b93611179565b9390916001600160a01b031690813b15610176575f8094611dd06040519788968795869463d20e71e760e01b865260048601611c0b565b03925af1801561058657611de15750565b806106095f610c22936107a8565b611df7611283565b5090565b90600b9160405191604083015260208201523081520160ff8153605590206001600160a01b031690565b15611e2e575050565b632bf6252360e21b5f9081526001600160a01b039182166004529116602452604490fd5b15611e5b575050565b6302232baf60e51b5f5260045260245260445ffd5b60405190611e7f6020836107a8565b5f808352366020840137565b5f1981146112145760010190565b15611ea057565b638533e92760e01b5f5260045ffd5b60018060a01b03811690815f525f60205260405f20835f526020527ffdeb67b02819f1ab9c0e57355ac925e9fe35883f75ef41b364cd780799c5998a60405f2054145f14611f3d57610b5083610acf611f179360018060a01b03165f525f60205260405f2090565b7fb7c8974e057303dd6a257526d2baec5ecd92237f586b8e622451647cb37cee6f5f80a3565b6001600160a01b0381165f9081526020819052604090208390815f526020527fc7a17c84cfc6bd62e248dc40d0d98f59040bcfbba3ed5cfe5a87aac90152ca7460405f2054145f14611fa95763ae9c304b60e01b5f526001600160a01b0390911660045260245260445ffd5b635ae2147960e01b5f526001600160a01b0390911660045260245260445ffd5b95926107fe979592612015959260018060a01b0316885260018060a01b031660208801526040870152606086015260808501525f60a085015261010060c08501526101008401906107c9565b9160e08184039101526107c9565b91929493905f93825115155f146121725760405163096b649b60e11b81526001600160681b0319606083901b1660048201527f0000000000000000000000000000000000000000000000000000000000000000602482018190526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016989094906020836044818d5afa90811561058657611df799612106966120f8955f9461214b575b50906120d991611685565b91604051978896635bedd1cd60e01b6020890152309060248901611fc9565b03601f1981018352826107a8565b612120612111610c13565b6001600160a01b039096168652565b5f60208601525f6040860152606085015261213a82611e8b565b9361214583836114b3565b526114b3565b6120d99291945061216a9060203d60201161057f5761057181836107a8565b9390916120ce565b50935050939250505f5b81518110156121b957806121b2612195600193856114b3565b516121a0835f611219565b906121ab82896114b3565b52866114b3565b500161217c565b506107fe919250515f611219565b84519295939491939092156122a25760405163096b649b60e11b81526001600160681b0319606088901b1660048201527f0000000000000000000000000000000000000000000000000000000000000000602482018190526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169790939091906020826044818c5afa801561058657611df798612106956120f8945f9361227d575b506120d9906060611685565b6120d991935061229b9060203d60201161057f5761057181836107a8565b9290612271565b505093925090505f5b6060518110156122d857806122d16122c660019360606114b3565b516121a08386611219565b50016122ab565b506107fe9192506060519061121956fe61012080604052346101eb57606081610d21803803809161002082856101ef565b8339810103126101eb5761003381610226565b9061004c604061004560208401610226565b9201610226565b9160c05260e052806101005260405160208101905f516020610d015f395f51905f5282527f5ded6f32275d04598307fdd0376cd6b84c395e7c443fc9c56c4d33bbed4812c560408201527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc660608201524660808201523060a082015260a081526100d760c0826101ef565b51902060805260405160208101915f516020610d015f395f51905f5283527f6c85c0337eba1661327f94f3bf46c8a7f9311a563f4d5c948362567f5d8ed60c60408301527ff9446b8e937d86f0bc87cac73923491692b123ca5f8761908494703758206adf606083015246608083015260018060a01b031660a082015260a0815261016360c0826101ef565b51902060a052604051610ac6908161023b823960805181818161039a015261054b015260a0518181816103e101526104cd015260c05181818160c901528181610201015281816105800152610686015260e0518181816101180152818161045d015281816105050152818161064301526106fb01526101005181818161072c01526107c60152f35b5f80fd5b601f909101601f19168101906001600160401b0382119082101761021257604052565b634e487b7160e01b5f52604160045260245ffd5b51906001600160a01b03821682036101eb5756fe60806040526004361015610011575f80fd5b5f3560e01c806305971f9e146100b457806308f6403e146100af5780631626ba7e146100aa5780632a33a7f7146100a55780632f99c6cc146100a057806364b2a4271461009b578063686dc35914610096578063983d273714610091578063ec6cb13f1461008c5763ef0fe24514610087575f80fd5b6107b1565b6106b5565b610671565b61056e565b610534565b6104f0565b6104b6565b610307565b6101c6565b34610146576101126100c53661018c565b91337f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316148015610114575b6101049033906107f5565b6001600160a01b0316610937565b005b50337f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316146100f9565b5f80fd5b600435906001600160a01b038216820361014657565b602435906001600160a01b038216820361014657565b606435906001600160a01b038216820361014657565b6060906003190112610146576004356001600160a01b038116810361014657906024356001600160a01b0381168103610146579060443590565b346101465760803660031901126101465761027260206101e461014a565b6101ec610160565b9060443561023b81836101fd610176565b95337f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316148015610114576101049033906107f5565b60405163acb7081560e01b815260048101919091526001600160a01b039092166024830152909283919082905f9082906044820190565b03926001600160a01b03165af180156102d4576102a1915f916102a5575b506040519081529081906020820190565b0390f35b6102c7915060203d6020116102cd575b6102bf8183610831565b810190610858565b5f610290565b503d6102b5565b610867565b9181601f840112156101465782359167ffffffffffffffff8311610146576020838186019501011161014657565b346101465760403660031901126101465760043560243567ffffffffffffffff81116101465761033b9036906004016102d9565b9061034c82826101c1821015610892565b6101a061036461035d8480856108c6565b36916108f1565b7fd5a25ba2e97094ad7d83dc28a6572da797d6b3e7fc6663bd93efb789fc17e48981522060405161190160f01b602082019081527f00000000000000000000000000000000000000000000000000000000000000006022830152604280830193909352828252909491906103d9606287610831565b8181209560227f0000000000000000000000000000000000000000000000000000000000000000910152208181036104975760205f8661041987876108e3565b50604080519283528181013560f81c6020840152813590830152830135606082015281805260809060015afa156102d4575f51610485906001600160a01b038082167f0000000000000000000000000000000000000000000000000000000000000000909116146107f5565b604051630b135d3f60e11b8152602090f35b631993489960e11b5f5260045260245260445ffd5b5f91031261014657565b34610146575f3660031901126101465760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b34610146575f366003190112610146576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b34610146575f3660031901126101465760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b346101465761057c3661018c565b91337f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031614801561063f575b6105bb9033906107f5565b60405163a9059cbb60e01b5f9081526001600160a01b0393841660045260249490945291169160209060448180865af160015f5114811615610620575b6040919091521561060557005b635274afe760e01b5f526001600160a01b031660045260245ffd5b6001811516610636573d15833b151516166105f8565b503d5f823e3d90fd5b50337f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316146105b0565b34610146575f366003190112610146576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b346101465760403660031901126101465760043567ffffffffffffffff8111610146576106e69036906004016102d9565b90602435918215158093036101465761072a337f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681146107f5565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316803b15610146575f9283610787936040519687958694859363ec6cb13f60e01b8552604060048601526044850191610872565b90602483015203925af180156102d45761079d57005b806107ab5f61011293610831565b806104ac565b34610146575f366003190112610146576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b156107fd5750565b63472511eb60e11b5f9081526001600160a01b0391909116600452602490fd5b634e487b7160e01b5f52604160045260245ffd5b90601f8019910116810190811067ffffffffffffffff82111761085357604052565b61081d565b90816020910312610146575190565b6040513d5f823e3d90fd5b908060209392818452848401375f828201840152601f01601f1916010190565b9190911561089e575050565b6108c260405192839263098d042f60e21b8452602060048501526024840191610872565b0390fd5b909291928360411161014657831161014657604101916040190190565b906041116101465790604190565b92919267ffffffffffffffff8211610853576040519161091b601f8201601f191660200184610831565b829481845281830111610146578281602093845f960137010152565b60405163095ea7b360e01b5f9081526001600160a01b03841660045260248590529193929160209060448180885af19060015f51148216156109e1575b6040521561098157505050565b61098b81846109f0565b156109c3579061099b9183610a55565b156109a35750565b635274afe760e01b5f9081526001600160a01b0391909116600452602490fd5b635274afe760e01b5f9081526001600160a01b038416600452602490fd5b90843b15153d15161690610974565b60405163095ea7b360e01b5f9081526001600160a01b03909316600452602483905290929160209060448180875af19260015f5114841615610a33575b50604052565b60018492941516610a4c573b15153d151616915f610a2d565b833d5f823e3d90fd5b92916040519163095ea7b360e01b5f5260018060a01b031660045260245260205f60448180875af19260015f5114841615610a33575060405256fea2646970667358221220c33da517eb778abccebc61f27dfdc113d16f2bdd7dcbf74ded048a88b21027a964736f6c634300082100338b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400fa2646970667358221220315a0c89ee5619f53fbf16546db52bb20356768a79bebbbea9488b4faf9e248564736f6c63430008210033",
      "deployedBytecode": "0x60806040526004361015610011575f80fd5b5f3560e01c8063036b54641461014457806306fdde031461013f5780630c8116701461013a5780630e8d8126146101355780631f4975b8146101305780633644e5151461012b57806343d00ebf146101265780635b0e555614610121578063756fe4811461011c5780637e829b31146101175780639f83a1a714610112578063a5a763b11461010d578063a70354a114610108578063af42b62214610103578063b1e3d3a9146100fe578063c0993eea146100f9578063c6186181146100f4578063d20e71e7146100ef5763ef0fe245146100ea575f80fd5b61102f565b610eff565b610ebb565b610e81565b610e55565b610d82565b610d3e565b610cd4565b610c91565b610bd9565b610b91565b610a54565b610a1f565b6109af565b610974565b61092e565b6108f4565b610801565b61017a565b9181601f84011215610176578235916001600160401b038311610176576020838186019501011161017657565b5f80fd5b34610176576060366003190112610176576004356001600160401b038111610176576101aa903690600401610149565b906024356001600160401b038111610176576101ca903690600401610149565b90916044356001600160401b038111610176576101eb903690600401610149565b9390927f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03163303610757575f5c61022a363661108e565b602081519101200361074857610242915f805d6112b3565b509160608301926004602061026f610263610263885160018060a01b031690565b6001600160a01b031690565b6040516338d52e0f60e01b815292839182905afa8015610586576102e7915f91610719575b5085516001600160a01b0391821695916102b091610263911681565b6020848101805160405163d283e75f60e01b81526001600160a01b0390911660048201529099909490928591829081906024820190565b03915afa928315610586575f936106f8575b50835161031e90610263906001600160a01b03168a516001600160a01b03169061136c565b608085018051909a919691906001600160a01b031693873b15610176576040516302cb8fcf60e11b81526001600160a01b0395861660048201527f000000000000000000000000000000000000000000000000000000000000000090951660248601525f1960448601525f85606481838c5af1948515610586576103a7956106e4575b50611cd8565b86516103bd90610263906001600160a01b031681565b6040516370a0823160e01b81526001600160a01b03851660048201529390602090859060249082905afa938415610586575f946106c3575b506040516370a0823160e01b81526001600160a01b038216600482015293602085602481895afa948515610586575f956106a2575b5084156106865780610615575b50839180851161058b575b508551875160405163047b201f60e11b81526001600160a01b039283166004820152968216602488015260448701849052166064860152602090859060849082905f905af1908115610586576104c8610552927fb7da3f2bd8ad3b81a0a78be2894148169f2266690d7846f43aaf75588f5a0438965f91610557575b5082808214611265565b61051a8160a06105116105036104f56104e7895160018060a01b031690565b9c516001600160a01b031690565b9a516001600160a01b031690565b9b516001600160a01b031690565b95015195611258565b604080516001600160a01b03988916815260208101969096528501919091526060840152908416958416949093169281906080820190565b0390a4005b610579915060203d60201161057f575b61057181836107a8565b81019061123b565b5f6104be565b503d610567565b61110d565b8351919250906001600160a01b0316906105a58186611258565b91833b156101765760405163686dc35960e01b81526001600160a01b03888116600483015291909116602482015260448101929092525f8260648183875af1918215610586576020926105fb575b509190610442565b806106095f61060f936107a8565b8061076a565b5f6105f3565b88516001600160a01b031688516001600160a01b0316833b156101765760405163686dc35960e01b81526001600160a01b0392831660048201529116602482015260448101919091525f8160648183865af18015610586571561043757806106095f610680936107a8565b5f610437565b63f787820760e01b5f526001600160a01b03821660045260245ffd5b6106bc91955060203d60201161057f5761057181836107a8565b935f61042a565b6106dd91945060203d60201161057f5761057181836107a8565b925f6103f5565b806106095f6106f2936107a8565b5f6103a1565b61071291935060203d60201161057f5761057181836107a8565b915f6102f9565b61073b915060203d602011610741575b61073381836107a8565b810190611226565b5f610294565b503d610729565b63f7a632f560e01b5f5260045ffd5b63472511eb60e11b5f523360045260245ffd5b5f91031261017657565b634e487b7160e01b5f52604160045260245ffd5b60c081019081106001600160401b038211176107a357604052565b610774565b90601f801991011681019081106001600160401b038211176107a357604052565b805180835260209291819084018484015e5f828201840152601f01601f1916010190565b9060206107fe9281815201906107c9565b90565b34610176575f366003190112610176576040515f6001548060011c90600181169081156108ea575b6020831082146108d65782855260208501919081156108bd575060011461086b575b6108678461085b818603826107a8565b604051918291826107ed565b0390f35b60015f9081529250907fb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf65b8184106108a95750500161085b8261084b565b805484840152602090930192600101610896565b60ff191682525090151560051b01905061085b8261084b565b634e487b7160e01b5f52602260045260245ffd5b91607f1691610829565b34610176575f3660031901126101765760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b34610176575f36600319011261017657610867610d216040519061095560208201836107a8565b8082526122e960208301396040519182916020835260208301906107c9565b34610176576020366003190112610176576004356001600160401b038111610176576109a76109ad913690600401610149565b906112b3565b005b34610176575f3660031901126101765760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b6001600160a01b0381160361017657565b604090600319011261017657600435610a12816109e9565b906024356107fe816109e9565b34610176576020610a41610a32366109fa565b6001600160a01b03929161136c565b16604051908152f35b8015150361017657565b3461017657604036600319011261017657600435602435610a7481610a4a565b335f525f60205260405f20825f526020527fc7a17c84cfc6bd62e248dc40d0d98f59040bcfbba3ed5cfe5a87aac90152ca7460405f205414610b7a578015610b3357335f908152602081905260409020610b0190610adc9084905b905f5260205260405f2090565b7ffdeb67b02819f1ab9c0e57355ac925e9fe35883f75ef41b364cd780799c5998a9055565b604051901515815233907fc96db6e691f7453f4a948b101f35561af4e2acf852cd1b95698ba775717a816a90602090a3005b335f908152602081905260409020610b7590610b50908490610acf565b7fc7a17c84cfc6bd62e248dc40d0d98f59040bcfbba3ed5cfe5a87aac90152ca749055565b610b01565b5063ae9c304b60e01b5f523360045260245260445ffd5b3461017657604036600319011261017657600435610bae816109e9565b6001600160a01b03165f90815260208181526040808320602435845282529182902054915191825290f35b34610176575f3660031901126101765760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b60405190610c226080836107a8565b565b60c09060031901126101765760405190610c3d82610788565b81600435610c4a816109e9565b8152602435610c58816109e9565b60208201526044356040820152606435610c71816109e9565b6060820152608435610c82816109e9565b608082015260a060a435910152565b346101765760c036600319011261017657610867610cc0610cb136610c24565b610cba816114c7565b50611685565b6040519182916020835260208301906107c9565b3461017657604036600319011261017657600435610cf1816109e9565b6024359060018060a01b03165f525f60205260405f20905f5260205260207ffdeb67b02819f1ab9c0e57355ac925e9fe35883f75ef41b364cd780799c5998a60405f205414604051908152f35b34610176575f366003190112610176576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b3461017657610d99610d93366109fa565b906116d0565b505060405160208101907f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f82527f5ded6f32275d04598307fdd0376cd6b84c395e7c443fc9c56c4d33bbed4812c560408201527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6606082015246608082015260018060a01b03831660a082015260a08152610e3560c0826107a8565b519020604080516001600160a01b03939093168352602083019190915290f35b346101765760c0366003190112610176576020610e79610e7436610c24565b61178e565b604051908152f35b34610176575f3660031901126101765760206040517f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f8152f35b34610176575f366003190112610176576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b34610176576040366003190112610176576004356001600160401b03811161017657610f2f903690600401610149565b6024356001600160401b03811161017657610f4e903690600401610149565b6040516302cc250d60e01b815233600482015293916020856024817f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165afa948515610586576109ad95610fb3915f91611000575b503390611118565b610ff882610fe5610fe0610fd9610fd3610fcd8588611140565b906111bc565b60f01c90565b61ffff1690565b611206565b610ff081838661114e565b9590946111a4565b94909361181d565b611022915060203d602011611028575b61101a81836107a8565b8101906110f8565b5f610fab565b503d611010565b34610176575f366003190112610176576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b6001600160401b0381116107a357601f01601f191660200190565b91909161109a81611073565b6110a760405191826107a8565b809382825282116101765781815f9384602080950137010152565b9291926110ce82611073565b916110dc60405193846107a8565b829481845281830111610176578281602093845f960137010152565b9081602091031261017657516107fe81610a4a565b6040513d5f823e3d90fd5b156111205750565b6363546f7f60e01b5f9081526001600160a01b0391909116600452602490fd5b906002116101765790600290565b909291928360021161017657831161017657600201916001190190565b906014116101765790601490565b909291928360141161017657831161017657601401916013190190565b906004116101765790600490565b90939293848311610176578411610176578101920390565b356001600160f01b03198116929190600282106111d7575050565b6001600160f01b031960029290920360031b82901b16169150565b634e487b7160e01b5f52601160045260245ffd5b600201908160021161121457565b6111f2565b9190820180921161121457565b9081602091031261017657516107fe816109e9565b90816020910312610176575190565b5f1981019190821161121457565b9190820391821161121457565b1561126e575050565b6304fc1ea960e41b5f5260045260245260445ffd5b6040519061129082610788565b5f60a0838281528260208201528260408201528260608201528260808201520152565b906112bc611283565b50810181810360e081126101765760c01361017657604051916112de83610788565b80356112e9816109e9565b835260208101356112f9816109e9565b6020840152604081013560408401526060810135611316816109e9565b60608401526080810135611329816109e9565b608084015260a081013560a084015260c0810135906001600160401b03821161017657019080601f8301121561017657816020611368933591016110c2565b9091565b90611376916116d0565b823b1561138c575b50506001600160a01b031690565b8151156113f45781516001600160a01b03926020015ff51680156113e0576001600160a01b038216036113c0575f8061137e565b63f050016760e01b5f9081526001600160a01b0391909116600452602490fd5b3d6105865763b06ebf3d60e01b5f5260045ffd5b631328927760e21b5f5260045ffd5b6001600160401b0381116107a35760051b60200190565b9061142482611403565b61143160405191826107a8565b8281528092611442601f1991611403565b015f5b81811061145157505050565b6040519060808201918083106001600160401b038411176107a3576020926040525f81525f838201525f604082015260608082015282828601015201611445565b80511561149f5760200190565b634e487b7160e01b5f52603260045260245ffd5b805182101561149f5760209160051b010190565b6114d090611def565b906115026114fd7f000000000000000000000000000000000000000000000000000000000000000061124a565b61141a565b82519092906001600160a01b031660208201805190916115bd9161154291611532916001600160a01b0316610d93565b505092516001600160a01b031690565b60808401516115939060a0906001600160a01b031695015160405163a9059cbb60e01b60208201526001600160a01b039095166024860152604485015283606481015b03601f1981018552846107a8565b6115ad61159e610c13565b6001600160a01b039095168552565b6001600160a01b03166020840152565b5f604083015260608201526115d183611492565b526115db82611492565b50600190565b602081016020825282518091526040820191602060408360051b8301019401925f915b83831061161357505050505090565b9091929394602080611664600193603f19868203018752608060608b51878060a01b038151168452878060a01b038682015116868501526040810151604085015201519181606082015201906107c9565b97019301930191939290611604565b805191908290602001825e015f815290565b60206115856116b36116c294610e746107fe9560405194859163305ab9e960e21b88840152602483016115e1565b60405194859284840190611673565b9081520380845201826107a8565b604051611773926001600160a01b03169161178b919061178190610d216116fa60208201856107a8565b8084526122e960208501396040519030602083015260018060a01b0316604082015260018060a01b037f0000000000000000000000000000000000000000000000000000000000000000166060820152606081526117596080826107a8565b60405195869161176d602084018096611673565b90611673565b03601f1981018652856107a8565b8351902082611dfb565b92565b604290601f190180517f000000000000000000000000000000000000000000000000000000000000000082527f0000000000000000000000000000000000000000000000000000000000000000602001822091526040519061190160f01b82527f0000000000000000000000000000000000000000000000000000000000000000600283015260228201522090565b611884611892929561186095976118726118378a886112b3565b97909a604051998a97602089019c8d62dad51960e21b9052606060248b015260848a0191611beb565b87810360231901604489015291611beb565b84810360231901606486015291611beb565b03601f1981018452836107a8565b8351602085015160408601516001600160a01b03808416976001600160681b0319606095861b81169792851696958a959294926118d79287928a92901b168a14611e25565b845115611b86575b61196961190b7f000000000000000000000000000000000000000000000000000000000000000061141a565b9861192a858b8561191b836114c7565b9a908b15611b78578c93612023565b90845190205f5d611939610c13565b308152933060208601525f6040860152606085015261195781611e8b565b93611962828c6114b3565b52896114b3565b508315611b70575b9161198a91611990938a611983611e70565b928b6121c7565b91611e99565b84527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031693843b15610176575f6119e3916040518093819263305ab9e960e21b8352600483016115e1565b038183895af1801561058657611b5c575b505115611a02575b50505050565b60405163b03c130d60e01b81526001600160681b0319929092166004830152306024830152602082604481865afa918215610586575f92611b3b575b5060016001600160a01b03858318161b8216611add575b8314159081611ad0575b50611a6c575b80806119fc565b803b1561017657604051634fae231560e11b81526001600160a01b039290921660048301523060248301525f60448301819052908290606490829084905af1801561058657611abc575b80611a65565b806106095f611aca936107a8565b5f611ab6565b600191501615155f611a5f565b823b1561017657604051634fae231560e11b81526001600160a01b03821660048201523060248201525f604482018190528160648183885af1801561058657611b27575b50611a55565b806106095f611b35936107a8565b5f611b21565b611b5591925060203d60201161057f5761057181836107a8565b905f611a3e565b806106095f611b6a936107a8565b5f6119f4565b5f9350611971565b611b80611e70565b93612023565b611b98611b928461178e565b85611eaf565b611ba6428242811015611e52565b6118df565b356bffffffffffffffffffffffff19811692919060148210611bcb575050565b6bffffffffffffffffffffffff1960149290920360031b82901b16169150565b908060209392818452848401375f828201840152601f01601f1916010190565b9290611c24906107fe9593604086526040860191611beb565b926020818503910152611beb565b356001600160e01b0319811692919060048210611c4d575050565b6001600160e01b031960049290920360031b82901b16169150565b91909115611c74575050565b611c986040519283926360de6df360e11b8452602060048501526024840191611beb565b0390fd5b908092918237015f815290565b3d15611cd3573d90611cba82611073565b91611cc860405193846107a8565b82523d5f602084013e565b606090565b91909280155f14611d725750508181611d1b8282611cf85f978897611196565b6313d79a0b60e01b916001600160e01b031991611d1491611c32565b1614611c68565b611d2a60405180938193611c9c565b0390827f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165af1611d61611ca9565b9015611d6a5750565b602081519101fd5b8080611d93611d8d611d87611d99958761116b565b90611bab565b60601c90565b93611179565b9390916001600160a01b031690813b15610176575f8094611dd06040519788968795869463d20e71e760e01b865260048601611c0b565b03925af1801561058657611de15750565b806106095f610c22936107a8565b611df7611283565b5090565b90600b9160405191604083015260208201523081520160ff8153605590206001600160a01b031690565b15611e2e575050565b632bf6252360e21b5f9081526001600160a01b039182166004529116602452604490fd5b15611e5b575050565b6302232baf60e51b5f5260045260245260445ffd5b60405190611e7f6020836107a8565b5f808352366020840137565b5f1981146112145760010190565b15611ea057565b638533e92760e01b5f5260045ffd5b60018060a01b03811690815f525f60205260405f20835f526020527ffdeb67b02819f1ab9c0e57355ac925e9fe35883f75ef41b364cd780799c5998a60405f2054145f14611f3d57610b5083610acf611f179360018060a01b03165f525f60205260405f2090565b7fb7c8974e057303dd6a257526d2baec5ecd92237f586b8e622451647cb37cee6f5f80a3565b6001600160a01b0381165f9081526020819052604090208390815f526020527fc7a17c84cfc6bd62e248dc40d0d98f59040bcfbba3ed5cfe5a87aac90152ca7460405f2054145f14611fa95763ae9c304b60e01b5f526001600160a01b0390911660045260245260445ffd5b635ae2147960e01b5f526001600160a01b0390911660045260245260445ffd5b95926107fe979592612015959260018060a01b0316885260018060a01b031660208801526040870152606086015260808501525f60a085015261010060c08501526101008401906107c9565b9160e08184039101526107c9565b91929493905f93825115155f146121725760405163096b649b60e11b81526001600160681b0319606083901b1660048201527f0000000000000000000000000000000000000000000000000000000000000000602482018190526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016989094906020836044818d5afa90811561058657611df799612106966120f8955f9461214b575b50906120d991611685565b91604051978896635bedd1cd60e01b6020890152309060248901611fc9565b03601f1981018352826107a8565b612120612111610c13565b6001600160a01b039096168652565b5f60208601525f6040860152606085015261213a82611e8b565b9361214583836114b3565b526114b3565b6120d99291945061216a9060203d60201161057f5761057181836107a8565b9390916120ce565b50935050939250505f5b81518110156121b957806121b2612195600193856114b3565b516121a0835f611219565b906121ab82896114b3565b52866114b3565b500161217c565b506107fe919250515f611219565b84519295939491939092156122a25760405163096b649b60e11b81526001600160681b0319606088901b1660048201527f0000000000000000000000000000000000000000000000000000000000000000602482018190526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169790939091906020826044818c5afa801561058657611df798612106956120f8945f9361227d575b506120d9906060611685565b6120d991935061229b9060203d60201161057f5761057181836107a8565b9290612271565b505093925090505f5b6060518110156122d857806122d16122c660019360606114b3565b516121a08386611219565b50016122ab565b506107fe9192506060519061121956fe61012080604052346101eb57606081610d21803803809161002082856101ef565b8339810103126101eb5761003381610226565b9061004c604061004560208401610226565b9201610226565b9160c05260e052806101005260405160208101905f516020610d015f395f51905f5282527f5ded6f32275d04598307fdd0376cd6b84c395e7c443fc9c56c4d33bbed4812c560408201527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc660608201524660808201523060a082015260a081526100d760c0826101ef565b51902060805260405160208101915f516020610d015f395f51905f5283527f6c85c0337eba1661327f94f3bf46c8a7f9311a563f4d5c948362567f5d8ed60c60408301527ff9446b8e937d86f0bc87cac73923491692b123ca5f8761908494703758206adf606083015246608083015260018060a01b031660a082015260a0815261016360c0826101ef565b51902060a052604051610ac6908161023b823960805181818161039a015261054b015260a0518181816103e101526104cd015260c05181818160c901528181610201015281816105800152610686015260e0518181816101180152818161045d015281816105050152818161064301526106fb01526101005181818161072c01526107c60152f35b5f80fd5b601f909101601f19168101906001600160401b0382119082101761021257604052565b634e487b7160e01b5f52604160045260245ffd5b51906001600160a01b03821682036101eb5756fe60806040526004361015610011575f80fd5b5f3560e01c806305971f9e146100b457806308f6403e146100af5780631626ba7e146100aa5780632a33a7f7146100a55780632f99c6cc146100a057806364b2a4271461009b578063686dc35914610096578063983d273714610091578063ec6cb13f1461008c5763ef0fe24514610087575f80fd5b6107b1565b6106b5565b610671565b61056e565b610534565b6104f0565b6104b6565b610307565b6101c6565b34610146576101126100c53661018c565b91337f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316148015610114575b6101049033906107f5565b6001600160a01b0316610937565b005b50337f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316146100f9565b5f80fd5b600435906001600160a01b038216820361014657565b602435906001600160a01b038216820361014657565b606435906001600160a01b038216820361014657565b6060906003190112610146576004356001600160a01b038116810361014657906024356001600160a01b0381168103610146579060443590565b346101465760803660031901126101465761027260206101e461014a565b6101ec610160565b9060443561023b81836101fd610176565b95337f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316148015610114576101049033906107f5565b60405163acb7081560e01b815260048101919091526001600160a01b039092166024830152909283919082905f9082906044820190565b03926001600160a01b03165af180156102d4576102a1915f916102a5575b506040519081529081906020820190565b0390f35b6102c7915060203d6020116102cd575b6102bf8183610831565b810190610858565b5f610290565b503d6102b5565b610867565b9181601f840112156101465782359167ffffffffffffffff8311610146576020838186019501011161014657565b346101465760403660031901126101465760043560243567ffffffffffffffff81116101465761033b9036906004016102d9565b9061034c82826101c1821015610892565b6101a061036461035d8480856108c6565b36916108f1565b7fd5a25ba2e97094ad7d83dc28a6572da797d6b3e7fc6663bd93efb789fc17e48981522060405161190160f01b602082019081527f00000000000000000000000000000000000000000000000000000000000000006022830152604280830193909352828252909491906103d9606287610831565b8181209560227f0000000000000000000000000000000000000000000000000000000000000000910152208181036104975760205f8661041987876108e3565b50604080519283528181013560f81c6020840152813590830152830135606082015281805260809060015afa156102d4575f51610485906001600160a01b038082167f0000000000000000000000000000000000000000000000000000000000000000909116146107f5565b604051630b135d3f60e11b8152602090f35b631993489960e11b5f5260045260245260445ffd5b5f91031261014657565b34610146575f3660031901126101465760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b34610146575f366003190112610146576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b34610146575f3660031901126101465760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b346101465761057c3661018c565b91337f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031614801561063f575b6105bb9033906107f5565b60405163a9059cbb60e01b5f9081526001600160a01b0393841660045260249490945291169160209060448180865af160015f5114811615610620575b6040919091521561060557005b635274afe760e01b5f526001600160a01b031660045260245ffd5b6001811516610636573d15833b151516166105f8565b503d5f823e3d90fd5b50337f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316146105b0565b34610146575f366003190112610146576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b346101465760403660031901126101465760043567ffffffffffffffff8111610146576106e69036906004016102d9565b90602435918215158093036101465761072a337f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031681146107f5565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316803b15610146575f9283610787936040519687958694859363ec6cb13f60e01b8552604060048601526044850191610872565b90602483015203925af180156102d45761079d57005b806107ab5f61011293610831565b806104ac565b34610146575f366003190112610146576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b156107fd5750565b63472511eb60e11b5f9081526001600160a01b0391909116600452602490fd5b634e487b7160e01b5f52604160045260245ffd5b90601f8019910116810190811067ffffffffffffffff82111761085357604052565b61081d565b90816020910312610146575190565b6040513d5f823e3d90fd5b908060209392818452848401375f828201840152601f01601f1916010190565b9190911561089e575050565b6108c260405192839263098d042f60e21b8452602060048501526024840191610872565b0390fd5b909291928360411161014657831161014657604101916040190190565b906041116101465790604190565b92919267ffffffffffffffff8211610853576040519161091b601f8201601f191660200184610831565b829481845281830111610146578281602093845f960137010152565b60405163095ea7b360e01b5f9081526001600160a01b03841660045260248590529193929160209060448180885af19060015f51148216156109e1575b6040521561098157505050565b61098b81846109f0565b156109c3579061099b9183610a55565b156109a35750565b635274afe760e01b5f9081526001600160a01b0391909116600452602490fd5b635274afe760e01b5f9081526001600160a01b038416600452602490fd5b90843b15153d15161690610974565b60405163095ea7b360e01b5f9081526001600160a01b03909316600452602483905290929160209060448180875af19260015f5114841615610a33575b50604052565b60018492941516610a4c573b15153d151616915f610a2d565b833d5f823e3d90fd5b92916040519163095ea7b360e01b5f5260018060a01b031660045260245260205f60448180875af19260015f5114841615610a33575060405256fea2646970667358221220c33da517eb778abccebc61f27dfdc113d16f2bdd7dcbf74ded048a88b21027a964736f6c634300082100338b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400fa2646970667358221220315a0c89ee5619f53fbf16546db52bb20356768a79bebbbea9488b4faf9e248564736f6c63430008210033",
      "linkReferences": {},
      "source": {
        "solcVersion": "0.8.33+commit.64118f21",
        "input": "{\"language\":\"Solidity\",\"sources\":{\"lib/euler-vault-kit/lib/ethereum-vault-connector/src/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport {IEVC} from \\\"./interfaces/IEthereumVaultConnector.sol\\\";\\n\\n/// @title Errors\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice This contract implements the error messages for the Ethereum Vault Connector.\\ncontract Errors {\\n    /// @notice Error for when caller is not authorized to perform an operation.\\n    error EVC_NotAuthorized();\\n    /// @notice Error for when no account has been authenticated to act on behalf of.\\n    error EVC_OnBehalfOfAccountNotAuthenticated();\\n    /// @notice Error for when an operator's to be set is no different from the current one.\\n    error EVC_InvalidOperatorStatus();\\n    /// @notice Error for when a nonce is invalid or already used.\\n    error EVC_InvalidNonce();\\n    /// @notice Error for when an address parameter passed is invalid.\\n    error EVC_InvalidAddress();\\n    /// @notice Error for when a timestamp parameter passed is expired.\\n    error EVC_InvalidTimestamp();\\n    /// @notice Error for when a value parameter passed is invalid or exceeds current balance.\\n    error EVC_InvalidValue();\\n    /// @notice Error for when data parameter passed is empty.\\n    error EVC_InvalidData();\\n    /// @notice Error for when an action is prohibited due to the lockdown mode.\\n    error EVC_LockdownMode();\\n    /// @notice Error for when permit execution is prohibited due to the permit disabled mode.\\n    error EVC_PermitDisabledMode();\\n    /// @notice Error for when checks are in progress and reentrancy is not allowed.\\n    error EVC_ChecksReentrancy();\\n    /// @notice Error for when control collateral is in progress and reentrancy is not allowed.\\n    error EVC_ControlCollateralReentrancy();\\n    /// @notice Error for when there is a different number of controllers enabled than expected.\\n    error EVC_ControllerViolation();\\n    /// @notice Error for when a simulation batch is nested within another simulation batch.\\n    error EVC_SimulationBatchNested();\\n    /// @notice Auxiliary error to pass simulation batch results.\\n    error EVC_RevertedBatchResult(\\n        IEVC.BatchItemResult[] batchItemsResult,\\n        IEVC.StatusCheckResult[] accountsStatusResult,\\n        IEVC.StatusCheckResult[] vaultsStatusResult\\n    );\\n    /// @notice Panic error for when simulation does not behave as expected. Should never be observed.\\n    error EVC_BatchPanic();\\n    /// @notice Error for when an empty or undefined error is thrown.\\n    error EVC_EmptyError();\\n}\\n\"},\"lib/euler-vault-kit/lib/ethereum-vault-connector/src/EthereumVaultConnector.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport {Set, SetStorage} from \\\"./Set.sol\\\";\\nimport {Events} from \\\"./Events.sol\\\";\\nimport {Errors} from \\\"./Errors.sol\\\";\\nimport {ExecutionContext, EC} from \\\"./ExecutionContext.sol\\\";\\nimport {TransientStorage} from \\\"./TransientStorage.sol\\\";\\nimport {IEVC} from \\\"./interfaces/IEthereumVaultConnector.sol\\\";\\nimport {IVault} from \\\"./interfaces/IVault.sol\\\";\\nimport {IERC1271} from \\\"./interfaces/IERC1271.sol\\\";\\n\\n/// @title EthereumVaultConnector\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice This contract implements the Ethereum Vault Connector.\\ncontract EthereumVaultConnector is Events, Errors, TransientStorage, IEVC {\\n    using ExecutionContext for EC;\\n    using Set for SetStorage;\\n\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n    //                                       CONSTANTS                                           //\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Name of the Ethereum Vault Connector.\\n    string public constant name = \\\"Ethereum Vault Connector\\\";\\n\\n    uint160 internal constant ACCOUNT_ID_OFFSET = 8;\\n    bytes32 internal constant HASHED_NAME = keccak256(bytes(name));\\n\\n    bytes32 internal constant TYPE_HASH =\\n        keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\");\\n\\n    bytes32 internal constant PERMIT_TYPEHASH = keccak256(\\n        \\\"Permit(address signer,address sender,uint256 nonceNamespace,uint256 nonce,uint256 deadline,uint256 value,bytes data)\\\"\\n    );\\n\\n    uint256 internal immutable CACHED_CHAIN_ID;\\n    bytes32 internal immutable CACHED_DOMAIN_SEPARATOR;\\n\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n    //                                        STORAGE                                            //\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    // EVC implements controller isolation, meaning that unless in transient state, only one controller per account can\\n    // be enabled. However, this can lead to a suboptimal user experience. In the event a user wants to have multiple\\n    // controllers enabled, a separate wallet must be created and funded. Although there is nothing wrong with having\\n    // many accounts within the same wallet, this can be a bad experience. In order to improve on this, EVC supports\\n    // the concept of an owner that owns 256 accounts within EVC.\\n\\n    // Every Ethereum address has 256 accounts in the EVC (including the primary account - called the owner).\\n    // Each account has an account ID from 0-255, where 0 is the owner account's ID. In order to compute the account\\n    // addresses, the account ID is treated as a uint256 and XORed (exclusive ORed) with the Ethereum address.\\n    // In order to record the owner of a group of 256 accounts, the EVC uses a definition of an address prefix.\\n    // An address prefix is a part of an address having the first 19 bytes common with any of the 256 account\\n    // addresses belonging to the same group.\\n    // account/152 -> prefix/152\\n    // To get an address prefix for the account, it's enough to take the account address and right shift it by 8 bits.\\n\\n    // Yes, this reduces the security of addresses by 8 bits, but creating multiple addresses in the wallet also reduces\\n    // security: if somebody is trying to brute-force one of user's N>1 private keys, they have N times as many chances\\n    // of succeeding per guess. It has to be admitted that the EVC model is weaker because finding a private key for\\n    // an owner gives access to all accounts, but there is still a very comfortable security margin.\\n\\n    // Internal data structure that stores the addressPrefix owner and mode flags\\n    struct OwnerStorage {\\n        // The addressPrefix owner\\n        address owner;\\n        // Flag indicating if the addressPrefix is in lockdown mode\\n        bool isLockdownMode;\\n        // Flag indicating if the permit function is disabled for the addressPrefix\\n        bool isPermitDisabledMode;\\n    }\\n\\n    mapping(bytes19 addressPrefix => OwnerStorage) internal ownerLookup;\\n\\n    mapping(bytes19 addressPrefix => mapping(address operator => uint256 operatorBitField)) internal operatorLookup;\\n\\n    mapping(bytes19 addressPrefix => mapping(uint256 nonceNamespace => uint256 nonce)) internal nonceLookup;\\n\\n    mapping(address account => SetStorage) internal accountCollaterals;\\n\\n    mapping(address account => SetStorage) internal accountControllers;\\n\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n    //                                CONSTRUCTOR, FALLBACKS                                     //\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    constructor() {\\n        CACHED_CHAIN_ID = block.chainid;\\n        CACHED_DOMAIN_SEPARATOR = calculateDomainSeparator();\\n    }\\n\\n    /// @notice Fallback function to receive Ether.\\n    receive() external payable {\\n        // only allows to receive value when checks are deferred\\n        if (!executionContext.areChecksDeferred()) {\\n            revert EVC_NotAuthorized();\\n        }\\n    }\\n\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n    //                                       MODIFIERS                                           //\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice A modifier that allows only the address recorded as an owner of the address prefix to call the function.\\n    /// @dev The owner of an address prefix is an address that matches the address that has previously been recorded (or\\n    /// will be) as an owner in the ownerLookup.\\n    /// @param addressPrefix The address prefix for which it is checked whether the caller is the owner.\\n    modifier onlyOwner(bytes19 addressPrefix) {\\n        authenticateCaller({addressPrefix: addressPrefix, allowOperator: false, checkLockdownMode: false});\\n\\n        _;\\n    }\\n\\n    /// @notice A modifier that allows only the owner or an operator of the account to call the function.\\n    /// @dev The owner of an address prefix is an address that matches the address that has previously been recorded (or\\n    /// will be) as an owner in the ownerLookup. An operator of an account is an address that has been authorized by the\\n    /// owner of an account to perform operations on behalf of the owner.\\n    /// @param account The address of the account for which it is checked whether the caller is the owner or an\\n    /// operator.\\n    modifier onlyOwnerOrOperator(address account) {\\n        authenticateCaller({account: account, allowOperator: true, checkLockdownMode: true});\\n\\n        _;\\n    }\\n\\n    /// @notice A modifier checks whether msg.sender is the only controller for the account.\\n    /// @dev The controller cannot use permit function in conjunction with this modifier.\\n    modifier onlyController(address account) {\\n        {\\n            uint256 numOfControllers = accountControllers[account].numElements;\\n            address controller = accountControllers[account].firstElement;\\n\\n            if (numOfControllers != 1) {\\n                revert EVC_ControllerViolation();\\n            }\\n\\n            if (controller != msg.sender) {\\n                revert EVC_NotAuthorized();\\n            }\\n        }\\n\\n        _;\\n    }\\n\\n    /// @notice A modifier that verifies whether account or vault status checks are re-entered.\\n    modifier nonReentrantChecks() {\\n        if (executionContext.areChecksInProgress()) {\\n            revert EVC_ChecksReentrancy();\\n        }\\n\\n        _;\\n    }\\n\\n    /// @notice A modifier that verifies whether account or vault status checks are re-entered as well as checks for\\n    /// controlCollateral re-entrancy.\\n    modifier nonReentrantChecksAndControlCollateral() {\\n        {\\n            EC context = executionContext;\\n\\n            if (context.areChecksInProgress()) {\\n                revert EVC_ChecksReentrancy();\\n            }\\n\\n            if (context.isControlCollateralInProgress()) {\\n                revert EVC_ControlCollateralReentrancy();\\n            }\\n        }\\n\\n        _;\\n    }\\n\\n    /// @notice A modifier that verifies whether account or vault status checks are re-entered and sets the lock.\\n    /// @dev This modifier also clears the current account on behalf of which the operation is performed as it shouldn't\\n    /// be relied upon when the checks are in progress.\\n    modifier nonReentrantChecksAcquireLock() {\\n        EC contextCache = executionContext;\\n\\n        if (contextCache.areChecksInProgress()) {\\n            revert EVC_ChecksReentrancy();\\n        }\\n\\n        executionContext = contextCache.setChecksInProgress().setOnBehalfOfAccount(address(0));\\n\\n        _;\\n\\n        executionContext = contextCache;\\n    }\\n\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n    //                                   PUBLIC FUNCTIONS                                        //\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    // Execution internals\\n\\n    /// @inheritdoc IEVC\\n    function getRawExecutionContext() external view returns (uint256 context) {\\n        context = EC.unwrap(executionContext);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function getCurrentOnBehalfOfAccount(address controllerToCheck)\\n        external\\n        view\\n        returns (address onBehalfOfAccount, bool controllerEnabled)\\n    {\\n        onBehalfOfAccount = executionContext.getOnBehalfOfAccount();\\n\\n        // for safety, revert if no account has been authenticated\\n        if (onBehalfOfAccount == address(0)) {\\n            revert EVC_OnBehalfOfAccountNotAuthenticated();\\n        }\\n\\n        controllerEnabled =\\n            controllerToCheck == address(0) ? false : accountControllers[onBehalfOfAccount].contains(controllerToCheck);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function areChecksDeferred() external view returns (bool) {\\n        return executionContext.areChecksDeferred();\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function areChecksInProgress() external view returns (bool) {\\n        return executionContext.areChecksInProgress();\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function isControlCollateralInProgress() external view returns (bool) {\\n        return executionContext.isControlCollateralInProgress();\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function isOperatorAuthenticated() external view returns (bool) {\\n        return executionContext.isOperatorAuthenticated();\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function isSimulationInProgress() external view returns (bool) {\\n        return executionContext.isSimulationInProgress();\\n    }\\n\\n    // Owners and operators\\n\\n    /// @inheritdoc IEVC\\n    function haveCommonOwner(address account, address otherAccount) external pure returns (bool) {\\n        return haveCommonOwnerInternal(account, otherAccount);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function getAddressPrefix(address account) external pure returns (bytes19) {\\n        return getAddressPrefixInternal(account);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function getAccountOwner(address account) external view returns (address) {\\n        bytes19 addressPrefix = getAddressPrefixInternal(account);\\n        return ownerLookup[addressPrefix].owner;\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function isLockdownMode(bytes19 addressPrefix) external view returns (bool) {\\n        return ownerLookup[addressPrefix].isLockdownMode;\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function isPermitDisabledMode(bytes19 addressPrefix) external view returns (bool) {\\n        return ownerLookup[addressPrefix].isPermitDisabledMode;\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function getNonce(bytes19 addressPrefix, uint256 nonceNamespace) external view returns (uint256) {\\n        return nonceLookup[addressPrefix][nonceNamespace];\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function getOperator(bytes19 addressPrefix, address operator) external view returns (uint256) {\\n        return operatorLookup[addressPrefix][operator];\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function isAccountOperatorAuthorized(address account, address operator) external view returns (bool) {\\n        return isAccountOperatorAuthorizedInternal(account, operator);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function setLockdownMode(bytes19 addressPrefix, bool enabled) public payable virtual onlyOwner(addressPrefix) {\\n        if (ownerLookup[addressPrefix].isLockdownMode != enabled) {\\n            // to increase user security, it is prohibited to disable this mode within the self-call of the permit\\n            // function or within a checks-deferrable call. to disable this mode, the setLockdownMode function must be\\n            // called directly\\n            if (!enabled && (executionContext.areChecksDeferred() || inPermitSelfCall())) {\\n                revert EVC_NotAuthorized();\\n            }\\n\\n            ownerLookup[addressPrefix].isLockdownMode = enabled;\\n            emit LockdownModeStatus(addressPrefix, enabled);\\n        }\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function setPermitDisabledMode(\\n        bytes19 addressPrefix,\\n        bool enabled\\n    ) public payable virtual onlyOwner(addressPrefix) {\\n        if (ownerLookup[addressPrefix].isPermitDisabledMode != enabled) {\\n            // to increase user security, it is prohibited to disable this mode within the self-call of the permit\\n            // function (verified in the permit function) or within a checks-deferrable call. to disable this mode the\\n            // setPermitDisabledMode function must be called directly\\n            if (!enabled && executionContext.areChecksDeferred()) {\\n                revert EVC_NotAuthorized();\\n            }\\n\\n            ownerLookup[addressPrefix].isPermitDisabledMode = enabled;\\n            emit PermitDisabledModeStatus(addressPrefix, enabled);\\n        }\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function setNonce(\\n        bytes19 addressPrefix,\\n        uint256 nonceNamespace,\\n        uint256 nonce\\n    ) public payable virtual onlyOwner(addressPrefix) {\\n        uint256 currentNonce = nonceLookup[addressPrefix][nonceNamespace];\\n\\n        if (currentNonce >= nonce) {\\n            revert EVC_InvalidNonce();\\n        }\\n\\n        nonceLookup[addressPrefix][nonceNamespace] = nonce;\\n\\n        emit NonceStatus(addressPrefix, nonceNamespace, currentNonce, nonce);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    /// @dev Uses authenticateCaller() function instead of onlyOwner() modifier to authenticate and get the caller\\n    /// address at once.\\n    function setOperator(bytes19 addressPrefix, address operator, uint256 operatorBitField) public payable virtual {\\n        address msgSender =\\n            authenticateCaller({addressPrefix: addressPrefix, allowOperator: false, checkLockdownMode: false});\\n\\n        // the operator can neither be the EVC nor can be one of 256 accounts of the owner\\n        if (operator == address(this) || haveCommonOwnerInternal(msgSender, operator)) {\\n            revert EVC_InvalidAddress();\\n        }\\n\\n        if (operatorLookup[addressPrefix][operator] == operatorBitField) {\\n            revert EVC_InvalidOperatorStatus();\\n        } else {\\n            operatorLookup[addressPrefix][operator] = operatorBitField;\\n\\n            emit OperatorStatus(addressPrefix, operator, operatorBitField);\\n        }\\n    }\\n\\n    /// @inheritdoc IEVC\\n    /// @dev Uses authenticateCaller() function instead of onlyOwnerOrOperator() modifier to authenticate and get the\\n    /// caller address at once.\\n    function setAccountOperator(address account, address operator, bool authorized) public payable virtual {\\n        address msgSender = authenticateCaller({account: account, allowOperator: true, checkLockdownMode: false});\\n        bytes19 addressPrefix = getAddressPrefixInternal(account);\\n\\n        // if the account and the caller have a common owner, the caller must be the owner. if the account and the\\n        // caller don't have a common owner, the caller must be an operator and the owner address is taken from the\\n        // storage. the caller authentication above guarantees that the account owner is already registered hence\\n        // non-zero\\n        address owner = haveCommonOwnerInternal(account, msgSender) ? msgSender : ownerLookup[addressPrefix].owner;\\n\\n        // if it's an operator calling, it can only act for itself and must not be able to change other operators status\\n        if (owner != msgSender && operator != msgSender) {\\n            revert EVC_NotAuthorized();\\n        }\\n\\n        // the operator can neither be the EVC nor can be one of 256 accounts of the owner\\n        if (operator == address(this) || haveCommonOwnerInternal(owner, operator)) {\\n            revert EVC_InvalidAddress();\\n        }\\n\\n        // The bitMask defines which accounts the operator is authorized for. The bitMask is created from the account\\n        // number which is a number up to 2^8 in binary, or 256. 1 << (uint160(owner) ^ uint160(account)) transforms\\n        // that number in an 256-position binary array like 0...010...0, marking the account positionally in a uint256.\\n        uint256 bitMask = 1 << (uint160(owner) ^ uint160(account));\\n\\n        // The operatorBitField is a 256-position binary array, where each 1 signals by position the account that the\\n        // operator is authorized for.\\n        uint256 oldOperatorBitField = operatorLookup[addressPrefix][operator];\\n        uint256 newOperatorBitField = authorized ? oldOperatorBitField | bitMask : oldOperatorBitField & ~bitMask;\\n\\n        if (oldOperatorBitField == newOperatorBitField) {\\n            revert EVC_InvalidOperatorStatus();\\n        } else {\\n            operatorLookup[addressPrefix][operator] = newOperatorBitField;\\n\\n            emit OperatorStatus(addressPrefix, operator, newOperatorBitField);\\n        }\\n    }\\n\\n    // Collaterals management\\n\\n    /// @inheritdoc IEVC\\n    function getCollaterals(address account) external view returns (address[] memory) {\\n        return accountCollaterals[account].get();\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function isCollateralEnabled(address account, address vault) external view returns (bool) {\\n        return accountCollaterals[account].contains(vault);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function enableCollateral(\\n        address account,\\n        address vault\\n    ) public payable virtual nonReentrantChecksAndControlCollateral onlyOwnerOrOperator(account) {\\n        if (vault == address(this)) revert EVC_InvalidAddress();\\n\\n        if (accountCollaterals[account].insert(vault)) {\\n            emit CollateralStatus(account, vault, true);\\n        }\\n        requireAccountStatusCheck(account);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function disableCollateral(\\n        address account,\\n        address vault\\n    ) public payable virtual nonReentrantChecksAndControlCollateral onlyOwnerOrOperator(account) {\\n        if (accountCollaterals[account].remove(vault)) {\\n            emit CollateralStatus(account, vault, false);\\n        }\\n        requireAccountStatusCheck(account);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function reorderCollaterals(\\n        address account,\\n        uint8 index1,\\n        uint8 index2\\n    ) public payable virtual nonReentrantChecksAndControlCollateral onlyOwnerOrOperator(account) {\\n        accountCollaterals[account].reorder(index1, index2);\\n        requireAccountStatusCheck(account);\\n    }\\n\\n    // Controllers management\\n\\n    /// @inheritdoc IEVC\\n    function getControllers(address account) external view returns (address[] memory) {\\n        return accountControllers[account].get();\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function isControllerEnabled(address account, address vault) external view returns (bool) {\\n        return accountControllers[account].contains(vault);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function enableController(\\n        address account,\\n        address vault\\n    ) public payable virtual nonReentrantChecksAndControlCollateral onlyOwnerOrOperator(account) {\\n        if (vault == address(this)) revert EVC_InvalidAddress();\\n\\n        if (accountControllers[account].insert(vault)) {\\n            emit ControllerStatus(account, vault, true);\\n        }\\n        requireAccountStatusCheck(account);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function disableController(address account) public payable virtual nonReentrantChecksAndControlCollateral {\\n        if (accountControllers[account].remove(msg.sender)) {\\n            emit ControllerStatus(account, msg.sender, false);\\n        }\\n        requireAccountStatusCheck(account);\\n    }\\n\\n    // Permit\\n\\n    /// @inheritdoc IEVC\\n    function permit(\\n        address signer,\\n        address sender,\\n        uint256 nonceNamespace,\\n        uint256 nonce,\\n        uint256 deadline,\\n        uint256 value,\\n        bytes calldata data,\\n        bytes calldata signature\\n    ) public payable virtual nonReentrantChecksAndControlCollateral {\\n        // cannot be called within the self-call of the permit function; can occur for nested calls.\\n        // the permit function can be called only by the specified sender, unless address zero is specified in which\\n        // case anyone can call it\\n        if (inPermitSelfCall() || (sender != address(0) && sender != msg.sender)) {\\n            revert EVC_NotAuthorized();\\n        }\\n\\n        if (signer == address(0) || !isSignerValid(signer)) {\\n            revert EVC_InvalidAddress();\\n        }\\n\\n        bytes19 addressPrefix = getAddressPrefixInternal(signer);\\n\\n        if (ownerLookup[addressPrefix].isPermitDisabledMode) {\\n            revert EVC_PermitDisabledMode();\\n        }\\n\\n        {\\n            uint256 currentNonce = nonceLookup[addressPrefix][nonceNamespace];\\n\\n            if (currentNonce == type(uint256).max || currentNonce != nonce) {\\n                revert EVC_InvalidNonce();\\n            }\\n        }\\n\\n        if (deadline < block.timestamp) {\\n            revert EVC_InvalidTimestamp();\\n        }\\n\\n        if (data.length == 0) {\\n            revert EVC_InvalidData();\\n        }\\n\\n        bytes32 permitHash = getPermitHash(signer, sender, nonceNamespace, nonce, deadline, value, data);\\n\\n        if (\\n            signer != recoverECDSASigner(permitHash, signature)\\n                && !isValidERC1271Signature(signer, permitHash, signature)\\n        ) {\\n            revert EVC_NotAuthorized();\\n        }\\n\\n        unchecked {\\n            nonceLookup[addressPrefix][nonceNamespace] = nonce + 1;\\n        }\\n\\n        emit NonceUsed(addressPrefix, nonceNamespace, nonce);\\n\\n        // EVC address becomes the msg.sender for the duration this self-call, no authentication is required here.\\n        // the signer will be later on authenticated as per data, depending on the functions that will be called\\n        (bool success, bytes memory result) = callWithContextInternal(address(this), signer, value, data);\\n\\n        if (!success) revertBytes(result);\\n    }\\n\\n    // Calls forwarding\\n\\n    /// @inheritdoc IEVC\\n    function call(\\n        address targetContract,\\n        address onBehalfOfAccount,\\n        uint256 value,\\n        bytes calldata data\\n    ) public payable virtual nonReentrantChecksAndControlCollateral returns (bytes memory result) {\\n        EC contextCache = executionContext;\\n        executionContext = contextCache.setChecksDeferred();\\n\\n        bool success;\\n        (success, result) = callWithAuthenticationInternal(targetContract, onBehalfOfAccount, value, data);\\n\\n        if (!success) revertBytes(result);\\n\\n        restoreExecutionContext(contextCache);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function controlCollateral(\\n        address targetCollateral,\\n        address onBehalfOfAccount,\\n        uint256 value,\\n        bytes calldata data\\n    )\\n        public\\n        payable\\n        virtual\\n        nonReentrantChecksAndControlCollateral\\n        onlyController(onBehalfOfAccount)\\n        returns (bytes memory result)\\n    {\\n        if (!accountCollaterals[onBehalfOfAccount].contains(targetCollateral)) {\\n            revert EVC_NotAuthorized();\\n        }\\n\\n        EC contextCache = executionContext;\\n        executionContext = contextCache.setChecksDeferred().setControlCollateralInProgress();\\n\\n        bool success;\\n        (success, result) = callWithContextInternal(targetCollateral, onBehalfOfAccount, value, data);\\n\\n        if (!success) revertBytes(result);\\n\\n        restoreExecutionContext(contextCache);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function batch(BatchItem[] calldata items) public payable virtual nonReentrantChecksAndControlCollateral {\\n        EC contextCache = executionContext;\\n        executionContext = contextCache.setChecksDeferred();\\n\\n        uint256 length = items.length;\\n        for (uint256 i; i < length; ++i) {\\n            BatchItem calldata item = items[i];\\n            (bool success, bytes memory result) =\\n                callWithAuthenticationInternal(item.targetContract, item.onBehalfOfAccount, item.value, item.data);\\n\\n            if (!success) revertBytes(result);\\n        }\\n\\n        restoreExecutionContext(contextCache);\\n    }\\n\\n    // Simulations\\n\\n    /// @inheritdoc IEVC\\n    function batchRevert(BatchItem[] calldata items) public payable virtual nonReentrantChecksAndControlCollateral {\\n        BatchItemResult[] memory batchItemsResult;\\n        StatusCheckResult[] memory accountsStatusCheckResult;\\n        StatusCheckResult[] memory vaultsStatusCheckResult;\\n\\n        EC contextCache = executionContext;\\n\\n        if (contextCache.areChecksDeferred()) {\\n            revert EVC_SimulationBatchNested();\\n        }\\n\\n        executionContext = contextCache.setChecksDeferred().setSimulationInProgress();\\n\\n        uint256 length = items.length;\\n        batchItemsResult = new BatchItemResult[](length);\\n\\n        for (uint256 i; i < length; ++i) {\\n            BatchItem calldata item = items[i];\\n            (batchItemsResult[i].success, batchItemsResult[i].result) =\\n                callWithAuthenticationInternal(item.targetContract, item.onBehalfOfAccount, item.value, item.data);\\n        }\\n\\n        executionContext = contextCache.setChecksInProgress().setOnBehalfOfAccount(address(0));\\n\\n        accountsStatusCheckResult = checkStatusAllWithResult(SetType.Account);\\n        vaultsStatusCheckResult = checkStatusAllWithResult(SetType.Vault);\\n\\n        executionContext = contextCache;\\n\\n        revert EVC_RevertedBatchResult(batchItemsResult, accountsStatusCheckResult, vaultsStatusCheckResult);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function batchSimulation(BatchItem[] calldata items)\\n        external\\n        payable\\n        virtual\\n        returns (\\n            BatchItemResult[] memory batchItemsResult,\\n            StatusCheckResult[] memory accountsStatusCheckResult,\\n            StatusCheckResult[] memory vaultsStatusCheckResult\\n        )\\n    {\\n        (bool success, bytes memory result) = address(this).delegatecall(abi.encodeCall(this.batchRevert, items));\\n\\n        if (success) {\\n            revert EVC_BatchPanic();\\n        } else if (result.length < 4 || bytes4(result) != EVC_RevertedBatchResult.selector) {\\n            revertBytes(result);\\n        }\\n\\n        assembly {\\n            let length := mload(result)\\n            // skip 4-byte EVC_RevertedBatchResult selector\\n            result := add(result, 4)\\n            // write new array length = original length - 4-byte selector\\n            // cannot underflow as we require result.length >= 4 above\\n            mstore(result, sub(length, 4))\\n        }\\n\\n        (batchItemsResult, accountsStatusCheckResult, vaultsStatusCheckResult) =\\n            abi.decode(result, (BatchItemResult[], StatusCheckResult[], StatusCheckResult[]));\\n    }\\n\\n    // Account Status Check\\n\\n    /// @inheritdoc IEVC\\n    function getLastAccountStatusCheckTimestamp(address account) external view nonReentrantChecks returns (uint256) {\\n        return accountControllers[account].getMetadata();\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function isAccountStatusCheckDeferred(address account) external view nonReentrantChecks returns (bool) {\\n        return accountStatusChecks.contains(account);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function requireAccountStatusCheck(address account) public payable virtual {\\n        if (executionContext.areChecksDeferred()) {\\n            accountStatusChecks.insert(account);\\n        } else {\\n            requireAccountStatusCheckInternalNonReentrantChecks(account);\\n        }\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function forgiveAccountStatusCheck(address account)\\n        public\\n        payable\\n        virtual\\n        nonReentrantChecksAcquireLock\\n        onlyController(account)\\n    {\\n        accountStatusChecks.remove(account);\\n    }\\n\\n    // Vault Status Check\\n\\n    /// @inheritdoc IEVC\\n    function isVaultStatusCheckDeferred(address vault) external view nonReentrantChecks returns (bool) {\\n        return vaultStatusChecks.contains(vault);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function requireVaultStatusCheck() public payable virtual {\\n        if (executionContext.areChecksDeferred()) {\\n            vaultStatusChecks.insert(msg.sender);\\n        } else {\\n            requireVaultStatusCheckInternalNonReentrantChecks(msg.sender);\\n        }\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function forgiveVaultStatusCheck() public payable virtual nonReentrantChecksAcquireLock {\\n        vaultStatusChecks.remove(msg.sender);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function requireAccountAndVaultStatusCheck(address account) public payable virtual {\\n        if (executionContext.areChecksDeferred()) {\\n            accountStatusChecks.insert(account);\\n            vaultStatusChecks.insert(msg.sender);\\n        } else {\\n            requireAccountStatusCheckInternalNonReentrantChecks(account);\\n            requireVaultStatusCheckInternalNonReentrantChecks(msg.sender);\\n        }\\n    }\\n\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n    //                                  INTERNAL FUNCTIONS                                       //\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Authenticates the caller of a function.\\n    /// @dev This function checks if the caller is the owner or an authorized operator of the account, and if the\\n    /// account is not in lockdown mode.\\n    /// @param account The account address to authenticate the caller against.\\n    /// @param allowOperator A boolean indicating if operators are allowed to authenticate as the caller.\\n    /// @param checkLockdownMode A boolean indicating if the function should check for lockdown mode on the account.\\n    /// @return The address of the authenticated caller.\\n    function authenticateCaller(\\n        address account,\\n        bool allowOperator,\\n        bool checkLockdownMode\\n    ) internal virtual returns (address) {\\n        bytes19 addressPrefix = getAddressPrefixInternal(account);\\n        address owner = ownerLookup[addressPrefix].owner;\\n        bool lockdownMode = ownerLookup[addressPrefix].isLockdownMode;\\n        address msgSender = _msgSender();\\n        bool authenticated = false;\\n\\n        // check if the caller is the owner of the account\\n        if (haveCommonOwnerInternal(account, msgSender)) {\\n            // if the owner is not registered, register it\\n            if (owner == address(0)) {\\n                ownerLookup[addressPrefix].owner = owner = msgSender;\\n                emit OwnerRegistered(addressPrefix, msgSender);\\n                authenticated = true;\\n            } else if (owner == msgSender) {\\n                authenticated = true;\\n            }\\n        }\\n\\n        // if the caller is not the owner, check if it is an operator if operators are allowed\\n        if (!authenticated && allowOperator && isAccountOperatorAuthorizedInternal(account, msgSender)) {\\n            authenticated = true;\\n        }\\n\\n        // if the authenticated account is non-owner, prevent its account from being a smart contract\\n        if (authenticated && owner != account && account.code.length != 0) {\\n            authenticated = false;\\n        }\\n\\n        // must revert if neither the owner nor the operator were authenticated\\n        if (!authenticated) {\\n            revert EVC_NotAuthorized();\\n        }\\n\\n        // revert if the account is in lockdown mode unless the lockdown mode is not being checked\\n        if (checkLockdownMode && lockdownMode) {\\n            revert EVC_LockdownMode();\\n        }\\n\\n        return msgSender;\\n    }\\n\\n    /// @notice Authenticates the caller of a function.\\n    /// @dev This function either passes the address prefix owner address, if the address prefix owner is already\\n    /// registered, or converts the bytes19 address prefix into an account address which will belong to the owner when\\n    /// it's finally registered.\\n    /// @param addressPrefix The bytes19 address prefix to authenticate the caller against.\\n    /// @param allowOperator A boolean indicating if operators are allowed to authenticate as the caller.\\n    /// @param checkLockdownMode A boolean indicating if the function should check for lockdown mode on the account.\\n    /// @return The address of the authenticated caller.\\n    function authenticateCaller(\\n        bytes19 addressPrefix,\\n        bool allowOperator,\\n        bool checkLockdownMode\\n    ) internal virtual returns (address) {\\n        address owner = ownerLookup[addressPrefix].owner;\\n\\n        return authenticateCaller({\\n            account: owner == address(0) ? address(uint160(uint152(addressPrefix)) << ACCOUNT_ID_OFFSET) : owner,\\n            allowOperator: allowOperator,\\n            checkLockdownMode: checkLockdownMode\\n        });\\n    }\\n\\n    /// @notice Internal function to make a call to a target contract with a specific context.\\n    /// @dev This function sets the execution context for the duration of the call.\\n    /// @param targetContract The contract address to call.\\n    /// @param onBehalfOfAccount The account address on behalf of which the call is made.\\n    /// @param value The amount of value to send with the call.\\n    /// @param data The calldata to send with the call.\\n    function callWithContextInternal(\\n        address targetContract,\\n        address onBehalfOfAccount,\\n        uint256 value,\\n        bytes calldata data\\n    ) internal virtual returns (bool success, bytes memory result) {\\n        if (value == type(uint256).max) {\\n            value = address(this).balance;\\n        } else if (value > address(this).balance) {\\n            revert EVC_InvalidValue();\\n        }\\n\\n        EC contextCache = executionContext;\\n        address msgSender = _msgSender();\\n\\n        // set the onBehalfOfAccount in the execution context for the duration of the external call.\\n        // considering that the operatorAuthenticated is only meant to be observable by external\\n        // contracts, it is sufficient to set it here rather than in the authentication function.\\n        // apart from the usual scenario (when an owner operates on behalf of its account),\\n        // the operatorAuthenticated should be cleared when about to execute the permit self-call, when\\n        // target contract is equal to the msg.sender in call() and batch(), or when the controlCollateral is in\\n        // progress (in which case the operatorAuthenticated is not relevant)\\n        if (\\n            haveCommonOwnerInternal(onBehalfOfAccount, msgSender) || targetContract == msg.sender\\n                || targetContract == address(this) || contextCache.isControlCollateralInProgress()\\n        ) {\\n            executionContext = contextCache.setOnBehalfOfAccount(onBehalfOfAccount).clearOperatorAuthenticated();\\n        } else {\\n            executionContext = contextCache.setOnBehalfOfAccount(onBehalfOfAccount).setOperatorAuthenticated();\\n        }\\n\\n        emit CallWithContext(\\n            msgSender, getAddressPrefixInternal(onBehalfOfAccount), onBehalfOfAccount, targetContract, bytes4(data)\\n        );\\n\\n        (success, result) = targetContract.call{value: value}(data);\\n\\n        executionContext = contextCache;\\n    }\\n\\n    /// @notice Internal function to call a target contract with necessary authentication.\\n    /// @dev This function decides whether to use delegatecall or a regular call based on the target contract.\\n    /// If the target contract is this contract, it uses delegatecall to preserve msg.sender for authentication.\\n    /// Otherwise, it authenticates the caller if needed and proceeds with a regular call.\\n    /// @param targetContract The contract address to call.\\n    /// @param onBehalfOfAccount The account address on behalf of which the call is made.\\n    /// @param value The amount of value to send with the call.\\n    /// @param data The calldata to send with the call.\\n    /// @return success A boolean indicating if the call was successful.\\n    /// @return result The bytes returned from the call.\\n    function callWithAuthenticationInternal(\\n        address targetContract,\\n        address onBehalfOfAccount,\\n        uint256 value,\\n        bytes calldata data\\n    ) internal virtual returns (bool success, bytes memory result) {\\n        if (targetContract == address(this)) {\\n            if (onBehalfOfAccount != address(0)) {\\n                revert EVC_InvalidAddress();\\n            }\\n\\n            if (value != 0) {\\n                revert EVC_InvalidValue();\\n            }\\n\\n            // delegatecall is used here to preserve msg.sender in order to be able to perform authentication\\n            (success, result) = address(this).delegatecall(data);\\n        } else {\\n            // when the target contract is equal to the msg.sender, both in call() and batch(), authentication is not\\n            // required\\n            if (targetContract != msg.sender) {\\n                authenticateCaller({account: onBehalfOfAccount, allowOperator: true, checkLockdownMode: true});\\n            }\\n\\n            (success, result) = callWithContextInternal(targetContract, onBehalfOfAccount, value, data);\\n        }\\n    }\\n\\n    /// @notice Restores the execution context from a cached state.\\n    /// @dev This function restores the execution context to a previously cached state, performing necessary status\\n    /// checks if they are no longer deferred. If checks are no longer deferred, it sets the execution context to\\n    /// indicate checks are in progress and clears the 'on behalf of' account. It then performs status checks for both\\n    /// accounts and vaults before restoring the execution context to the cached state.\\n    /// @param contextCache The cached execution context to restore from.\\n    function restoreExecutionContext(EC contextCache) internal virtual {\\n        if (!contextCache.areChecksDeferred()) {\\n            executionContext = contextCache.setChecksInProgress().setOnBehalfOfAccount(address(0));\\n\\n            checkStatusAll(SetType.Account);\\n            checkStatusAll(SetType.Vault);\\n        }\\n\\n        executionContext = contextCache;\\n    }\\n\\n    /// @notice Checks the status of an account internally.\\n    /// @dev This function first checks the number of controllers for the account. If there are no controllers enabled,\\n    /// it returns true immediately, indicating the account status is valid without further checks. If there is more\\n    /// than one controller, it reverts with an EVC_ControllerViolation error. For a single controller, it proceeds to\\n    /// call the controller to check the account status.\\n    /// @param account The account address to check the status for.\\n    /// @return isValid A boolean indicating if the account status is valid.\\n    /// @return result The bytes returned from the controller call, indicating the account status.\\n    function checkAccountStatusInternal(address account) internal virtual returns (bool isValid, bytes memory result) {\\n        SetStorage storage accountControllersStorage = accountControllers[account];\\n        uint256 numOfControllers = accountControllersStorage.numElements;\\n        address controller = accountControllersStorage.firstElement;\\n        uint8 stamp = accountControllersStorage.stamp;\\n\\n        if (numOfControllers == 0) return (true, \\\"\\\");\\n        else if (numOfControllers > 1) return (false, abi.encodeWithSelector(EVC_ControllerViolation.selector));\\n\\n        bool success;\\n        (success, result) = controller.staticcall(\\n            abi.encodeCall(IVault.checkAccountStatus, (account, accountCollaterals[account].get()))\\n        );\\n\\n        isValid = success && result.length == 32\\n            && abi.decode(result, (bytes32)) == bytes32(IVault.checkAccountStatus.selector);\\n\\n        if (isValid) {\\n            accountControllersStorage.numElements = uint8(numOfControllers);\\n            accountControllersStorage.firstElement = controller;\\n            accountControllersStorage.metadata = uint80(block.timestamp);\\n            accountControllersStorage.stamp = stamp;\\n        }\\n\\n        emit AccountStatusCheck(account, controller);\\n    }\\n\\n    function requireAccountStatusCheckInternal(address account) internal virtual {\\n        (bool isValid, bytes memory result) = checkAccountStatusInternal(account);\\n\\n        if (!isValid) {\\n            revertBytes(result);\\n        }\\n    }\\n\\n    function requireAccountStatusCheckInternalNonReentrantChecks(address account)\\n        internal\\n        virtual\\n        nonReentrantChecksAcquireLock\\n    {\\n        requireAccountStatusCheckInternal(account);\\n    }\\n\\n    /// @notice Checks the status of a vault internally.\\n    /// @dev This function makes an external call to the vault to check its status.\\n    /// @param vault The address of the vault to check the status for.\\n    /// @return isValid A boolean indicating if the vault status is valid.\\n    /// @return result The bytes returned from the vault call, indicating the vault status.\\n    function checkVaultStatusInternal(address vault) internal virtual returns (bool isValid, bytes memory result) {\\n        bool success;\\n        (success, result) = vault.call(abi.encodeCall(IVault.checkVaultStatus, ()));\\n\\n        isValid =\\n            success && result.length == 32 && abi.decode(result, (bytes32)) == bytes32(IVault.checkVaultStatus.selector);\\n\\n        emit VaultStatusCheck(vault);\\n    }\\n\\n    function requireVaultStatusCheckInternal(address vault) internal virtual {\\n        (bool isValid, bytes memory result) = checkVaultStatusInternal(vault);\\n\\n        if (!isValid) {\\n            revertBytes(result);\\n        }\\n    }\\n\\n    function requireVaultStatusCheckInternalNonReentrantChecks(address vault)\\n        internal\\n        virtual\\n        nonReentrantChecksAcquireLock\\n    {\\n        requireVaultStatusCheckInternal(vault);\\n    }\\n\\n    /// @notice Checks the status of all entities in a set, either accounts or vaults, and clears the checks.\\n    /// @dev Iterates over either accountStatusChecks or vaultStatusChecks based on the setType and performs status\\n    /// checks.\\n    /// Clears the checks while performing them.\\n    /// @param setType The type of set to perform the status checks on, either accounts or vaults.\\n    function checkStatusAll(SetType setType) internal virtual {\\n        setType == SetType.Account\\n            ? accountStatusChecks.forEachAndClear(requireAccountStatusCheckInternal)\\n            : vaultStatusChecks.forEachAndClear(requireVaultStatusCheckInternal);\\n    }\\n\\n    function checkStatusAllWithResult(SetType setType)\\n        internal\\n        virtual\\n        returns (StatusCheckResult[] memory checksResult)\\n    {\\n        bytes[] memory callbackResult = setType == SetType.Account\\n            ? accountStatusChecks.forEachAndClearWithResult(checkAccountStatusInternal)\\n            : vaultStatusChecks.forEachAndClearWithResult(checkVaultStatusInternal);\\n\\n        uint256 length = callbackResult.length;\\n        checksResult = new StatusCheckResult[](length);\\n\\n        for (uint256 i; i < length; ++i) {\\n            (address checkedAddress, bool isValid, bytes memory result) =\\n                abi.decode(callbackResult[i], (address, bool, bytes));\\n            checksResult[i] = StatusCheckResult({checkedAddress: checkedAddress, isValid: isValid, result: result});\\n        }\\n    }\\n\\n    // Permit-related functions\\n\\n    /// @notice Determines if the signer address is valid.\\n    /// @dev It's important to revisit this logic when deploying on chains other than the Ethereum mainnet. If new\\n    /// precompiles had been added to the Ethereum mainnet, the current implementation of the function would not be\\n    /// future-proof and would need to be updated.\\n    /// @param signer The address of the signer to validate.\\n    /// @return bool Returns true if the signer is valid, false otherwise.\\n    function isSignerValid(address signer) internal pure virtual returns (bool) {\\n        // not valid if the signer address falls into any of the precompiles/predeploys\\n        // addresses space (depends on the chain ID).\\n        return !haveCommonOwnerInternal(signer, address(0));\\n    }\\n\\n    /// @notice Computes the permit hash for a given set of parameters.\\n    /// @dev This function generates a permit hash using EIP712 typed data signing.\\n    /// @param signer The address of the signer.\\n    /// @param nonceNamespace The namespace of the nonce.\\n    /// @param nonce The nonce value, ensuring permits are used once.\\n    /// @param deadline The time until when the permit is valid.\\n    /// @param value The value associated with the permit.\\n    /// @param data Calldata associated with the permit.\\n    /// @return permitHash The computed permit hash.\\n    function getPermitHash(\\n        address signer,\\n        address sender,\\n        uint256 nonceNamespace,\\n        uint256 nonce,\\n        uint256 deadline,\\n        uint256 value,\\n        bytes calldata data\\n    ) internal view returns (bytes32 permitHash) {\\n        bytes32 domainSeparator =\\n            block.chainid == CACHED_CHAIN_ID ? CACHED_DOMAIN_SEPARATOR : calculateDomainSeparator();\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(PERMIT_TYPEHASH, signer, sender, nonceNamespace, nonce, deadline, value, keccak256(data))\\n        );\\n\\n        // This code overwrites the two most significant bytes of the free memory pointer,\\n        // and restores them to 0 after\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, \\\"\\\\x19\\\\x01\\\")\\n            mstore(0x02, domainSeparator)\\n            mstore(0x22, structHash)\\n            permitHash := keccak256(0x00, 0x42)\\n            mstore(0x22, 0)\\n        }\\n    }\\n\\n    /// @notice Recovers the signer address from a hash and a signature.\\n    /// Based on:\\n    /// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol\\n    /// Note that the function returns zero address if the signature is invalid hence the result always has to be\\n    /// checked against address zero.\\n    /// @param hash The hash of the signed data.\\n    /// @param signature The signature to recover the signer from.\\n    /// @return signer The address of the signer, or the zero address if signature recovery fails.\\n    function recoverECDSASigner(bytes32 hash, bytes memory signature) internal pure returns (address signer) {\\n        if (signature.length != 65) return address(0);\\n\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // ecrecover takes the signature parameters, and the only way to get them\\n        // currently is to use assembly.\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return address(0);\\n        }\\n\\n        // return the signer address (note that it might be zero address)\\n        signer = ecrecover(hash, v, r, s);\\n    }\\n\\n    /// @notice Checks if a given signature is valid according to ERC-1271 standard.\\n    /// @dev This function is based on the implementation found in OpenZeppelin's SignatureChecker.\\n    /// See:\\n    /// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/SignatureChecker.sol\\n    /// It performs a static call to the signer's address with the signature data and checks if the returned value\\n    /// matches the expected valid signature selector.\\n    /// @param signer The address of the signer to validate the signature against.\\n    /// @param hash The hash of the data that was signed.\\n    /// @param signature The signature to validate.\\n    /// @return isValid True if the signature is valid according to ERC-1271, false otherwise.\\n    function isValidERC1271Signature(\\n        address signer,\\n        bytes32 hash,\\n        bytes memory signature\\n    ) internal view returns (bool isValid) {\\n        if (signer.code.length == 0) return false;\\n\\n        (bool success, bytes memory result) =\\n            signer.staticcall(abi.encodeCall(IERC1271.isValidSignature, (hash, signature)));\\n\\n        isValid = success && result.length == 32\\n            && abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector);\\n    }\\n\\n    /// @notice Calculates the EIP-712 domain separator for the contract.\\n    /// @return The calculated EIP-712 domain separator as a bytes32 value.\\n    function calculateDomainSeparator() internal view returns (bytes32) {\\n        return keccak256(abi.encode(TYPE_HASH, HASHED_NAME, block.chainid, address(this)));\\n    }\\n\\n    // Auxiliary functions\\n\\n    /// @notice Returns the message sender's address.\\n    /// @dev In the context of a permit self-call, it returns the account on behalf of which the call is made.\\n    /// Otherwise, it returns `msg.sender`.\\n    /// @return The address of the message sender or the account on behalf of which the call is made.\\n    function _msgSender() internal view virtual returns (address) {\\n        return inPermitSelfCall() ? executionContext.getOnBehalfOfAccount() : msg.sender;\\n    }\\n\\n    /// @notice Checks if the contract is in the context of a permit self-call.\\n    /// @dev EVC can only be `msg.sender` during the self-call in the permit function.\\n    /// @return True if the current call is a self-call within the permit function, false otherwise.\\n    function inPermitSelfCall() internal view returns (bool) {\\n        return address(this) == msg.sender;\\n    }\\n\\n    /// @notice Determines if two accounts have a common owner by comparing their address prefixes.\\n    /// @param account The first account address to compare.\\n    /// @param otherAccount The second account address to compare.\\n    /// @return result True if the accounts have a common owner, false otherwise.\\n    function haveCommonOwnerInternal(address account, address otherAccount) internal pure returns (bool result) {\\n        assembly {\\n            result := lt(xor(account, otherAccount), 0x100)\\n        }\\n    }\\n\\n    /// @notice Computes the address prefix for a given account address.\\n    /// @dev The address prefix is derived by right-shifting the account address by 8 bits which effectively reduces the\\n    /// address size to 19 bytes.\\n    /// @param account The account address to compute the prefix for.\\n    /// @return The computed address prefix as a bytes19 value.\\n    function getAddressPrefixInternal(address account) internal pure returns (bytes19) {\\n        return bytes19(uint152(uint160(account) >> ACCOUNT_ID_OFFSET));\\n    }\\n\\n    /// @notice Checks if an operator is authorized for a specific account.\\n    /// @dev Determines operator authorization by checking if the operator's bit is set in the operator's bit field for\\n    /// the account's address prefix. If the owner is not registered (address(0)), it implies the operator cannot be\\n    /// authorized, hence returns false. The bitMask is calculated by shifting 1 left by the XOR of the owner's and\\n    /// account's address, effectively checking the operator's authorization for the specific account.\\n    /// @param account The account address to check the operator authorization for.\\n    /// @param operator The operator address to check authorization status.\\n    /// @return isAuthorized True if the operator is authorized for the account, false otherwise.\\n    function isAccountOperatorAuthorizedInternal(\\n        address account,\\n        address operator\\n    ) internal view returns (bool isAuthorized) {\\n        bytes19 addressPrefix = getAddressPrefixInternal(account);\\n        address owner = ownerLookup[addressPrefix].owner;\\n\\n        // if the owner is not registered yet, it means that the operator couldn't have been authorized\\n        if (owner == address(0)) return false;\\n\\n        // The bitMask defines which accounts the operator is authorized for. The bitMask is created from the account\\n        // number which is a number up to 2^8 in binary, or 256. 1 << (uint160(owner) ^ uint160(account)) transforms\\n        // that number in an 256-position binary array like 0...010...0, marking the account positionally in a uint256.\\n        uint256 bitMask = 1 << (uint160(owner) ^ uint160(account));\\n\\n        return operatorLookup[addressPrefix][operator] & bitMask != 0;\\n    }\\n\\n    /// @notice Reverts the transaction with a custom error message if provided, otherwise reverts with a generic empty\\n    /// error.\\n    /// @param errMsg The custom error message to revert the transaction with.\\n    function revertBytes(bytes memory errMsg) internal pure {\\n        if (errMsg.length != 0) {\\n            assembly {\\n                revert(add(32, errMsg), mload(errMsg))\\n            }\\n        }\\n        revert EVC_EmptyError();\\n    }\\n}\\n\"},\"lib/euler-vault-kit/lib/ethereum-vault-connector/src/Events.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\n/// @title Events\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice This contract implements the events for the Ethereum Vault Connector.\\ncontract Events {\\n    /// @notice Emitted when an owner is registered for an address prefix.\\n    /// @param addressPrefix The address prefix for which the owner is registered.\\n    /// @param owner The address of the owner registered.\\n    event OwnerRegistered(bytes19 indexed addressPrefix, address indexed owner);\\n\\n    /// @notice Emitted when the lockdown mode status is changed for an address prefix.\\n    /// @param addressPrefix The address prefix for which the lockdown mode status is changed.\\n    /// @param enabled True if the lockdown mode is enabled, false otherwise.\\n    event LockdownModeStatus(bytes19 indexed addressPrefix, bool enabled);\\n\\n    /// @notice Emitted when the permit disabled mode status is changed for an address prefix.\\n    /// @param addressPrefix The address prefix for which the permit disabled mode status is changed.\\n    /// @param enabled True if the permit disabled mode is enabled, false otherwise.\\n    event PermitDisabledModeStatus(bytes19 indexed addressPrefix, bool enabled);\\n\\n    /// @notice Emitted when the nonce status is updated for a given address prefix and nonce namespace.\\n    /// @param addressPrefix The prefix of the address for which the nonce status is updated.\\n    /// @param nonceNamespace The namespace of the nonce being updated.\\n    /// @param oldNonce The previous nonce value before the update.\\n    /// @param newNonce The new nonce value after the update.\\n    event NonceStatus(\\n        bytes19 indexed addressPrefix, uint256 indexed nonceNamespace, uint256 oldNonce, uint256 newNonce\\n    );\\n\\n    /// @notice Emitted when a nonce is used for an address prefix and nonce namespace as part of permit execution.\\n    /// @param addressPrefix The address prefix for which the nonce is used.\\n    /// @param nonceNamespace The namespace of the nonce used.\\n    /// @param nonce The nonce that was used.\\n    event NonceUsed(bytes19 indexed addressPrefix, uint256 indexed nonceNamespace, uint256 nonce);\\n\\n    /// @notice Emitted when the operator status is changed for an address prefix.\\n    /// @param addressPrefix The address prefix for which the operator status is changed.\\n    /// @param operator The address of the operator.\\n    /// @param accountOperatorAuthorized The new authorization bitfield of the operator.\\n    event OperatorStatus(bytes19 indexed addressPrefix, address indexed operator, uint256 accountOperatorAuthorized);\\n\\n    /// @notice Emitted when the collateral status is changed for an account.\\n    /// @param account The account for which the collateral status is changed.\\n    /// @param collateral The address of the collateral.\\n    /// @param enabled True if the collateral is enabled, false otherwise.\\n    event CollateralStatus(address indexed account, address indexed collateral, bool enabled);\\n\\n    /// @notice Emitted when the controller status is changed for an account.\\n    /// @param account The account for which the controller status is changed.\\n    /// @param controller The address of the controller.\\n    /// @param enabled True if the controller is enabled, false otherwise.\\n    event ControllerStatus(address indexed account, address indexed controller, bool enabled);\\n\\n    /// @notice Emitted when an external call is made through the EVC.\\n    /// @param caller The address of the caller.\\n    /// @param onBehalfOfAddressPrefix The address prefix of the account on behalf of which the call is made.\\n    /// @param onBehalfOfAccount The account on behalf of which the call is made.\\n    /// @param targetContract The target contract of the call.\\n    /// @param selector The selector of the function called on the target contract.\\n    event CallWithContext(\\n        address indexed caller,\\n        bytes19 indexed onBehalfOfAddressPrefix,\\n        address onBehalfOfAccount,\\n        address indexed targetContract,\\n        bytes4 selector\\n    );\\n\\n    /// @notice Emitted when an account status check is performed.\\n    /// @param account The account for which the status check is performed.\\n    /// @param controller The controller performing the status check.\\n    event AccountStatusCheck(address indexed account, address indexed controller);\\n\\n    /// @notice Emitted when a vault status check is performed.\\n    /// @param vault The vault for which the status check is performed.\\n    event VaultStatusCheck(address indexed vault);\\n}\\n\"},\"lib/euler-vault-kit/lib/ethereum-vault-connector/src/ExecutionContext.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\ntype EC is uint256;\\n\\n/// @title ExecutionContext\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice This library provides functions for managing the execution context in the Ethereum Vault Connector.\\n/// @dev The execution context is a bit field that stores the following information:\\n/// @dev - on behalf of account - an account on behalf of which the currently executed operation is being performed\\n/// @dev - checks deferred flag - used to indicate whether checks are deferred\\n/// @dev - checks in progress flag - used to indicate that the account/vault status checks are in progress. This flag is\\n/// used to prevent re-entrancy.\\n/// @dev - control collateral in progress flag - used to indicate that the control collateral is in progress. This flag\\n/// is used to prevent re-entrancy.\\n/// @dev - operator authenticated flag - used to indicate that the currently executed operation is being performed by\\n/// the account operator\\n/// @dev - simulation flag - used to indicate that the currently executed batch call is a simulation\\n/// @dev - stamp - dummy value for optimization purposes\\nlibrary ExecutionContext {\\n    uint256 internal constant ON_BEHALF_OF_ACCOUNT_MASK =\\n        0x000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n    uint256 internal constant CHECKS_DEFERRED_MASK = 0x0000000000000000000000FF0000000000000000000000000000000000000000;\\n    uint256 internal constant CHECKS_IN_PROGRESS_MASK =\\n        0x00000000000000000000FF000000000000000000000000000000000000000000;\\n    uint256 internal constant CONTROL_COLLATERAL_IN_PROGRESS_LOCK_MASK =\\n        0x000000000000000000FF00000000000000000000000000000000000000000000;\\n    uint256 internal constant OPERATOR_AUTHENTICATED_MASK =\\n        0x0000000000000000FF0000000000000000000000000000000000000000000000;\\n    uint256 internal constant SIMULATION_MASK = 0x00000000000000FF000000000000000000000000000000000000000000000000;\\n    uint256 internal constant STAMP_OFFSET = 200;\\n\\n    // None of the functions below modifies the state. All the functions operate on the copy\\n    // of the execution context and return its modified value as a result. In order to update\\n    // one should use the result of the function call as a new execution context value.\\n\\n    function getOnBehalfOfAccount(EC self) internal pure returns (address result) {\\n        result = address(uint160(EC.unwrap(self) & ON_BEHALF_OF_ACCOUNT_MASK));\\n    }\\n\\n    function setOnBehalfOfAccount(EC self, address account) internal pure returns (EC result) {\\n        result = EC.wrap((EC.unwrap(self) & ~ON_BEHALF_OF_ACCOUNT_MASK) | uint160(account));\\n    }\\n\\n    function areChecksDeferred(EC self) internal pure returns (bool result) {\\n        result = EC.unwrap(self) & CHECKS_DEFERRED_MASK != 0;\\n    }\\n\\n    function setChecksDeferred(EC self) internal pure returns (EC result) {\\n        result = EC.wrap(EC.unwrap(self) | CHECKS_DEFERRED_MASK);\\n    }\\n\\n    function areChecksInProgress(EC self) internal pure returns (bool result) {\\n        result = EC.unwrap(self) & CHECKS_IN_PROGRESS_MASK != 0;\\n    }\\n\\n    function setChecksInProgress(EC self) internal pure returns (EC result) {\\n        result = EC.wrap(EC.unwrap(self) | CHECKS_IN_PROGRESS_MASK);\\n    }\\n\\n    function isControlCollateralInProgress(EC self) internal pure returns (bool result) {\\n        result = EC.unwrap(self) & CONTROL_COLLATERAL_IN_PROGRESS_LOCK_MASK != 0;\\n    }\\n\\n    function setControlCollateralInProgress(EC self) internal pure returns (EC result) {\\n        result = EC.wrap(EC.unwrap(self) | CONTROL_COLLATERAL_IN_PROGRESS_LOCK_MASK);\\n    }\\n\\n    function isOperatorAuthenticated(EC self) internal pure returns (bool result) {\\n        result = EC.unwrap(self) & OPERATOR_AUTHENTICATED_MASK != 0;\\n    }\\n\\n    function setOperatorAuthenticated(EC self) internal pure returns (EC result) {\\n        result = EC.wrap(EC.unwrap(self) | OPERATOR_AUTHENTICATED_MASK);\\n    }\\n\\n    function clearOperatorAuthenticated(EC self) internal pure returns (EC result) {\\n        result = EC.wrap(EC.unwrap(self) & ~OPERATOR_AUTHENTICATED_MASK);\\n    }\\n\\n    function isSimulationInProgress(EC self) internal pure returns (bool result) {\\n        result = EC.unwrap(self) & SIMULATION_MASK != 0;\\n    }\\n\\n    function setSimulationInProgress(EC self) internal pure returns (EC result) {\\n        result = EC.wrap(EC.unwrap(self) | SIMULATION_MASK);\\n    }\\n}\\n\"},\"lib/euler-vault-kit/lib/ethereum-vault-connector/src/Set.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\n/// @dev Represents the maximum number of elements that can be stored in the set.\\n/// Must not exceed 255 due to the uint8 data type limit.\\nuint8 constant SET_MAX_ELEMENTS = 10;\\n\\n/// @title ElementStorage\\n/// @notice This struct is used to store the value and stamp of an element.\\n/// @dev The stamp field is used to keep the storage slot non-zero when the element is removed.\\n/// @dev It allows for cheaper SSTORE when an element is inserted.\\nstruct ElementStorage {\\n    /// @notice The value of the element.\\n    address value;\\n    /// @notice The stamp of the element.\\n    uint96 stamp;\\n}\\n\\n/// @title SetStorage\\n/// @notice This struct is used to store the set data.\\n/// @dev To optimize the gas consumption, firstElement is stored in the same storage slot as the numElements\\n/// @dev so that for sets with one element, only one storage slot has to be read/written. To keep the elements\\n/// @dev array indexing consistent and because the first element is stored outside of the array, the elements[0]\\n/// @dev is not utilized. The stamp field is used to keep the storage slot non-zero when the element is removed.\\n/// @dev It allows for cheaper SSTORE when an element is inserted.\\nstruct SetStorage {\\n    /// @notice The number of elements in the set.\\n    uint8 numElements;\\n    /// @notice The first element in the set.\\n    address firstElement;\\n    /// @notice The metadata of the set.\\n    uint80 metadata;\\n    /// @notice The stamp of the set.\\n    uint8 stamp;\\n    /// @notice The array of elements in the set. Stores the elements starting from index 1.\\n    ElementStorage[SET_MAX_ELEMENTS] elements;\\n}\\n\\n/// @title Set\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice This library provides functions for managing sets of addresses.\\n/// @dev The maximum number of elements in the set is defined by the constant SET_MAX_ELEMENTS.\\nlibrary Set {\\n    error TooManyElements();\\n    error InvalidIndex();\\n\\n    uint8 internal constant EMPTY_ELEMENT_OFFSET = 1; // must be 1\\n    uint8 internal constant DUMMY_STAMP = 1;\\n\\n    /// @notice Initializes the set by setting the stamp field of the SetStorage and the stamp field of elements to\\n    /// DUMMY_STAMP.\\n    /// @dev The stamp field is used to keep the storage slot non-zero when the element is removed. It allows for\\n    /// cheaper SSTORE when an element is inserted.\\n    /// @param setStorage The set storage whose stamp fields will be initialized.\\n    function initialize(SetStorage storage setStorage) internal {\\n        setStorage.stamp = DUMMY_STAMP;\\n\\n        for (uint256 i = EMPTY_ELEMENT_OFFSET; i < SET_MAX_ELEMENTS; ++i) {\\n            setStorage.elements[i].stamp = DUMMY_STAMP;\\n        }\\n    }\\n\\n    /// @notice Inserts an element and returns information whether the element was inserted or not.\\n    /// @dev Reverts if the set is full but the element is not in the set storage.\\n    /// @param setStorage The set storage to which the element will be inserted.\\n    /// @param element The element to be inserted.\\n    /// @return A boolean value that indicates whether the element was inserted or not. If the element was already in\\n    /// the set storage, it returns false.\\n    function insert(SetStorage storage setStorage, address element) internal returns (bool) {\\n        address firstElement = setStorage.firstElement;\\n        uint256 numElements = setStorage.numElements;\\n        uint80 metadata = setStorage.metadata;\\n\\n        if (numElements == 0) {\\n            // gas optimization:\\n            // on the first element insertion, set the stamp to non-zero value to keep the storage slot non-zero when\\n            // the element is removed. when a new element is inserted after the removal, it should be cheaper\\n            setStorage.numElements = 1;\\n            setStorage.firstElement = element;\\n            setStorage.metadata = metadata;\\n            setStorage.stamp = DUMMY_STAMP;\\n            return true;\\n        }\\n\\n        if (firstElement == element) return false;\\n\\n        for (uint256 i = EMPTY_ELEMENT_OFFSET; i < numElements; ++i) {\\n            if (setStorage.elements[i].value == element) return false;\\n        }\\n\\n        if (numElements == SET_MAX_ELEMENTS) revert TooManyElements();\\n\\n        setStorage.elements[numElements].value = element;\\n\\n        unchecked {\\n            setStorage.numElements = uint8(numElements + 1);\\n        }\\n\\n        return true;\\n    }\\n\\n    /// @notice Removes an element and returns information whether the element was removed or not.\\n    /// @dev This operation may affect the order of elements in the array of elements obtained using get() function. This\\n    /// function does not modify the metadata of the set, even if it becomes empty as a result of invoking this\\n    /// function.\\n    /// @param setStorage The set storage from which the element will be removed.\\n    /// @param element The element to be removed.\\n    /// @return A boolean value that indicates whether the element was removed or not. If the element was not in the set\\n    /// storage, it returns false.\\n    function remove(SetStorage storage setStorage, address element) internal returns (bool) {\\n        address firstElement = setStorage.firstElement;\\n        uint256 numElements = setStorage.numElements;\\n        uint80 metadata = setStorage.metadata;\\n\\n        if (numElements == 0) return false;\\n\\n        uint256 searchIndex;\\n        if (firstElement != element) {\\n            for (searchIndex = EMPTY_ELEMENT_OFFSET; searchIndex < numElements; ++searchIndex) {\\n                if (setStorage.elements[searchIndex].value == element) break;\\n            }\\n\\n            if (searchIndex == numElements) return false;\\n        }\\n\\n        // write full slot at once to avoid SLOAD and bit masking\\n        if (numElements == 1) {\\n            setStorage.numElements = 0;\\n            setStorage.firstElement = address(0);\\n            setStorage.metadata = metadata;\\n            setStorage.stamp = DUMMY_STAMP;\\n            return true;\\n        }\\n\\n        uint256 lastIndex;\\n        unchecked {\\n            lastIndex = numElements - 1;\\n        }\\n\\n        // set numElements for every execution path to avoid SSTORE and bit masking when the element removed is\\n        // firstElement\\n        ElementStorage storage lastElement = setStorage.elements[lastIndex];\\n        if (searchIndex != lastIndex) {\\n            if (searchIndex == 0) {\\n                setStorage.firstElement = lastElement.value;\\n                setStorage.numElements = uint8(lastIndex);\\n                setStorage.metadata = metadata;\\n                setStorage.stamp = DUMMY_STAMP;\\n            } else {\\n                setStorage.elements[searchIndex].value = lastElement.value;\\n\\n                setStorage.firstElement = firstElement;\\n                setStorage.numElements = uint8(lastIndex);\\n                setStorage.metadata = metadata;\\n                setStorage.stamp = DUMMY_STAMP;\\n            }\\n        } else {\\n            setStorage.firstElement = firstElement;\\n            setStorage.numElements = uint8(lastIndex);\\n            setStorage.metadata = metadata;\\n            setStorage.stamp = DUMMY_STAMP;\\n        }\\n\\n        lastElement.value = address(0);\\n\\n        return true;\\n    }\\n\\n    /// @notice Swaps the position of two elements so that they appear switched in the array of elements obtained using\\n    /// get() function.\\n    /// @dev The first index must not be greater than or equal to the second index. Indices must not be out of bounds.\\n    /// The function will revert if the indices are invalid.\\n    /// @param setStorage The set storage for which the elements will be swapped.\\n    /// @param index1 The index of the first element to be swapped.\\n    /// @param index2 The index of the second element to be swapped.\\n    function reorder(SetStorage storage setStorage, uint8 index1, uint8 index2) internal {\\n        address firstElement = setStorage.firstElement;\\n        uint256 numElements = setStorage.numElements;\\n\\n        if (index1 >= index2 || index2 >= numElements) {\\n            revert InvalidIndex();\\n        }\\n\\n        if (index1 == 0) {\\n            (setStorage.firstElement, setStorage.elements[index2].value) =\\n                (setStorage.elements[index2].value, firstElement);\\n        } else {\\n            (setStorage.elements[index1].value, setStorage.elements[index2].value) =\\n                (setStorage.elements[index2].value, setStorage.elements[index1].value);\\n        }\\n    }\\n\\n    /// @notice Sets the metadata for the set storage.\\n    /// @param setStorage The storage structure where metadata will be set.\\n    /// @param metadata The metadata value to set.\\n    function setMetadata(SetStorage storage setStorage, uint80 metadata) internal {\\n        setStorage.metadata = metadata;\\n    }\\n\\n    /// @notice Returns an array of elements contained in the storage.\\n    /// @dev The order of the elements in the array may be affected by performing operations on the set.\\n    /// @param setStorage The set storage to be processed.\\n    /// @return An array that contains the same elements as the set storage.\\n    function get(SetStorage storage setStorage) internal view returns (address[] memory) {\\n        address firstElement = setStorage.firstElement;\\n        uint256 numElements = setStorage.numElements;\\n        address[] memory output = new address[](numElements);\\n\\n        if (numElements == 0) return output;\\n\\n        output[0] = firstElement;\\n\\n        for (uint256 i = EMPTY_ELEMENT_OFFSET; i < numElements; ++i) {\\n            output[i] = setStorage.elements[i].value;\\n        }\\n\\n        return output;\\n    }\\n\\n    /// @notice Retrieves the metadata from the set storage.\\n    /// @param setStorage The storage structure from which metadata is retrieved.\\n    /// @return The metadata value.\\n    function getMetadata(SetStorage storage setStorage) internal view returns (uint80) {\\n        return setStorage.metadata;\\n    }\\n\\n    /// @notice Checks if the set storage contains a given element and returns a boolean value that indicates the\\n    /// result.\\n    /// @param setStorage The set storage to be searched.\\n    /// @param element The element to be searched for.\\n    /// @return A boolean value that indicates whether the set storage includes the element or not.\\n    function contains(SetStorage storage setStorage, address element) internal view returns (bool) {\\n        address firstElement = setStorage.firstElement;\\n        uint256 numElements = setStorage.numElements;\\n\\n        if (numElements == 0) return false;\\n        if (firstElement == element) return true;\\n\\n        for (uint256 i = EMPTY_ELEMENT_OFFSET; i < numElements; ++i) {\\n            if (setStorage.elements[i].value == element) return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /// @notice Iterates over each element in the set and applies the callback function to it.\\n    /// @dev The set is cleared as a result of this call. Considering that this function does not follow the\\n    /// Checks-Effects-Interactions pattern, the function using it must prevent re-entrancy. This function does not\\n    /// modify the metadata of the set.\\n    /// @param setStorage The set storage to be processed.\\n    /// @param callback The function to be applied to each element.\\n    function forEachAndClear(SetStorage storage setStorage, function(address) callback) internal {\\n        uint256 numElements = setStorage.numElements;\\n        address firstElement = setStorage.firstElement;\\n        uint80 metadata = setStorage.metadata;\\n\\n        if (numElements == 0) return;\\n\\n        setStorage.numElements = 0;\\n        setStorage.firstElement = address(0);\\n        setStorage.metadata = metadata;\\n        setStorage.stamp = DUMMY_STAMP;\\n\\n        callback(firstElement);\\n\\n        for (uint256 i = EMPTY_ELEMENT_OFFSET; i < numElements; ++i) {\\n            address element = setStorage.elements[i].value;\\n            setStorage.elements[i] = ElementStorage({value: address(0), stamp: DUMMY_STAMP});\\n\\n            callback(element);\\n        }\\n    }\\n\\n    /// @notice Iterates over each element in the set and applies the callback function to it, returning the array of\\n    /// callback results.\\n    /// @dev The set is cleared as a result of this call. Considering that this function does not follow the\\n    /// Checks-Effects-Interactions pattern, the function using it must prevent re-entrancy. This function does not\\n    /// modify the metadata of the set.\\n    /// @param setStorage The set storage to be processed.\\n    /// @param callback The function to be applied to each element.\\n    /// @return result An array of encoded bytes that are the addresses passed to the callback function and results of\\n    /// calling it.\\n    function forEachAndClearWithResult(\\n        SetStorage storage setStorage,\\n        function(address) returns (bool, bytes memory) callback\\n    ) internal returns (bytes[] memory) {\\n        uint256 numElements = setStorage.numElements;\\n        address firstElement = setStorage.firstElement;\\n        uint80 metadata = setStorage.metadata;\\n        bytes[] memory results = new bytes[](numElements);\\n\\n        if (numElements == 0) return results;\\n\\n        setStorage.numElements = 0;\\n        setStorage.firstElement = address(0);\\n        setStorage.metadata = metadata;\\n        setStorage.stamp = DUMMY_STAMP;\\n\\n        (bool success, bytes memory result) = callback(firstElement);\\n        results[0] = abi.encode(firstElement, success, result);\\n\\n        for (uint256 i = EMPTY_ELEMENT_OFFSET; i < numElements; ++i) {\\n            address element = setStorage.elements[i].value;\\n            setStorage.elements[i] = ElementStorage({value: address(0), stamp: DUMMY_STAMP});\\n\\n            (success, result) = callback(element);\\n            results[i] = abi.encode(element, success, result);\\n        }\\n\\n        return results;\\n    }\\n}\\n\"},\"lib/euler-vault-kit/lib/ethereum-vault-connector/src/TransientStorage.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport {ExecutionContext, EC} from \\\"./ExecutionContext.sol\\\";\\nimport {Set, SetStorage} from \\\"./Set.sol\\\";\\n\\n/// @title TransientStorage\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice This contract provides transient storage for the Ethereum Vault Connector.\\n/// @dev All the variables in this contract are considered transient meaning that their state does not change between\\n/// invocations.\\nabstract contract TransientStorage {\\n    using ExecutionContext for EC;\\n    using Set for SetStorage;\\n\\n    enum SetType {\\n        Account,\\n        Vault\\n    }\\n\\n    EC internal executionContext;\\n    SetStorage internal accountStatusChecks;\\n    SetStorage internal vaultStatusChecks;\\n\\n    constructor() {\\n        // set the execution context to non-zero value to always keep the storage slot in non-zero state.\\n        // it allows for cheaper SSTOREs when the execution context is in its default state\\n        executionContext = EC.wrap(1 << ExecutionContext.STAMP_OFFSET);\\n\\n        // there are two types of data that are stored using SetStorage type:\\n        // - the data that is transient in nature (accountStatusChecks and vaultStatusChecks)\\n        // - the data that is permanent (accountControllers and accountCollaterals from the EthereumVaultConnector\\n        // contract)\\n\\n        // for the permanent data, there's no need to care that much about optimizations. each account has its two sets.\\n        // usually, an address inserted to either of them won't be removed within the same transaction. the only\\n        // optimization applied (directly in the Set contract) is that on the first element insertion, the stamp is set\\n        // to non-zero value to always keep that storage slot in non-zero state. it allows for cheaper SSTORE when an\\n        // element is inserted again after clearing the set.\\n\\n        // for the transient data, an address insertion should be as cheap as possible. hence on construction, we store\\n        // dummy values for all the storage slots where the elements will be stored later on. it is important\\n        // considering that both accountStatusChecks and vaultStatusChecks are always cleared at the end of the\\n        // transaction. with dummy values set, the transition from zero to non-zero and back to zero will be\\n        // significantly cheaper than it would be otherwise\\n        accountStatusChecks.initialize();\\n        vaultStatusChecks.initialize();\\n    }\\n}\\n\"},\"lib/euler-vault-kit/lib/ethereum-vault-connector/src/interfaces/IERC1271.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\\n\\npragma solidity >=0.8.0;\\n\\n/// @dev Interface of the ERC1271 standard signature validation method for\\n/// contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\ninterface IERC1271 {\\n    /// @dev Should return whether the signature provided is valid for the provided data\\n    /// @param hash Hash of the data to be signed\\n    /// @param signature Signature byte array associated with _data\\n    /// @return magicValue Must return the bytes4 magic value 0x1626ba7e (which is a selector of this function) when\\n    /// the signature is valid.\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\"},\"lib/euler-vault-kit/lib/ethereum-vault-connector/src/interfaces/IEthereumVaultConnector.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.8.0;\\n\\n/// @title IEVC\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice This interface defines the methods for the Ethereum Vault Connector.\\ninterface IEVC {\\n    /// @notice A struct representing a batch item.\\n    /// @dev Each batch item represents a single operation to be performed within a checks deferred context.\\n    struct BatchItem {\\n        /// @notice The target contract to be called.\\n        address targetContract;\\n        /// @notice The account on behalf of which the operation is to be performed. msg.sender must be authorized to\\n        /// act on behalf of this account. Must be address(0) if the target contract is the EVC itself.\\n        address onBehalfOfAccount;\\n        /// @notice The amount of value to be forwarded with the call. If the value is type(uint256).max, the whole\\n        /// balance of the EVC contract will be forwarded. Must be 0 if the target contract is the EVC itself.\\n        uint256 value;\\n        /// @notice The encoded data which is called on the target contract.\\n        bytes data;\\n    }\\n\\n    /// @notice A struct representing the result of a batch item operation.\\n    /// @dev Used only for simulation purposes.\\n    struct BatchItemResult {\\n        /// @notice A boolean indicating whether the operation was successful.\\n        bool success;\\n        /// @notice The result of the operation.\\n        bytes result;\\n    }\\n\\n    /// @notice A struct representing the result of the account or vault status check.\\n    /// @dev Used only for simulation purposes.\\n    struct StatusCheckResult {\\n        /// @notice The address of the account or vault for which the check was performed.\\n        address checkedAddress;\\n        /// @notice A boolean indicating whether the status of the account or vault is valid.\\n        bool isValid;\\n        /// @notice The result of the check.\\n        bytes result;\\n    }\\n\\n    /// @notice Returns current raw execution context.\\n    /// @dev When checks in progress, on behalf of account is always address(0).\\n    /// @return context Current raw execution context.\\n    function getRawExecutionContext() external view returns (uint256 context);\\n\\n    /// @notice Returns an account on behalf of which the operation is being executed at the moment and whether the\\n    /// controllerToCheck is an enabled controller for that account.\\n    /// @dev This function should only be used by external smart contracts if msg.sender is the EVC. Otherwise, the\\n    /// account address returned must not be trusted.\\n    /// @dev When checks in progress, on behalf of account is always address(0). When address is zero, the function\\n    /// reverts to protect the consumer from ever relying on the on behalf of account address which is in its default\\n    /// state.\\n    /// @param controllerToCheck The address of the controller for which it is checked whether it is an enabled\\n    /// controller for the account on behalf of which the operation is being executed at the moment.\\n    /// @return onBehalfOfAccount An account that has been authenticated and on behalf of which the operation is being\\n    /// executed at the moment.\\n    /// @return controllerEnabled A boolean value that indicates whether controllerToCheck is an enabled controller for\\n    /// the account on behalf of which the operation is being executed at the moment. Always false if controllerToCheck\\n    /// is address(0).\\n    function getCurrentOnBehalfOfAccount(address controllerToCheck)\\n        external\\n        view\\n        returns (address onBehalfOfAccount, bool controllerEnabled);\\n\\n    /// @notice Checks if checks are deferred.\\n    /// @return A boolean indicating whether checks are deferred.\\n    function areChecksDeferred() external view returns (bool);\\n\\n    /// @notice Checks if checks are in progress.\\n    /// @return A boolean indicating whether checks are in progress.\\n    function areChecksInProgress() external view returns (bool);\\n\\n    /// @notice Checks if control collateral is in progress.\\n    /// @return A boolean indicating whether control collateral is in progress.\\n    function isControlCollateralInProgress() external view returns (bool);\\n\\n    /// @notice Checks if an operator is authenticated.\\n    /// @return A boolean indicating whether an operator is authenticated.\\n    function isOperatorAuthenticated() external view returns (bool);\\n\\n    /// @notice Checks if a simulation is in progress.\\n    /// @return A boolean indicating whether a simulation is in progress.\\n    function isSimulationInProgress() external view returns (bool);\\n\\n    /// @notice Checks whether the specified account and the other account have the same owner.\\n    /// @dev The function is used to check whether one account is authorized to perform operations on behalf of the\\n    /// other. Accounts are considered to have a common owner if they share the first 19 bytes of their address.\\n    /// @param account The address of the account that is being checked.\\n    /// @param otherAccount The address of the other account that is being checked.\\n    /// @return A boolean flag that indicates whether the accounts have the same owner.\\n    function haveCommonOwner(address account, address otherAccount) external pure returns (bool);\\n\\n    /// @notice Returns the address prefix of the specified account.\\n    /// @dev The address prefix is the first 19 bytes of the account address.\\n    /// @param account The address of the account whose address prefix is being retrieved.\\n    /// @return A bytes19 value that represents the address prefix of the account.\\n    function getAddressPrefix(address account) external pure returns (bytes19);\\n\\n    /// @notice Returns the owner for the specified account.\\n    /// @dev The function returns address(0) if the owner is not registered. Registration of the owner happens on the\\n    /// initial\\n    /// interaction with the EVC that requires authentication of an owner.\\n    /// @param account The address of the account whose owner is being retrieved.\\n    /// @return owner The address of the account owner. An account owner is an EOA/smart contract which address matches\\n    /// the first 19 bytes of the account address.\\n    function getAccountOwner(address account) external view returns (address);\\n\\n    /// @notice Checks if lockdown mode is enabled for a given address prefix.\\n    /// @param addressPrefix The address prefix to check for lockdown mode status.\\n    /// @return A boolean indicating whether lockdown mode is enabled.\\n    function isLockdownMode(bytes19 addressPrefix) external view returns (bool);\\n\\n    /// @notice Checks if permit functionality is disabled for a given address prefix.\\n    /// @param addressPrefix The address prefix to check for permit functionality status.\\n    /// @return A boolean indicating whether permit functionality is disabled.\\n    function isPermitDisabledMode(bytes19 addressPrefix) external view returns (bool);\\n\\n    /// @notice Returns the current nonce for a given address prefix and nonce namespace.\\n    /// @dev Each nonce namespace provides 256 bit nonce that has to be used sequentially. There's no requirement to use\\n    /// all the nonces for a given nonce namespace before moving to the next one which allows to use permit messages in\\n    /// a non-sequential manner.\\n    /// @param addressPrefix The address prefix for which the nonce is being retrieved.\\n    /// @param nonceNamespace The nonce namespace for which the nonce is being retrieved.\\n    /// @return nonce The current nonce for the given address prefix and nonce namespace.\\n    function getNonce(bytes19 addressPrefix, uint256 nonceNamespace) external view returns (uint256 nonce);\\n\\n    /// @notice Returns the bit field for a given address prefix and operator.\\n    /// @dev The bit field is used to store information about authorized operators for a given address prefix. Each bit\\n    /// in the bit field corresponds to one account belonging to the same owner. If the bit is set, the operator is\\n    /// authorized for the account.\\n    /// @param addressPrefix The address prefix for which the bit field is being retrieved.\\n    /// @param operator The address of the operator for which the bit field is being retrieved.\\n    /// @return operatorBitField The bit field for the given address prefix and operator. The bit field defines which\\n    /// accounts the operator is authorized for. It is a 256-position binary array like 0...010...0, marking the account\\n    /// positionally in a uint256. The position in the bit field corresponds to the account ID (0-255), where 0 is the\\n    /// owner account's ID.\\n    function getOperator(bytes19 addressPrefix, address operator) external view returns (uint256 operatorBitField);\\n\\n    /// @notice Returns whether a given operator has been authorized for a given account.\\n    /// @param account The address of the account whose operator is being checked.\\n    /// @param operator The address of the operator that is being checked.\\n    /// @return authorized A boolean value that indicates whether the operator is authorized for the account.\\n    function isAccountOperatorAuthorized(address account, address operator) external view returns (bool authorized);\\n\\n    /// @notice Enables or disables lockdown mode for a given address prefix.\\n    /// @dev This function can only be called by the owner of the address prefix. To disable this mode, the EVC\\n    /// must be called directly. It is not possible to disable this mode by using checks-deferrable call or\\n    /// permit message.\\n    /// @param addressPrefix The address prefix for which the lockdown mode is being set.\\n    /// @param enabled A boolean indicating whether to enable or disable lockdown mode.\\n    function setLockdownMode(bytes19 addressPrefix, bool enabled) external payable;\\n\\n    /// @notice Enables or disables permit functionality for a given address prefix.\\n    /// @dev This function can only be called by the owner of the address prefix. To disable this mode, the EVC\\n    /// must be called directly. It is not possible to disable this mode by using checks-deferrable call or (by\\n    /// definition) permit message. To support permit functionality by default, note that the logic was inverted here. To\\n    /// disable  the permit functionality, one must pass true as the second argument. To enable the permit\\n    /// functionality, one must pass false as the second argument.\\n    /// @param addressPrefix The address prefix for which the permit functionality is being set.\\n    /// @param enabled A boolean indicating whether to enable or disable the disable-permit mode.\\n    function setPermitDisabledMode(bytes19 addressPrefix, bool enabled) external payable;\\n\\n    /// @notice Sets the nonce for a given address prefix and nonce namespace.\\n    /// @dev This function can only be called by the owner of the address prefix. Each nonce namespace provides a 256\\n    /// bit nonce that has to be used sequentially. There's no requirement to use all the nonces for a given nonce\\n    /// namespace before moving to the next one which allows the use of permit messages in a non-sequential manner. To\\n    /// invalidate signed permit messages, set the nonce for a given nonce namespace accordingly. To invalidate all the\\n    /// permit messages for a given nonce namespace, set the nonce to type(uint).max.\\n    /// @param addressPrefix The address prefix for which the nonce is being set.\\n    /// @param nonceNamespace The nonce namespace for which the nonce is being set.\\n    /// @param nonce The new nonce for the given address prefix and nonce namespace.\\n    function setNonce(bytes19 addressPrefix, uint256 nonceNamespace, uint256 nonce) external payable;\\n\\n    /// @notice Sets the bit field for a given address prefix and operator.\\n    /// @dev This function can only be called by the owner of the address prefix. Each bit in the bit field corresponds\\n    /// to one account belonging to the same owner. If the bit is set, the operator is authorized for the account.\\n    /// @param addressPrefix The address prefix for which the bit field is being set.\\n    /// @param operator The address of the operator for which the bit field is being set. Can neither be the EVC address\\n    /// nor an address belonging to the same address prefix.\\n    /// @param operatorBitField The new bit field for the given address prefix and operator. Reverts if the provided\\n    /// value is equal to the currently stored value.\\n    function setOperator(bytes19 addressPrefix, address operator, uint256 operatorBitField) external payable;\\n\\n    /// @notice Authorizes or deauthorizes an operator for the account.\\n    /// @dev Only the owner or authorized operator of the account can call this function. An operator is an address that\\n    /// can perform actions for an account on behalf of the owner. If it's an operator calling this function, it can\\n    /// only deauthorize itself.\\n    /// @param account The address of the account whose operator is being set or unset.\\n    /// @param operator The address of the operator that is being installed or uninstalled. Can neither be the EVC\\n    /// address nor an address belonging to the same owner as the account.\\n    /// @param authorized A boolean value that indicates whether the operator is being authorized or deauthorized.\\n    /// Reverts if the provided value is equal to the currently stored value.\\n    function setAccountOperator(address account, address operator, bool authorized) external payable;\\n\\n    /// @notice Returns an array of collaterals enabled for an account.\\n    /// @dev A collateral is a vault for which an account's balances are under the control of the currently enabled\\n    /// controller vault.\\n    /// @param account The address of the account whose collaterals are being queried.\\n    /// @return An array of addresses that are enabled collaterals for the account.\\n    function getCollaterals(address account) external view returns (address[] memory);\\n\\n    /// @notice Returns whether a collateral is enabled for an account.\\n    /// @dev A collateral is a vault for which account's balances are under the control of the currently enabled\\n    /// controller vault.\\n    /// @param account The address of the account that is being checked.\\n    /// @param vault The address of the collateral that is being checked.\\n    /// @return A boolean value that indicates whether the vault is an enabled collateral for the account or not.\\n    function isCollateralEnabled(address account, address vault) external view returns (bool);\\n\\n    /// @notice Enables a collateral for an account.\\n    /// @dev A collaterals is a vault for which account's balances are under the control of the currently enabled\\n    /// controller vault. Only the owner or an operator of the account can call this function. Unless it's a duplicate,\\n    /// the collateral is added to the end of the array. There can be at most 10 unique collaterals enabled at a time.\\n    /// Account status checks are performed.\\n    /// @param account The account address for which the collateral is being enabled.\\n    /// @param vault The address being enabled as a collateral.\\n    function enableCollateral(address account, address vault) external payable;\\n\\n    /// @notice Disables a collateral for an account.\\n    /// @dev This function does not preserve the order of collaterals in the array obtained using the getCollaterals\\n    /// function; the order may change. A collateral is a vault for which accounts balances are under the control of\\n    /// the currently enabled controller vault. Only the owner or an operator of the account can call this function.\\n    /// Disabling a collateral might change the order of collaterals in the array obtained using getCollaterals\\n    /// function. Account status checks are performed.\\n    /// @param account The account address for which the collateral is being disabled.\\n    /// @param vault The address of a collateral being disabled.\\n    function disableCollateral(address account, address vault) external payable;\\n\\n    /// @notice Swaps the position of two collaterals so that they appear switched in the array of collaterals for a\\n    /// given account obtained by calling getCollaterals function.\\n    /// @dev A collateral is a vault for which accounts balances are under the control of the currently enabled\\n    /// controller vault. Only the owner or an operator of the account can call this function. The order of collaterals\\n    /// can be changed by specifying the indices of the two collaterals to be swapped. Indices are zero-based and must\\n    /// be in the range of 0 to the number of collaterals minus 1. index1 must be lower than index2. Account status\\n    /// checks are performed.\\n    /// @param account The address of the account for which the collaterals are being reordered.\\n    /// @param index1 The index of the first collateral to be swapped.\\n    /// @param index2 The index of the second collateral to be swapped.\\n    function reorderCollaterals(address account, uint8 index1, uint8 index2) external payable;\\n\\n    /// @notice Returns an array of enabled controllers for an account.\\n    /// @dev A controller is a vault that has been chosen for an account to have special control over the account's\\n    /// balances in enabled collaterals vaults. A user can have multiple controllers during a call execution, but at\\n    /// most one can be selected when the account status check is performed.\\n    /// @param account The address of the account whose controllers are being queried.\\n    /// @return An array of addresses that are the enabled controllers for the account.\\n    function getControllers(address account) external view returns (address[] memory);\\n\\n    /// @notice Returns whether a controller is enabled for an account.\\n    /// @dev A controller is a vault that has been chosen for an account to have special control over accounts\\n    /// balances in the enabled collaterals vaults.\\n    /// @param account The address of the account that is being checked.\\n    /// @param vault The address of the controller that is being checked.\\n    /// @return A boolean value that indicates whether the vault is enabled controller for the account or not.\\n    function isControllerEnabled(address account, address vault) external view returns (bool);\\n\\n    /// @notice Enables a controller for an account.\\n    /// @dev A controller is a vault that has been chosen for an account to have special control over accounts\\n    /// balances in the enabled collaterals vaults. Only the owner or an operator of the account can call this function.\\n    /// Unless it's a duplicate, the controller is added to the end of the array. Transiently, there can be at most 10\\n    /// unique controllers enabled at a time, but at most one can be enabled after the outermost checks-deferrable\\n    /// call concludes. Account status checks are performed.\\n    /// @param account The address for which the controller is being enabled.\\n    /// @param vault The address of the controller being enabled.\\n    function enableController(address account, address vault) external payable;\\n\\n    /// @notice Disables a controller for an account.\\n    /// @dev A controller is a vault that has been chosen for an account to have special control over accounts\\n    /// balances in the enabled collaterals vaults. Only the vault itself can call this function. Disabling a controller\\n    /// might change the order of controllers in the array obtained using getControllers function. Account status checks\\n    /// are performed.\\n    /// @param account The address for which the calling controller is being disabled.\\n    function disableController(address account) external payable;\\n\\n    /// @notice Executes signed arbitrary data by self-calling into the EVC.\\n    /// @dev Low-level call function is used to execute the arbitrary data signed by the owner or the operator on the\\n    /// EVC contract. During that call, EVC becomes msg.sender.\\n    /// @param signer The address signing the permit message (ECDSA) or verifying the permit message signature\\n    /// (ERC-1271). It's also the owner or the operator of all the accounts for which authentication will be needed\\n    /// during the execution of the arbitrary data call.\\n    /// @param sender The address of the msg.sender which is expected to execute the data signed by the signer. If\\n    /// address(0) is passed, the msg.sender is ignored.\\n    /// @param nonceNamespace The nonce namespace for which the nonce is being used.\\n    /// @param nonce The nonce for the given account and nonce namespace. A valid nonce value is considered to be the\\n    /// value currently stored and can take any value between 0 and type(uint256).max - 1.\\n    /// @param deadline The timestamp after which the permit is considered expired.\\n    /// @param value The amount of value to be forwarded with the call. If the value is type(uint256).max, the whole\\n    /// balance of the EVC contract will be forwarded.\\n    /// @param data The encoded data which is self-called on the EVC contract.\\n    /// @param signature The signature of the data signed by the signer.\\n    function permit(\\n        address signer,\\n        address sender,\\n        uint256 nonceNamespace,\\n        uint256 nonce,\\n        uint256 deadline,\\n        uint256 value,\\n        bytes calldata data,\\n        bytes calldata signature\\n    ) external payable;\\n\\n    /// @notice Calls into a target contract as per data encoded.\\n    /// @dev This function defers the account and vault status checks (it's a checks-deferrable call). If the outermost\\n    /// call ends, the account and vault status checks are performed.\\n    /// @dev This function can be used to interact with any contract while checks are deferred. If the target contract\\n    /// is msg.sender, msg.sender is called back with the calldata provided and the context set up according to the\\n    /// account provided. If the target contract is not msg.sender, only the owner or the operator of the account\\n    /// provided can call this function.\\n    /// @dev This function can be used to recover the remaining value from the EVC contract.\\n    /// @param targetContract The address of the contract to be called.\\n    /// @param onBehalfOfAccount  If the target contract is msg.sender, the address of the account which will be set\\n    /// in the context. It assumes msg.sender has authenticated the account themselves. If the target contract is\\n    /// not msg.sender, the address of the account for which it is checked whether msg.sender is authorized to act\\n    /// on behalf of.\\n    /// @param value The amount of value to be forwarded with the call. If the value is type(uint256).max, the whole\\n    /// balance of the EVC contract will be forwarded.\\n    /// @param data The encoded data which is called on the target contract.\\n    /// @return result The result of the call.\\n    function call(\\n        address targetContract,\\n        address onBehalfOfAccount,\\n        uint256 value,\\n        bytes calldata data\\n    ) external payable returns (bytes memory result);\\n\\n    /// @notice For a given account, calls into one of the enabled collateral vaults from the currently enabled\\n    /// controller vault as per data encoded.\\n    /// @dev This function defers the account and vault status checks (it's a checks-deferrable call). If the outermost\\n    /// call ends, the account and vault status checks are performed.\\n    /// @dev This function can be used to interact with any contract while checks are deferred as long as the contract\\n    /// is enabled as a collateral of the account and the msg.sender is the only enabled controller of the account.\\n    /// @param targetCollateral The collateral address to be called.\\n    /// @param onBehalfOfAccount The address of the account for which it is checked whether msg.sender is authorized to\\n    /// act on behalf.\\n    /// @param value The amount of value to be forwarded with the call. If the value is type(uint256).max, the whole\\n    /// balance of the EVC contract will be forwarded.\\n    /// @param data The encoded data which is called on the target collateral.\\n    /// @return result The result of the call.\\n    function controlCollateral(\\n        address targetCollateral,\\n        address onBehalfOfAccount,\\n        uint256 value,\\n        bytes calldata data\\n    ) external payable returns (bytes memory result);\\n\\n    /// @notice Executes multiple calls into the target contracts while checks deferred as per batch items provided.\\n    /// @dev This function defers the account and vault status checks (it's a checks-deferrable call). If the outermost\\n    /// call ends, the account and vault status checks are performed.\\n    /// @dev The authentication rules for each batch item are the same as for the call function.\\n    /// @param items An array of batch items to be executed.\\n    function batch(BatchItem[] calldata items) external payable;\\n\\n    /// @notice Executes multiple calls into the target contracts while checks deferred as per batch items provided.\\n    /// @dev This function always reverts as it's only used for simulation purposes. This function cannot be called\\n    /// within a checks-deferrable call.\\n    /// @param items An array of batch items to be executed.\\n    function batchRevert(BatchItem[] calldata items) external payable;\\n\\n    /// @notice Executes multiple calls into the target contracts while checks deferred as per batch items provided.\\n    /// @dev This function does not modify state and should only be used for simulation purposes. This function cannot\\n    /// be called within a checks-deferrable call.\\n    /// @param items An array of batch items to be executed.\\n    /// @return batchItemsResult An array of batch item results for each item.\\n    /// @return accountsStatusCheckResult An array of account status check results for each account.\\n    /// @return vaultsStatusCheckResult An array of vault status check results for each vault.\\n    function batchSimulation(BatchItem[] calldata items)\\n        external\\n        payable\\n        returns (\\n            BatchItemResult[] memory batchItemsResult,\\n            StatusCheckResult[] memory accountsStatusCheckResult,\\n            StatusCheckResult[] memory vaultsStatusCheckResult\\n        );\\n\\n    /// @notice Retrieves the timestamp of the last successful account status check performed for a specific account.\\n    /// @dev This function reverts if the checks are in progress.\\n    /// @dev The account status check is considered to be successful if it calls into the selected controller vault and\\n    /// obtains expected magic value. This timestamp does not change if the account status is considered valid when no\\n    /// controller enabled. When consuming, one might need to ensure that the account status check is not deferred at\\n    /// the moment.\\n    /// @param account The address of the account for which the last status check timestamp is being queried.\\n    /// @return The timestamp of the last status check as a uint256.\\n    function getLastAccountStatusCheckTimestamp(address account) external view returns (uint256);\\n\\n    /// @notice Checks whether the status check is deferred for a given account.\\n    /// @dev This function reverts if the checks are in progress.\\n    /// @param account The address of the account for which it is checked whether the status check is deferred.\\n    /// @return A boolean flag that indicates whether the status check is deferred or not.\\n    function isAccountStatusCheckDeferred(address account) external view returns (bool);\\n\\n    /// @notice Checks the status of an account and reverts if it is not valid.\\n    /// @dev If checks deferred, the account is added to the set of accounts to be checked at the end of the outermost\\n    /// checks-deferrable call. There can be at most 10 unique accounts added to the set at a time. Account status\\n    /// check is performed by calling into the selected controller vault and passing the array of currently enabled\\n    /// collaterals. If controller is not selected, the account is always considered valid.\\n    /// @param account The address of the account to be checked.\\n    function requireAccountStatusCheck(address account) external payable;\\n\\n    /// @notice Forgives previously deferred account status check.\\n    /// @dev Account address is removed from the set of addresses for which status checks are deferred. This function\\n    /// can only be called by the currently enabled controller of a given account. Depending on the vault\\n    /// implementation, may be needed in the liquidation flow.\\n    /// @param account The address of the account for which the status check is forgiven.\\n    function forgiveAccountStatusCheck(address account) external payable;\\n\\n    /// @notice Checks whether the status check is deferred for a given vault.\\n    /// @dev This function reverts if the checks are in progress.\\n    /// @param vault The address of the vault for which it is checked whether the status check is deferred.\\n    /// @return A boolean flag that indicates whether the status check is deferred or not.\\n    function isVaultStatusCheckDeferred(address vault) external view returns (bool);\\n\\n    /// @notice Checks the status of a vault and reverts if it is not valid.\\n    /// @dev If checks deferred, the vault is added to the set of vaults to be checked at the end of the outermost\\n    /// checks-deferrable call. There can be at most 10 unique vaults added to the set at a time. This function can\\n    /// only be called by the vault itself.\\n    function requireVaultStatusCheck() external payable;\\n\\n    /// @notice Forgives previously deferred vault status check.\\n    /// @dev Vault address is removed from the set of addresses for which status checks are deferred. This function can\\n    /// only be called by the vault itself.\\n    function forgiveVaultStatusCheck() external payable;\\n\\n    /// @notice Checks the status of an account and a vault and reverts if it is not valid.\\n    /// @dev If checks deferred, the account and the vault are added to the respective sets of accounts and vaults to be\\n    /// checked at the end of the outermost checks-deferrable call. Account status check is performed by calling into\\n    /// selected controller vault and passing the array of currently enabled collaterals. If controller is not selected,\\n    /// the account is always considered valid. This function can only be called by the vault itself.\\n    /// @param account The address of the account to be checked.\\n    function requireAccountAndVaultStatusCheck(address account) external payable;\\n}\\n\"},\"lib/euler-vault-kit/lib/ethereum-vault-connector/src/interfaces/IVault.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.8.0;\\n\\n/// @title IVault\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice This interface defines the methods for the Vault for the purpose of integration with the Ethereum Vault\\n/// Connector.\\ninterface IVault {\\n    /// @notice Disables a controller (this vault) for the authenticated account.\\n    /// @dev A controller is a vault that has been chosen for an account to have special control over accounts\\n    /// balances in the enabled collaterals vaults. User calls this function in order for the vault to disable itself\\n    /// for the account if the conditions are met (i.e. user has repaid debt in full). If the conditions are not met,\\n    /// the function reverts.\\n    function disableController() external;\\n\\n    /// @notice Checks the status of an account.\\n    /// @dev This function must only deliberately revert if the account status is invalid. If this function reverts due\\n    /// to any other reason, it may render the account unusable with possibly no way to recover funds.\\n    /// @param account The address of the account to be checked.\\n    /// @param collaterals The array of enabled collateral addresses to be considered for the account status check.\\n    /// @return magicValue Must return the bytes4 magic value 0xb168c58f (which is a selector of this function) when\\n    /// account status is valid, or revert otherwise.\\n    function checkAccountStatus(\\n        address account,\\n        address[] calldata collaterals\\n    ) external view returns (bytes4 magicValue);\\n\\n    /// @notice Checks the status of the vault.\\n    /// @dev This function must only deliberately revert if the vault status is invalid. If this function reverts due to\\n    /// any other reason, it may render some accounts unusable with possibly no way to recover funds.\\n    /// @return magicValue Must return the bytes4 magic value 0x4b3d1223 (which is a selector of this function) when\\n    /// account status is valid, or revert otherwise.\\n    function checkVaultStatus() external returns (bytes4 magicValue);\\n}\\n\"},\"lib/euler-vault-kit/src/EVault/IEVault.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.8.0;\\n\\nimport {IVault as IEVCVault} from \\\"ethereum-vault-connector/interfaces/IVault.sol\\\";\\n\\n// Full interface of EVault and all it's modules\\n\\n/// @title IInitialize\\n/// @notice Interface of the initialization module of EVault\\ninterface IInitialize {\\n    /// @notice Initialization of the newly deployed proxy contract\\n    /// @param proxyCreator Account which created the proxy or should be the initial governor\\n    function initialize(address proxyCreator) external;\\n}\\n\\n/// @title IERC20\\n/// @notice Interface of the EVault's Initialize module\\ninterface IERC20 {\\n    /// @notice Vault share token (eToken) name, ie \\\"Euler Vault: DAI\\\"\\n    /// @return The name of the eToken\\n    function name() external view returns (string memory);\\n\\n    /// @notice Vault share token (eToken) symbol, ie \\\"eDAI\\\"\\n    /// @return The symbol of the eToken\\n    function symbol() external view returns (string memory);\\n\\n    /// @notice Decimals, the same as the asset's or 18 if the asset doesn't implement `decimals()`\\n    /// @return The decimals of the eToken\\n    function decimals() external view returns (uint8);\\n\\n    /// @notice Sum of all eToken balances\\n    /// @return The total supply of the eToken\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Balance of a particular account, in eTokens\\n    /// @param account Address to query\\n    /// @return The balance of the account\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /// @notice Retrieve the current allowance\\n    /// @param holder The account holding the eTokens\\n    /// @param spender Trusted address\\n    /// @return The allowance from holder for spender\\n    function allowance(address holder, address spender) external view returns (uint256);\\n\\n    /// @notice Transfer eTokens to another address\\n    /// @param to Recipient account\\n    /// @param amount In shares.\\n    /// @return True if transfer succeeded\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /// @notice Transfer eTokens from one address to another\\n    /// @param from This address must've approved the to address\\n    /// @param to Recipient account\\n    /// @param amount In shares\\n    /// @return True if transfer succeeded\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n\\n    /// @notice Allow spender to access an amount of your eTokens\\n    /// @param spender Trusted address\\n    /// @param amount Use max uint for \\\"infinite\\\" allowance\\n    /// @return True if approval succeeded\\n    function approve(address spender, uint256 amount) external returns (bool);\\n}\\n\\n/// @title IToken\\n/// @notice Interface of the EVault's Token module\\ninterface IToken is IERC20 {\\n    /// @notice Transfer the full eToken balance of an address to another\\n    /// @param from This address must've approved the to address\\n    /// @param to Recipient account\\n    /// @return True if transfer succeeded\\n    function transferFromMax(address from, address to) external returns (bool);\\n}\\n\\n/// @title IERC4626\\n/// @notice Interface of an ERC4626 vault\\ninterface IERC4626 {\\n    /// @notice Vault's underlying asset\\n    /// @return The vault's underlying asset\\n    function asset() external view returns (address);\\n\\n    /// @notice Total amount of managed assets, cash and borrows\\n    /// @return The total amount of assets\\n    function totalAssets() external view returns (uint256);\\n\\n    /// @notice Calculate amount of assets corresponding to the requested shares amount\\n    /// @param shares Amount of shares to convert\\n    /// @return The amount of assets\\n    function convertToAssets(uint256 shares) external view returns (uint256);\\n\\n    /// @notice Calculate amount of shares corresponding to the requested assets amount\\n    /// @param assets Amount of assets to convert\\n    /// @return The amount of shares\\n    function convertToShares(uint256 assets) external view returns (uint256);\\n\\n    /// @notice Fetch the maximum amount of assets a user can deposit\\n    /// @param account Address to query\\n    /// @return The max amount of assets the account can deposit\\n    function maxDeposit(address account) external view returns (uint256);\\n\\n    /// @notice Calculate an amount of shares that would be created by depositing assets\\n    /// @param assets Amount of assets deposited\\n    /// @return Amount of shares received\\n    function previewDeposit(uint256 assets) external view returns (uint256);\\n\\n    /// @notice Fetch the maximum amount of shares a user can mint\\n    /// @param account Address to query\\n    /// @return The max amount of shares the account can mint\\n    function maxMint(address account) external view returns (uint256);\\n\\n    /// @notice Calculate an amount of assets that would be required to mint requested amount of shares\\n    /// @param shares Amount of shares to be minted\\n    /// @return Required amount of assets\\n    function previewMint(uint256 shares) external view returns (uint256);\\n\\n    /// @notice Fetch the maximum amount of assets a user is allowed to withdraw\\n    /// @param owner Account holding the shares\\n    /// @return The maximum amount of assets the owner is allowed to withdraw\\n    function maxWithdraw(address owner) external view returns (uint256);\\n\\n    /// @notice Calculate the amount of shares that will be burned when withdrawing requested amount of assets\\n    /// @param assets Amount of assets withdrawn\\n    /// @return Amount of shares burned\\n    function previewWithdraw(uint256 assets) external view returns (uint256);\\n\\n    /// @notice Fetch the maximum amount of shares a user is allowed to redeem for assets\\n    /// @param owner Account holding the shares\\n    /// @return The maximum amount of shares the owner is allowed to redeem\\n    function maxRedeem(address owner) external view returns (uint256);\\n\\n    /// @notice Calculate the amount of assets that will be transferred when redeeming requested amount of shares\\n    /// @param shares Amount of shares redeemed\\n    /// @return Amount of assets transferred\\n    function previewRedeem(uint256 shares) external view returns (uint256);\\n\\n    /// @notice Transfer requested amount of underlying tokens from sender to the vault pool in return for shares\\n    /// @param amount Amount of assets to deposit (use max uint256 for full underlying token balance)\\n    /// @param receiver An account to receive the shares\\n    /// @return Amount of shares minted\\n    /// @dev Deposit will round down the amount of assets that are converted to shares. To prevent losses consider using\\n    /// mint instead.\\n    function deposit(uint256 amount, address receiver) external returns (uint256);\\n\\n    /// @notice Transfer underlying tokens from sender to the vault pool in return for requested amount of shares\\n    /// @param amount Amount of shares to be minted\\n    /// @param receiver An account to receive the shares\\n    /// @return Amount of assets deposited\\n    function mint(uint256 amount, address receiver) external returns (uint256);\\n\\n    /// @notice Transfer requested amount of underlying tokens from the vault and decrease account's shares balance\\n    /// @param amount Amount of assets to withdraw\\n    /// @param receiver Account to receive the withdrawn assets\\n    /// @param owner Account holding the shares to burn\\n    /// @return Amount of shares burned\\n    function withdraw(uint256 amount, address receiver, address owner) external returns (uint256);\\n\\n    /// @notice Burn requested shares and transfer corresponding underlying tokens from the vault to the receiver\\n    /// @param amount Amount of shares to burn (use max uint256 to burn full owner balance)\\n    /// @param receiver Account to receive the withdrawn assets\\n    /// @param owner Account holding the shares to burn.\\n    /// @return Amount of assets transferred\\n    function redeem(uint256 amount, address receiver, address owner) external returns (uint256);\\n}\\n\\n/// @title IVault\\n/// @notice Interface of the EVault's Vault module\\ninterface IVault is IERC4626 {\\n    /// @notice Balance of the fees accumulator, in shares\\n    /// @return The accumulated fees in shares\\n    function accumulatedFees() external view returns (uint256);\\n\\n    /// @notice Balance of the fees accumulator, in underlying units\\n    /// @return The accumulated fees in asset units\\n    function accumulatedFeesAssets() external view returns (uint256);\\n\\n    /// @notice Address of the original vault creator\\n    /// @return The address of the creator\\n    function creator() external view returns (address);\\n\\n    /// @notice Creates shares for the receiver, from excess asset balances of the vault (not accounted for in `cash`)\\n    /// @param amount Amount of assets to claim (use max uint256 to claim all available assets)\\n    /// @param receiver An account to receive the shares\\n    /// @return Amount of shares minted\\n    /// @dev Could be used as an alternative deposit flow in certain scenarios. E.g. swap directly to the vault, call\\n    /// `skim` to claim deposit.\\n    function skim(uint256 amount, address receiver) external returns (uint256);\\n}\\n\\n/// @title IBorrowing\\n/// @notice Interface of the EVault's Borrowing module\\ninterface IBorrowing {\\n    /// @notice Sum of all outstanding debts, in underlying units (increases as interest is accrued)\\n    /// @return The total borrows in asset units\\n    function totalBorrows() external view returns (uint256);\\n\\n    /// @notice Sum of all outstanding debts, in underlying units scaled up by shifting\\n    /// INTERNAL_DEBT_PRECISION_SHIFT bits\\n    /// @return The total borrows in internal debt precision\\n    function totalBorrowsExact() external view returns (uint256);\\n\\n    /// @notice Balance of vault assets as tracked by deposits/withdrawals and borrows/repays\\n    /// @return The amount of assets the vault tracks as current direct holdings\\n    function cash() external view returns (uint256);\\n\\n    /// @notice Debt owed by a particular account, in underlying units\\n    /// @param account Address to query\\n    /// @return The debt of the account in asset units\\n    function debtOf(address account) external view returns (uint256);\\n\\n    /// @notice Debt owed by a particular account, in underlying units scaled up by shifting\\n    /// INTERNAL_DEBT_PRECISION_SHIFT bits\\n    /// @param account Address to query\\n    /// @return The debt of the account in internal precision\\n    function debtOfExact(address account) external view returns (uint256);\\n\\n    /// @notice Retrieves the current interest rate for an asset\\n    /// @return The interest rate in yield-per-second, scaled by 10**27\\n    function interestRate() external view returns (uint256);\\n\\n    /// @notice Retrieves the current interest rate accumulator for an asset\\n    /// @return An opaque accumulator that increases as interest is accrued\\n    function interestAccumulator() external view returns (uint256);\\n\\n    /// @notice Returns an address of the sidecar DToken\\n    /// @return The address of the DToken\\n    function dToken() external view returns (address);\\n\\n    /// @notice Transfer underlying tokens from the vault to the sender, and increase sender's debt\\n    /// @param amount Amount of assets to borrow (use max uint256 for all available tokens)\\n    /// @param receiver Account receiving the borrowed tokens\\n    /// @return Amount of assets borrowed\\n    function borrow(uint256 amount, address receiver) external returns (uint256);\\n\\n    /// @notice Transfer underlying tokens from the sender to the vault, and decrease receiver's debt\\n    /// @param amount Amount of debt to repay in assets (use max uint256 for full debt)\\n    /// @param receiver Account holding the debt to be repaid\\n    /// @return Amount of assets repaid\\n    function repay(uint256 amount, address receiver) external returns (uint256);\\n\\n    /// @notice Pay off liability with shares (\\\"self-repay\\\")\\n    /// @param amount In asset units (use max uint256 to repay the debt in full or up to the available deposit)\\n    /// @param receiver Account to remove debt from by burning sender's shares\\n    /// @return shares Amount of shares burned\\n    /// @return debt Amount of debt removed in assets\\n    /// @dev Equivalent to withdrawing and repaying, but no assets are needed to be present in the vault\\n    /// @dev Contrary to a regular `repay`, if account is unhealthy, the repay amount must bring the account back to\\n    /// health, or the operation will revert during account status check\\n    function repayWithShares(uint256 amount, address receiver) external returns (uint256 shares, uint256 debt);\\n\\n    /// @notice Take over debt from another account\\n    /// @param amount Amount of debt in asset units (use max uint256 for all the account's debt)\\n    /// @param from Account to pull the debt from\\n    /// @dev Due to internal debt precision accounting, the liability reported on either or both accounts after\\n    /// calling `pullDebt` may not match the `amount` requested precisely\\n    function pullDebt(uint256 amount, address from) external;\\n\\n    /// @notice Request a flash-loan. A onFlashLoan() callback in msg.sender will be invoked, which must repay the loan\\n    /// to the main Euler address prior to returning.\\n    /// @param amount In asset units\\n    /// @param data Passed through to the onFlashLoan() callback, so contracts don't need to store transient data in\\n    /// storage\\n    function flashLoan(uint256 amount, bytes calldata data) external;\\n\\n    /// @notice Updates interest accumulator and totalBorrows, credits reserves, re-targets interest rate, and logs\\n    /// vault status\\n    function touch() external;\\n}\\n\\n/// @title ILiquidation\\n/// @notice Interface of the EVault's Liquidation module\\ninterface ILiquidation {\\n    /// @notice Checks to see if a liquidation would be profitable, without actually doing anything\\n    /// @param liquidator Address that will initiate the liquidation\\n    /// @param violator Address that may be in collateral violation\\n    /// @param collateral Collateral which is to be seized\\n    /// @return maxRepay Max amount of debt that can be repaid, in asset units\\n    /// @return maxYield Yield in collateral corresponding to max allowed amount of debt to be repaid, in collateral\\n    /// balance (shares for vaults)\\n    function checkLiquidation(address liquidator, address violator, address collateral)\\n        external\\n        view\\n        returns (uint256 maxRepay, uint256 maxYield);\\n\\n    /// @notice Attempts to perform a liquidation\\n    /// @param violator Address that may be in collateral violation\\n    /// @param collateral Collateral which is to be seized\\n    /// @param repayAssets The amount of underlying debt to be transferred from violator to sender, in asset units (use\\n    /// max uint256 to repay the maximum possible amount). Meant as slippage check together with `minYieldBalance`\\n    /// @param minYieldBalance The minimum acceptable amount of collateral to be transferred from violator to sender, in\\n    /// collateral balance units (shares for vaults).  Meant as slippage check together with `repayAssets`\\n    /// @dev If `repayAssets` is set to max uint256 it is assumed the caller will perform their own slippage checks to\\n    /// make sure they are not taking on too much debt. This option is mainly meant for smart contract liquidators\\n    function liquidate(address violator, address collateral, uint256 repayAssets, uint256 minYieldBalance) external;\\n}\\n\\n/// @title IRiskManager\\n/// @notice Interface of the EVault's RiskManager module\\ninterface IRiskManager is IEVCVault {\\n    /// @notice Retrieve account's total liquidity\\n    /// @param account Account holding debt in this vault\\n    /// @param liquidation Flag to indicate if the calculation should be performed in liquidation vs account status\\n    /// check mode, where different LTV values might apply.\\n    /// @return collateralValue Total risk adjusted value of all collaterals in unit of account\\n    /// @return liabilityValue Value of debt in unit of account\\n    function accountLiquidity(address account, bool liquidation)\\n        external\\n        view\\n        returns (uint256 collateralValue, uint256 liabilityValue);\\n\\n    /// @notice Retrieve account's liquidity per collateral\\n    /// @param account Account holding debt in this vault\\n    /// @param liquidation Flag to indicate if the calculation should be performed in liquidation vs account status\\n    /// check mode, where different LTV values might apply.\\n    /// @return collaterals Array of collaterals enabled\\n    /// @return collateralValues Array of risk adjusted collateral values corresponding to items in collaterals array.\\n    /// In unit of account\\n    /// @return liabilityValue Value of debt in unit of account\\n    function accountLiquidityFull(address account, bool liquidation)\\n        external\\n        view\\n        returns (address[] memory collaterals, uint256[] memory collateralValues, uint256 liabilityValue);\\n\\n    /// @notice Release control of the account on EVC if no outstanding debt is present\\n    function disableController() external;\\n\\n    /// @notice Checks the status of an account and reverts if account is not healthy\\n    /// @param account The address of the account to be checked\\n    /// @return magicValue Must return the bytes4 magic value 0xb168c58f (which is a selector of this function) when\\n    /// account status is valid, or revert otherwise.\\n    /// @dev Only callable by EVC during status checks\\n    function checkAccountStatus(address account, address[] calldata collaterals) external view returns (bytes4);\\n\\n    /// @notice Checks the status of the vault and reverts if caps are exceeded\\n    /// @return magicValue Must return the bytes4 magic value 0x4b3d1223 (which is a selector of this function) when\\n    /// account status is valid, or revert otherwise.\\n    /// @dev Only callable by EVC during status checks\\n    function checkVaultStatus() external returns (bytes4);\\n}\\n\\n/// @title IBalanceForwarder\\n/// @notice Interface of the EVault's BalanceForwarder module\\ninterface IBalanceForwarder {\\n    /// @notice Retrieve the address of rewards contract, tracking changes in account's balances\\n    /// @return The balance tracker address\\n    function balanceTrackerAddress() external view returns (address);\\n\\n    /// @notice Retrieves boolean indicating if the account opted in to forward balance changes to the rewards contract\\n    /// @param account Address to query\\n    /// @return True if balance forwarder is enabled\\n    function balanceForwarderEnabled(address account) external view returns (bool);\\n\\n    /// @notice Enables balance forwarding for the authenticated account\\n    /// @dev Only the authenticated account can enable balance forwarding for itself\\n    /// @dev Should call the IBalanceTracker hook with the current account's balance\\n    function enableBalanceForwarder() external;\\n\\n    /// @notice Disables balance forwarding for the authenticated account\\n    /// @dev Only the authenticated account can disable balance forwarding for itself\\n    /// @dev Should call the IBalanceTracker hook with the account's balance of 0\\n    function disableBalanceForwarder() external;\\n}\\n\\n/// @title IGovernance\\n/// @notice Interface of the EVault's Governance module\\ninterface IGovernance {\\n    /// @notice Retrieves the address of the governor\\n    /// @return The governor address\\n    function governorAdmin() external view returns (address);\\n\\n    /// @notice Retrieves address of the governance fee receiver\\n    /// @return The fee receiver address\\n    function feeReceiver() external view returns (address);\\n\\n    /// @notice Retrieves the interest fee in effect for the vault\\n    /// @return Amount of interest that is redirected as a fee, as a fraction scaled by 1e4\\n    function interestFee() external view returns (uint16);\\n\\n    /// @notice Looks up an asset's currently configured interest rate model\\n    /// @return Address of the interest rate contract or address zero to indicate 0% interest\\n    function interestRateModel() external view returns (address);\\n\\n    /// @notice Retrieves the ProtocolConfig address\\n    /// @return The protocol config address\\n    function protocolConfigAddress() external view returns (address);\\n\\n    /// @notice Retrieves the protocol fee share\\n    /// @return A percentage share of fees accrued belonging to the protocol, in 1e4 scale\\n    function protocolFeeShare() external view returns (uint256);\\n\\n    /// @notice Retrieves the address which will receive protocol's fees\\n    /// @notice The protocol fee receiver address\\n    function protocolFeeReceiver() external view returns (address);\\n\\n    /// @notice Retrieves supply and borrow caps in AmountCap format\\n    /// @return supplyCap The supply cap in AmountCap format\\n    /// @return borrowCap The borrow cap in AmountCap format\\n    function caps() external view returns (uint16 supplyCap, uint16 borrowCap);\\n\\n    /// @notice Retrieves the borrow LTV of the collateral, which is used to determine if the account is healthy during\\n    /// account status checks.\\n    /// @param collateral The address of the collateral to query\\n    /// @return Borrowing LTV in 1e4 scale\\n    function LTVBorrow(address collateral) external view returns (uint16);\\n\\n    /// @notice Retrieves the current liquidation LTV, which is used to determine if the account is eligible for\\n    /// liquidation\\n    /// @param collateral The address of the collateral to query\\n    /// @return Liquidation LTV in 1e4 scale\\n    function LTVLiquidation(address collateral) external view returns (uint16);\\n\\n    /// @notice Retrieves LTV configuration for the collateral\\n    /// @param collateral Collateral asset\\n    /// @return borrowLTV The current value of borrow LTV for originating positions\\n    /// @return liquidationLTV The value of fully converged liquidation LTV\\n    /// @return initialLiquidationLTV The initial value of the liquidation LTV, when the ramp began\\n    /// @return targetTimestamp The timestamp when the liquidation LTV is considered fully converged\\n    /// @return rampDuration The time it takes for the liquidation LTV to converge from the initial value to the fully\\n    /// converged value\\n    function LTVFull(address collateral)\\n        external\\n        view\\n        returns (\\n            uint16 borrowLTV,\\n            uint16 liquidationLTV,\\n            uint16 initialLiquidationLTV,\\n            uint48 targetTimestamp,\\n            uint32 rampDuration\\n        );\\n\\n    /// @notice Retrieves a list of collaterals with configured LTVs\\n    /// @return List of asset collaterals\\n    /// @dev Returned assets could have the ltv disabled (set to zero)\\n    function LTVList() external view returns (address[] memory);\\n\\n    /// @notice Retrieves the maximum liquidation discount\\n    /// @return The maximum liquidation discount in 1e4 scale\\n    /// @dev The default value, which is zero, is deliberately bad, as it means there would be no incentive to liquidate\\n    /// unhealthy users. The vault creator must take care to properly select the limit, given the underlying and\\n    /// collaterals used.\\n    function maxLiquidationDiscount() external view returns (uint16);\\n\\n    /// @notice Retrieves liquidation cool-off time, which must elapse after successful account status check before\\n    /// account can be liquidated\\n    /// @return The liquidation cool off time in seconds\\n    function liquidationCoolOffTime() external view returns (uint16);\\n\\n    /// @notice Retrieves a hook target and a bitmask indicating which operations call the hook target\\n    /// @return hookTarget Address of the hook target contract\\n    /// @return hookedOps Bitmask with operations that should call the hooks. See Constants.sol for a list of operations\\n    function hookConfig() external view returns (address hookTarget, uint32 hookedOps);\\n\\n    /// @notice Retrieves a bitmask indicating enabled config flags\\n    /// @return Bitmask with config flags enabled\\n    function configFlags() external view returns (uint32);\\n\\n    /// @notice Address of EthereumVaultConnector contract\\n    /// @return The EVC address\\n    function EVC() external view returns (address);\\n\\n    /// @notice Retrieves a reference asset used for liquidity calculations\\n    /// @return The address of the reference asset\\n    function unitOfAccount() external view returns (address);\\n\\n    /// @notice Retrieves the address of the oracle contract\\n    /// @return The address of the oracle\\n    function oracle() external view returns (address);\\n\\n    /// @notice Retrieves the Permit2 contract address\\n    /// @return The address of the Permit2 contract\\n    function permit2Address() external view returns (address);\\n\\n    /// @notice Splits accrued fees balance according to protocol fee share and transfers shares to the governor fee\\n    /// receiver and protocol fee receiver\\n    function convertFees() external;\\n\\n    /// @notice Set a new governor address\\n    /// @param newGovernorAdmin The new governor address\\n    /// @dev Set to zero address to renounce privileges and make the vault non-governed\\n    function setGovernorAdmin(address newGovernorAdmin) external;\\n\\n    /// @notice Set a new governor fee receiver address\\n    /// @param newFeeReceiver The new fee receiver address\\n    function setFeeReceiver(address newFeeReceiver) external;\\n\\n    /// @notice Set a new LTV config\\n    /// @param collateral Address of collateral to set LTV for\\n    /// @param borrowLTV New borrow LTV, for assessing account's health during account status checks, in 1e4 scale\\n    /// @param liquidationLTV New liquidation LTV after ramp ends in 1e4 scale\\n    /// @param rampDuration Ramp duration in seconds\\n    function setLTV(address collateral, uint16 borrowLTV, uint16 liquidationLTV, uint32 rampDuration) external;\\n\\n    /// @notice Set a new maximum liquidation discount\\n    /// @param newDiscount New maximum liquidation discount in 1e4 scale\\n    /// @dev If the discount is zero (the default), the liquidators will not be incentivized to liquidate unhealthy\\n    /// accounts\\n    function setMaxLiquidationDiscount(uint16 newDiscount) external;\\n\\n    /// @notice Set a new liquidation cool off time, which must elapse after successful account status check before\\n    /// account can be liquidated\\n    /// @param newCoolOffTime The new liquidation cool off time in seconds\\n    /// @dev Setting cool off time to zero allows liquidating the account in the same block as the last successful\\n    /// account status check\\n    function setLiquidationCoolOffTime(uint16 newCoolOffTime) external;\\n\\n    /// @notice Set a new interest rate model contract\\n    /// @param newModel The new IRM address\\n    /// @dev If the new model reverts, perhaps due to governor error, the vault will silently use a zero interest\\n    /// rate. Governor should make sure the new interest rates are computed as expected.\\n    function setInterestRateModel(address newModel) external;\\n\\n    /// @notice Set a new hook target and a new bitmap indicating which operations should call the hook target.\\n    /// Operations are defined in Constants.sol.\\n    /// @param newHookTarget The new hook target address. Use address(0) to simply disable hooked operations\\n    /// @param newHookedOps Bitmask with the new hooked operations\\n    /// @dev All operations are initially disabled in a newly created vault. The vault creator must set their\\n    /// own configuration to make the vault usable\\n    function setHookConfig(address newHookTarget, uint32 newHookedOps) external;\\n\\n    /// @notice Set new bitmap indicating which config flags should be enabled. Flags are defined in Constants.sol\\n    /// @param newConfigFlags Bitmask with the new config flags\\n    function setConfigFlags(uint32 newConfigFlags) external;\\n\\n    /// @notice Set new supply and borrow caps in AmountCap format\\n    /// @param supplyCap The new supply cap in AmountCap fromat\\n    /// @param borrowCap The new borrow cap in AmountCap fromat\\n    function setCaps(uint16 supplyCap, uint16 borrowCap) external;\\n\\n    /// @notice Set a new interest fee\\n    /// @param newFee The new interest fee\\n    function setInterestFee(uint16 newFee) external;\\n}\\n\\n/// @title IEVault\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice Interface of the EVault, an EVC enabled lending vault\\ninterface IEVault is\\n    IInitialize,\\n    IToken,\\n    IVault,\\n    IBorrowing,\\n    ILiquidation,\\n    IRiskManager,\\n    IBalanceForwarder,\\n    IGovernance\\n{\\n    /// @notice Fetch address of the `Initialize` module\\n    function MODULE_INITIALIZE() external view returns (address);\\n    /// @notice Fetch address of the `Token` module\\n    function MODULE_TOKEN() external view returns (address);\\n    /// @notice Fetch address of the `Vault` module\\n    function MODULE_VAULT() external view returns (address);\\n    /// @notice Fetch address of the `Borrowing` module\\n    function MODULE_BORROWING() external view returns (address);\\n    /// @notice Fetch address of the `Liquidation` module\\n    function MODULE_LIQUIDATION() external view returns (address);\\n    /// @notice Fetch address of the `RiskManager` module\\n    function MODULE_RISKMANAGER() external view returns (address);\\n    /// @notice Fetch address of the `BalanceForwarder` module\\n    function MODULE_BALANCE_FORWARDER() external view returns (address);\\n    /// @notice Fetch address of the `Governance` module\\n    function MODULE_GOVERNANCE() external view returns (address);\\n}\\n\"},\"lib/openzeppelin-contracts/contracts/interfaces/IERC1271.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1271.sol)\\n\\npragma solidity >=0.5.0;\\n\\n/**\\n * @dev Interface of the ERC-1271 standard signature validation method for\\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\n */\\ninterface IERC1271 {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param hash      Hash of the data to be signed\\n     * @param signature Signature byte array associated with `hash`\\n     */\\n    function isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4 magicValue);\\n}\\n\"},\"lib/openzeppelin-contracts/contracts/interfaces/IERC1363.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1363.sol)\\n\\npragma solidity >=0.6.2;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @title IERC1363\\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\\n *\\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\\n */\\ninterface IERC1363 is IERC20, IERC165 {\\n    /*\\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\\n     * 0xb0202a11 ===\\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\\n     */\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferAndCall(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @param data Additional data with no specified format, sent in call to `to`.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param from The address which you want to send tokens from.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param from The address which you want to send tokens from.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @param data Additional data with no specified format, sent in call to `to`.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function approveAndCall(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     * @param data Additional data with no specified format, sent in call to `spender`.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\\n}\\n\"},\"lib/openzeppelin-contracts/contracts/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC165.sol)\\n\\npragma solidity >=0.4.16;\\n\\nimport {IERC165} from \\\"../utils/introspection/IERC165.sol\\\";\\n\"},\"lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC20.sol)\\n\\npragma solidity >=0.4.16;\\n\\nimport {IERC20} from \\\"../token/ERC20/IERC20.sol\\\";\\n\"},\"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity >=0.4.16;\\n\\n/**\\n * @dev Interface of the ERC-20 standard as defined in the ERC.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"},\"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.5.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\nimport {IERC1363} from \\\"../../../interfaces/IERC1363.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    /**\\n     * @dev An operation with an ERC-20 token failed.\\n     */\\n    error SafeERC20FailedOperation(address token);\\n\\n    /**\\n     * @dev Indicates a failed `decreaseAllowance` request.\\n     */\\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        if (!_safeTransfer(token, to, value, true)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        if (!_safeTransferFrom(token, from, to, value, true)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\\n     */\\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\\n        return _safeTransfer(token, to, value, false);\\n    }\\n\\n    /**\\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\\n     */\\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\\n        return _safeTransferFrom(token, from, to, value, false);\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     *\\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \\\"client\\\"\\n     * smart contract uses ERC-7674 to set temporary allowances, then the \\\"client\\\" smart contract should avoid using\\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        forceApprove(token, spender, oldAllowance + value);\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\\n     * value, non-reverting calls are assumed to be successful.\\n     *\\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \\\"client\\\"\\n     * smart contract uses ERC-7674 to set temporary allowances, then the \\\"client\\\" smart contract should avoid using\\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\\n        unchecked {\\n            uint256 currentAllowance = token.allowance(address(this), spender);\\n            if (currentAllowance < requestedDecrease) {\\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\\n            }\\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     *\\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\\n     * only sets the \\\"standard\\\" allowance. Any temporary allowance will remain active, in addition to the value being\\n     * set here.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        if (!_safeApprove(token, spender, value, false)) {\\n            if (!_safeApprove(token, spender, 0, true)) revert SafeERC20FailedOperation(address(token));\\n            if (!_safeApprove(token, spender, value, true)) revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\\n     * code. This can be used to implement an {ERC721}-like safe transfer that relies on {ERC1363} checks when\\n     * targeting contracts.\\n     *\\n     * Reverts if the returned value is other than `true`.\\n     */\\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\\n        if (to.code.length == 0) {\\n            safeTransfer(token, to, value);\\n        } else if (!token.transferAndCall(to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that relies on {ERC1363} checks when\\n     * targeting contracts.\\n     *\\n     * Reverts if the returned value is other than `true`.\\n     */\\n    function transferFromAndCallRelaxed(\\n        IERC1363 token,\\n        address from,\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal {\\n        if (to.code.length == 0) {\\n            safeTransferFrom(token, from, to, value);\\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\\n     * targeting contracts.\\n     *\\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\\n     * Oppositely, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\\n     * once without retrying, and relies on the returned value to be true.\\n     *\\n     * Reverts if the returned value is other than `true`.\\n     */\\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\\n        if (to.code.length == 0) {\\n            forceApprove(token, to, value);\\n        } else if (!token.approveAndCall(to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity `token.transfer(to, value)` call, relaxing the requirement on the return value: the\\n     * return value is optional (but if data is returned, it must not be false).\\n     *\\n     * @param token The token targeted by the call.\\n     * @param to The recipient of the tokens\\n     * @param value The amount of token to transfer\\n     * @param bubble Behavior switch if the transfer call reverts: bubble the revert reason or return a false boolean.\\n     */\\n    function _safeTransfer(IERC20 token, address to, uint256 value, bool bubble) private returns (bool success) {\\n        bytes4 selector = IERC20.transfer.selector;\\n\\n        assembly (\\\"memory-safe\\\") {\\n            let fmp := mload(0x40)\\n            mstore(0x00, selector)\\n            mstore(0x04, and(to, shr(96, not(0))))\\n            mstore(0x24, value)\\n            success := call(gas(), token, 0, 0x00, 0x44, 0x00, 0x20)\\n            // if call success and return is true, all is good.\\n            // otherwise (not success or return is not true), we need to perform further checks\\n            if iszero(and(success, eq(mload(0x00), 1))) {\\n                // if the call was a failure and bubble is enabled, bubble the error\\n                if and(iszero(success), bubble) {\\n                    returndatacopy(fmp, 0x00, returndatasize())\\n                    revert(fmp, returndatasize())\\n                }\\n                // if the return value is not true, then the call is only successful if:\\n                // - the token address has code\\n                // - the returndata is empty\\n                success := and(success, and(iszero(returndatasize()), gt(extcodesize(token), 0)))\\n            }\\n            mstore(0x40, fmp)\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity `token.transferFrom(from, to, value)` call, relaxing the requirement on the return\\n     * value: the return value is optional (but if data is returned, it must not be false).\\n     *\\n     * @param token The token targeted by the call.\\n     * @param from The sender of the tokens\\n     * @param to The recipient of the tokens\\n     * @param value The amount of token to transfer\\n     * @param bubble Behavior switch if the transfer call reverts: bubble the revert reason or return a false boolean.\\n     */\\n    function _safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value,\\n        bool bubble\\n    ) private returns (bool success) {\\n        bytes4 selector = IERC20.transferFrom.selector;\\n\\n        assembly (\\\"memory-safe\\\") {\\n            let fmp := mload(0x40)\\n            mstore(0x00, selector)\\n            mstore(0x04, and(from, shr(96, not(0))))\\n            mstore(0x24, and(to, shr(96, not(0))))\\n            mstore(0x44, value)\\n            success := call(gas(), token, 0, 0x00, 0x64, 0x00, 0x20)\\n            // if call success and return is true, all is good.\\n            // otherwise (not success or return is not true), we need to perform further checks\\n            if iszero(and(success, eq(mload(0x00), 1))) {\\n                // if the call was a failure and bubble is enabled, bubble the error\\n                if and(iszero(success), bubble) {\\n                    returndatacopy(fmp, 0x00, returndatasize())\\n                    revert(fmp, returndatasize())\\n                }\\n                // if the return value is not true, then the call is only successful if:\\n                // - the token address has code\\n                // - the returndata is empty\\n                success := and(success, and(iszero(returndatasize()), gt(extcodesize(token), 0)))\\n            }\\n            mstore(0x40, fmp)\\n            mstore(0x60, 0)\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity `token.approve(spender, value)` call, relaxing the requirement on the return value:\\n     * the return value is optional (but if data is returned, it must not be false).\\n     *\\n     * @param token The token targeted by the call.\\n     * @param spender The spender of the tokens\\n     * @param value The amount of token to transfer\\n     * @param bubble Behavior switch if the transfer call reverts: bubble the revert reason or return a false boolean.\\n     */\\n    function _safeApprove(IERC20 token, address spender, uint256 value, bool bubble) private returns (bool success) {\\n        bytes4 selector = IERC20.approve.selector;\\n\\n        assembly (\\\"memory-safe\\\") {\\n            let fmp := mload(0x40)\\n            mstore(0x00, selector)\\n            mstore(0x04, and(spender, shr(96, not(0))))\\n            mstore(0x24, value)\\n            success := call(gas(), token, 0, 0x00, 0x44, 0x00, 0x20)\\n            // if call success and return is true, all is good.\\n            // otherwise (not success or return is not true), we need to perform further checks\\n            if iszero(and(success, eq(mload(0x00), 1))) {\\n                // if the call was a failure and bubble is enabled, bubble the error\\n                if and(iszero(success), bubble) {\\n                    returndatacopy(fmp, 0x00, returndatasize())\\n                    revert(fmp, returndatasize())\\n                }\\n                // if the return value is not true, then the call is only successful if:\\n                // - the token address has code\\n                // - the returndata is empty\\n                success := and(success, and(iszero(returndatasize()), gt(extcodesize(token), 0)))\\n            }\\n            mstore(0x40, fmp)\\n        }\\n    }\\n}\\n\"},\"lib/openzeppelin-contracts/contracts/utils/Create2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.5.0) (utils/Create2.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Errors} from \\\"./Errors.sol\\\";\\nimport {LowLevelCall} from \\\"./LowLevelCall.sol\\\";\\n\\n/**\\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\\n * `CREATE2` can be used to compute in advance the address where a smart\\n * contract will be deployed, which allows for interesting new mechanisms known\\n * as 'counterfactual interactions'.\\n *\\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\\n * information.\\n */\\nlibrary Create2 {\\n    /**\\n     * @dev There's no code to deploy.\\n     */\\n    error Create2EmptyBytecode();\\n\\n    /**\\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\\n     * will be deployed can be known in advance via {computeAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already.\\n     * - the factory must have a balance of at least `amount`.\\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\\n     */\\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address addr) {\\n        if (address(this).balance < amount) {\\n            revert Errors.InsufficientBalance(address(this).balance, amount);\\n        }\\n        if (bytecode.length == 0) {\\n            revert Create2EmptyBytecode();\\n        }\\n        assembly (\\\"memory-safe\\\") {\\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\\n        }\\n        if (addr == address(0)) {\\n            if (LowLevelCall.returnDataSize() == 0) {\\n                revert Errors.FailedDeployment();\\n            } else {\\n                LowLevelCall.bubbleRevert();\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\\n     * `bytecodeHash` or `salt` will result in a new destination address.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\\n        return computeAddress(salt, bytecodeHash, address(this));\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address addr) {\\n        assembly (\\\"memory-safe\\\") {\\n            let ptr := mload(0x40) // Get free memory pointer\\n\\n            // |                     |  ptr ...   ptr + 0x0B (start) ...   ptr + 0x20 ...   ptr + 0x40 ...   |\\n            // |---------------------|---------------------------------------------------------------------------|\\n            // | bytecodeHash        |                                                        CCCCCCCCCCCCC...CC |\\n            // | salt                |                                      BBBBBBBBBBBBB...BB                   |\\n            // | deployer            | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\\n            // | 0xFF                |            FF                                                             |\\n            // |---------------------|---------------------------------------------------------------------------|\\n            // | memory              | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\\n            // | keccak(start, 0x55) |             |\\n\\n            mstore(add(ptr, 0x40), bytecodeHash)\\n            mstore(add(ptr, 0x20), salt)\\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\\n            mstore8(start, 0xff)\\n            addr := and(keccak256(start, 0x55), 0xffffffffffffffffffffffffffffffffffffffff)\\n        }\\n    }\\n}\\n\"},\"lib/openzeppelin-contracts/contracts/utils/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of common custom errors used in multiple contracts\\n *\\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\\n * It is recommended to avoid relying on the error API for critical functionality.\\n *\\n * _Available since v5.1._\\n */\\nlibrary Errors {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error InsufficientBalance(uint256 balance, uint256 needed);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedCall();\\n\\n    /**\\n     * @dev The deployment failed.\\n     */\\n    error FailedDeployment();\\n\\n    /**\\n     * @dev A necessary precompile is missing.\\n     */\\n    error MissingPrecompile(address);\\n}\\n\"},\"lib/openzeppelin-contracts/contracts/utils/LowLevelCall.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.5.0) (utils/LowLevelCall.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library of low level call functions that implement different calling strategies to deal with the return data.\\n *\\n * WARNING: Using this library requires an advanced understanding of Solidity and how the EVM works. It is recommended\\n * to use the {Address} library instead.\\n */\\nlibrary LowLevelCall {\\n    /// @dev Performs a Solidity function call using a low level `call` and ignoring the return data.\\n    function callNoReturn(address target, bytes memory data) internal returns (bool success) {\\n        return callNoReturn(target, 0, data);\\n    }\\n\\n    /// @dev Same as {callNoReturn}, but allows to specify the value to be sent in the call.\\n    function callNoReturn(address target, uint256 value, bytes memory data) internal returns (bool success) {\\n        assembly (\\\"memory-safe\\\") {\\n            success := call(gas(), target, value, add(data, 0x20), mload(data), 0x00, 0x00)\\n        }\\n    }\\n\\n    /// @dev Performs a Solidity function call using a low level `call` and returns the first 64 bytes of the result\\n    /// in the scratch space of memory. Useful for functions that return a tuple of single-word values.\\n    ///\\n    /// WARNING: Do not assume that the results are zero if `success` is false. Memory can be already allocated\\n    /// and this function doesn't zero it out.\\n    function callReturn64Bytes(\\n        address target,\\n        bytes memory data\\n    ) internal returns (bool success, bytes32 result1, bytes32 result2) {\\n        return callReturn64Bytes(target, 0, data);\\n    }\\n\\n    /// @dev Same as {callReturnBytes32Pair}, but allows to specify the value to be sent in the call.\\n    function callReturn64Bytes(\\n        address target,\\n        uint256 value,\\n        bytes memory data\\n    ) internal returns (bool success, bytes32 result1, bytes32 result2) {\\n        assembly (\\\"memory-safe\\\") {\\n            success := call(gas(), target, value, add(data, 0x20), mload(data), 0x00, 0x40)\\n            result1 := mload(0x00)\\n            result2 := mload(0x20)\\n        }\\n    }\\n\\n    /// @dev Performs a Solidity function call using a low level `staticcall` and ignoring the return data.\\n    function staticcallNoReturn(address target, bytes memory data) internal view returns (bool success) {\\n        assembly (\\\"memory-safe\\\") {\\n            success := staticcall(gas(), target, add(data, 0x20), mload(data), 0x00, 0x00)\\n        }\\n    }\\n\\n    /// @dev Performs a Solidity function call using a low level `staticcall` and returns the first 64 bytes of the result\\n    /// in the scratch space of memory. Useful for functions that return a tuple of single-word values.\\n    ///\\n    /// WARNING: Do not assume that the results are zero if `success` is false. Memory can be already allocated\\n    /// and this function doesn't zero it out.\\n    function staticcallReturn64Bytes(\\n        address target,\\n        bytes memory data\\n    ) internal view returns (bool success, bytes32 result1, bytes32 result2) {\\n        assembly (\\\"memory-safe\\\") {\\n            success := staticcall(gas(), target, add(data, 0x20), mload(data), 0x00, 0x40)\\n            result1 := mload(0x00)\\n            result2 := mload(0x20)\\n        }\\n    }\\n\\n    /// @dev Performs a Solidity function call using a low level `delegatecall` and ignoring the return data.\\n    function delegatecallNoReturn(address target, bytes memory data) internal returns (bool success) {\\n        assembly (\\\"memory-safe\\\") {\\n            success := delegatecall(gas(), target, add(data, 0x20), mload(data), 0x00, 0x00)\\n        }\\n    }\\n\\n    /// @dev Performs a Solidity function call using a low level `delegatecall` and returns the first 64 bytes of the result\\n    /// in the scratch space of memory. Useful for functions that return a tuple of single-word values.\\n    ///\\n    /// WARNING: Do not assume that the results are zero if `success` is false. Memory can be already allocated\\n    /// and this function doesn't zero it out.\\n    function delegatecallReturn64Bytes(\\n        address target,\\n        bytes memory data\\n    ) internal returns (bool success, bytes32 result1, bytes32 result2) {\\n        assembly (\\\"memory-safe\\\") {\\n            success := delegatecall(gas(), target, add(data, 0x20), mload(data), 0x00, 0x40)\\n            result1 := mload(0x00)\\n            result2 := mload(0x20)\\n        }\\n    }\\n\\n    /// @dev Returns the size of the return data buffer.\\n    function returnDataSize() internal pure returns (uint256 size) {\\n        assembly (\\\"memory-safe\\\") {\\n            size := returndatasize()\\n        }\\n    }\\n\\n    /// @dev Returns a buffer containing the return data from the last call.\\n    function returnData() internal pure returns (bytes memory result) {\\n        assembly (\\\"memory-safe\\\") {\\n            result := mload(0x40)\\n            mstore(result, returndatasize())\\n            returndatacopy(add(result, 0x20), 0x00, returndatasize())\\n            mstore(0x40, add(result, add(0x20, returndatasize())))\\n        }\\n    }\\n\\n    /// @dev Revert with the return data from the last call.\\n    function bubbleRevert() internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            let fmp := mload(0x40)\\n            returndatacopy(fmp, 0x00, returndatasize())\\n            revert(fmp, returndatasize())\\n        }\\n    }\\n\\n    function bubbleRevert(bytes memory returndata) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            revert(add(returndata, 0x20), mload(returndata))\\n        }\\n    }\\n}\\n\"},\"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity >=0.4.16;\\n\\n/**\\n * @dev Interface of the ERC-165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"},\"src/CowEvcBaseWrapper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity ^0.8;\\n\\nimport {IEVC} from \\\"evc/EthereumVaultConnector.sol\\\";\\n\\nimport {CowWrapper, ICowSettlement} from \\\"./CowWrapper.sol\\\";\\nimport {PreApprovedHashes} from \\\"./PreApprovedHashes.sol\\\";\\n\\n/// @title CowEvcBaseWrapper\\n/// @notice Shared components for implementing Euler wrappers.\\nabstract contract CowEvcBaseWrapper is CowWrapper, PreApprovedHashes {\\n    /// @dev location in memory of the parameters describing the wrapper implementation.\\n    type ParamsLocation is bytes32;\\n\\n    IEVC public immutable EVC;\\n\\n    /// @dev The EIP-712 domain type hash used for computing the domain\\n    /// separator.\\n    bytes32 public constant DOMAIN_TYPE_HASH =\\n        keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\");\\n\\n    /// @dev The marker value for a sell order for computing the order struct\\n    /// hash. This allows the EIP-712 compatible wallets to display a\\n    /// descriptive string for the order kind (instead of 0 or 1).\\n    bytes32 internal constant KIND_SELL = keccak256(\\\"sell\\\");\\n\\n    /// @dev The OrderKind marker value for a buy order for computing the order\\n    /// struct hash.\\n    bytes32 internal constant KIND_BUY = keccak256(\\\"buy\\\");\\n\\n    /// @dev Used by EIP-712 signing to prevent signatures from being replayed\\n    bytes32 public immutable DOMAIN_SEPARATOR;\\n\\n    /// @dev The EVC nonce namespace to use when calling `EVC.permit` to authorize this contract.\\n    /// See: https://evc.wtf/docs/concepts/internals/permit/#nonce-namespaces\\n    uint256 public immutable NONCE_NAMESPACE;\\n\\n    /// @dev The length of the parameters consumed by this wrapper. Used in order to know how much data to read after the ParamsLocation for the hash.\\n    /// Ideally this should be computed by creating the parameters struct and then `abi.encode().length` to ensure its always the correct size.\\n    uint256 internal immutable PARAMS_SIZE;\\n\\n    /// @dev The EIP-712 type hash of the parameters structure used by this wrapper.\\n    bytes32 public immutable PARAMS_TYPE_HASH;\\n\\n    /// @dev How long to make the `items` array without calculating it. Determines the maximum number of EVC operations that can be batched.\\n    /// This value depends on the each concrete wrapper implementation. It should include the settlement and any operations before and after it.\\n    uint256 internal immutable MAX_BATCH_OPERATIONS;\\n\\n    /// @dev Indicates that the current operation cannot be completed with the given msgSender\\n    error Unauthorized(address msgSender);\\n\\n    /// @dev Indicates that the pre-approved hash is no longer able to be executed because the block timestamp is too old\\n    error OperationDeadlineExceeded(uint256 validToTimestamp, uint256 currentTimestamp);\\n\\n    /// @dev Indicates that a user attempted to interact with an account that is not their own\\n    error SubaccountMustBeControlledByOwner(address subaccount, address owner);\\n\\n    /// @dev Indicates that the EVC called `evcInternalSettle` in an invalid way\\n    error InvalidCallback();\\n\\n    /// @dev Indicates that neither `_encodeBatchItemsBefore` nor `_encodeBatchItemsAfter` requested permission, meaning the provided permit signature is unused.\\n    error UnusedPermitSignature();\\n\\n    /// @dev Used to ensure that the EVC is calling back this contract with the correct data\\n    bytes32 internal transient expectedEvcInternalSettleCallHash;\\n\\n    constructor(address _evc, ICowSettlement _settlement, bytes32 _domainName, bytes32 _domainVersion)\\n        CowWrapper(_settlement)\\n    {\\n        require(_evc.code.length > 0, \\\"EVC address is invalid\\\");\\n        EVC = IEVC(_evc);\\n        NONCE_NAMESPACE = uint256(uint160(address(this)));\\n        DOMAIN_SEPARATOR =\\n            keccak256(abi.encode(DOMAIN_TYPE_HASH, _domainName, _domainVersion, block.chainid, address(this)));\\n    }\\n\\n    /// @notice Encode batch items to execute before the settlement\\n    /// @dev By default we return the default value (empty array, false).\\n    /// At least one between this function and `_encodeBatchItemsAfter` should need permission (i.e., use the permit signature) for the permit flow to be secure.\\n    /// @param location The memory storage position where the parameters needed to encode the batch items have been saved\\n    /// @return items Array of batch items to execute\\n    /// @return needsPermission Whether these items require user signature or prior authorization as an operator\\n    function _encodeBatchItemsBefore(ParamsLocation location)\\n        internal\\n        view\\n        virtual\\n        returns (IEVC.BatchItem[] memory items, bool needsPermission)\\n    {}\\n\\n    /// @notice Encode batch items to execute after the settlement\\n    /// @dev By default we return the default value (empty array, false).\\n    /// At least one between this function and `_encodeBatchItemsBefore` should need permission (i.e., use the permit signature) for the permit flow to be secure.\\n    /// @param location The memory storage position where the parameters needed to encode the batch items have been saved\\n    /// @return items Array of batch items to execute\\n    /// @return needsPermission Whether these items require user signature or prior authorization as an operator\\n    function _encodeBatchItemsAfter(ParamsLocation location)\\n        internal\\n        view\\n        virtual\\n        returns (IEVC.BatchItem[] memory items, bool needsPermission)\\n    {}\\n\\n    /// @dev This function makes strong assumptions on the memory layout of the struct in memory.\\n    /// It assumes:\\n    ///  - The struct itself doesn't contain any dynamic-length types.\\n    ///  - The struct is encoded in memory with zero padding.\\n    /// @param params The memory location of the struct data\\n    /// @return digest The EIP-712 compliant digest\\n    function _getApprovalHash(ParamsLocation params) internal view returns (bytes32 digest) {\\n        bytes32 structHash;\\n        bytes32 separator = DOMAIN_SEPARATOR;\\n        bytes32 typeHash = PARAMS_TYPE_HASH;\\n        uint256 paramsSize = PARAMS_SIZE;\\n        assembly {\\n            // Build structHash = keccak256(typeHash || encodeData(params))\\n            let wordBeforeParamPtr := sub(params, 0x20)\\n            // Subtraction overflow causes the next line to revert with out of gas if params isn't allocated\\n            let wordBeforeParam := mload(wordBeforeParamPtr)\\n            mstore(wordBeforeParamPtr, typeHash)\\n            structHash := keccak256(wordBeforeParamPtr, add(0x20, paramsSize))\\n            // Restore original content\\n            mstore(wordBeforeParamPtr, wordBeforeParam)\\n\\n            // Build digest = keccak256(\\\"\\\\x19\\\\x01\\\" || domainSeparator || structHash)\\n            let ptr := mload(0x40)\\n            mstore(ptr, \\\"\\\\x19\\\\x01\\\")\\n            mstore(add(ptr, 0x02), separator)\\n            mstore(add(ptr, 0x22), structHash)\\n            digest := keccak256(ptr, 0x42)\\n        }\\n    }\\n\\n    /// @notice Generates the permit data that would be used for the given EVC batch items (presumably generated from params)\\n    function _encodePermitData(IEVC.BatchItem[] memory items, ParamsLocation params)\\n        internal\\n        view\\n        returns (bytes memory)\\n    {\\n        // The abi.encodeCall() part consists of the batch call that we want to execute. The additional data tacked on the end is to ensure\\n        // the provided parameters are all validated against the user signature, even if `items` doesn't completely use the parameters in effect.\\n        return abi.encodePacked(abi.encodeCall(IEVC.batch, items), _getApprovalHash(params));\\n    }\\n\\n    /// @notice This function is called by EVC and continues the CoW settlement process inside an EVC batch while including any necessary security check.\\n    function evcInternalSettle(\\n        bytes calldata settleData,\\n        bytes calldata wrapperData,\\n        bytes calldata remainingWrapperData\\n    ) external {\\n        require(msg.sender == address(EVC), Unauthorized(msg.sender));\\n        require(expectedEvcInternalSettleCallHash == keccak256(msg.data), InvalidCallback());\\n        expectedEvcInternalSettleCallHash = bytes32(0);\\n\\n        _evcInternalSettle(settleData, wrapperData, remainingWrapperData);\\n    }\\n\\n    function _makeInternalSettleCallbackData(\\n        bytes calldata settleData,\\n        bytes calldata wrapperData,\\n        bytes calldata remainingWrapperData\\n    ) internal pure returns (bytes memory) {\\n        return abi.encodeCall(CowEvcBaseWrapper.evcInternalSettle, (settleData, wrapperData, remainingWrapperData));\\n    }\\n\\n    function _invokeEvc(\\n        bytes memory evcInternalSettleCallback,\\n        ParamsLocation param,\\n        bytes memory signature,\\n        address owner,\\n        address account,\\n        uint256 deadline\\n    ) internal {\\n        // Subaccounts in the EVC can be any account that shares the highest 19 bits as the owner.\\n        // Here we verify that the subaccount address has been specified is, in fact, a subaccount of the owner.\\n        // Otherwise its concievably possible that a transfer could happen between an owner with an unauthorized subaccount.\\n        require(bytes19(bytes20(owner)) == bytes19(bytes20(account)), SubaccountMustBeControlledByOwner(account, owner));\\n\\n        // There are 2 ways that this contract can validate user operations: 1) the user pre-approves a hash with an on-chain call and grants this contract ability to operate on the user's behalf, or 2) they issue a signature which can be used to call EVC.permit()\\n        // The choice of the flow is based on whether `signature` has length zero. If so, then we use the hash approval flow (1).\\n        // Otherwise, the signature is assumed to be one for EVC.permit (2).\\n        // The permit signature is verified against the permit generated by `_encodePermitData`; the parameters are validated because they are unequivocally encoded in the signed permit.\\n        if (signature.length == 0) {\\n            _consumePreApprovedHash(owner, _getApprovalHash(param));\\n            // The deadline is checked by `EVC.permit()`, so we only check it here if we are using a pre-approved hash (aka, no signature) which would bypass that call\\n            require(deadline >= block.timestamp, OperationDeadlineExceeded(deadline, block.timestamp));\\n        }\\n\\n        // Build the EVC batch items for swapping collateral\\n        IEVC.BatchItem[] memory items = new IEVC.BatchItem[](MAX_BATCH_OPERATIONS);\\n\\n        uint256 itemIndex = 0;\\n\\n        {\\n            // add any EVC actions that have to be performed before\\n            IEVC.BatchItem[] memory partialItems;\\n            bool needsPermission;\\n            bool permissionRequested = false;\\n\\n            (partialItems, needsPermission) = _encodeBatchItemsBefore(param);\\n            permissionRequested = permissionRequested || needsPermission;\\n            itemIndex = _addEvcBatchItems(\\n                items, partialItems, itemIndex, owner, deadline, needsPermission ? signature : new bytes(0), param\\n            );\\n\\n            // add the EVC callback to this (which calls settlement)\\n            expectedEvcInternalSettleCallHash = keccak256(evcInternalSettleCallback);\\n            items[itemIndex++] = IEVC.BatchItem({\\n                onBehalfOfAccount: address(this),\\n                targetContract: address(this),\\n                value: 0,\\n                data: evcInternalSettleCallback\\n            });\\n\\n            // add the EVC actions that have to be performed after\\n            (partialItems, needsPermission) = _encodeBatchItemsAfter(param);\\n            permissionRequested = permissionRequested || needsPermission;\\n            itemIndex = _addEvcBatchItems(\\n                items, partialItems, itemIndex, owner, deadline, needsPermission ? signature : new bytes(0), param\\n            );\\n\\n            require(permissionRequested, UnusedPermitSignature());\\n        }\\n\\n        // shorten the length of the generated array to its actual length\\n        // We assume as an a invariant that the code above will not generate a `itemIndex` greater than `MAX_BATCH_OPERATIONS` at this point\\n        // because we always add an item to the items array when we increment `itemIndex`, and if the itemIndex goes out of bounds,\\n        // solidity will revert\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(items, itemIndex)\\n        }\\n\\n        // 3. Account status check (automatically done by EVC at end of batch)\\n        // For more info, see: https://evc.wtf/docs/concepts/internals/account-status-checks\\n        // No explicit item needed - EVC handles this\\n\\n        // Execute all items in a single batch\\n        EVC.batch(items);\\n\\n        // The pre approved hash flow needs the user to set this contract as an operator for both the owner address itself and the subaccount.\\n        // The EVC treats owner and subaccount operator authorizations separately, so we need to relinquish them separately\\n        if (signature.length == 0) {\\n            // This function returns both account and subaccount operator authorizations as a bitmask.\\n            // So we can do one call to find out what accounts are authorized, and then remove them as needed.\\n            uint256 mask = EVC.getOperator(bytes19(bytes20(owner)), address(this));\\n\\n            // check subaccount control\\n            // despite the lint, the shift is correct. This is the same way\\n            // the calculation is done in the EthereumVaultConnector contract.\\n            // https://github.com/euler-xyz/ethereum-vault-connector/blob/v1.0.1/src/EthereumVaultConnector.sol#L387\\n            /// forge-lint: disable-next-line(incorrect-shift)\\n            if ((mask & (1 << (uint160(owner) ^ uint160(account)))) > 0) {\\n                EVC.setAccountOperator(account, address(this), false);\\n            }\\n\\n            // check owner account control. If the owner is the subaccount, there is no need to set the operator again.\\n            if (owner != account && mask & 1 > 0) {\\n                EVC.setAccountOperator(owner, address(this), false);\\n            }\\n        }\\n    }\\n\\n    /// @dev Helper function to add IEVC.BatchItem to the EVC.batch call with any authorization that may be required.\\n    /// Depending on whether a signature is provided, this function will either copy `addItems` into `fullItems` at the given position,\\n    /// or `addItems` will be condensed into a single `EVC.permit` call and then added to the batch as a single item.\\n    /// @param fullItems The items which will ultimately be executed by EVC.batch\\n    /// @param addItems The items which need to be added to fullItems with appropriate authorization wrapping as needed\\n    /// @param itemIndex The index in `fullItems` starting from which `addItems` should be written\\n    /// @param owner The owner who is granting permission to execute the operations. Needed to construct the `EVC.permit`\\n    /// @param deadline The time at which the permit signature would expire. needed to construct the `EVC.permit`\\n    /// @param signature The signature used to validate the EVC.permit. If this is set to `new bytes(0)`, no permit will be used, and the items will be copied directly instead.\\n    /// @param param The input parameters for this trade. Needed to construct the `EVC.permit`, as the params data hash is appended to the end of the batch to ensure the signed `EVC.permit` can't be used with parameters that the user didn't sign.\\n    /// @return The index immediately after the last item written to `fullItems`\\n    function _addEvcBatchItems(\\n        IEVC.BatchItem[] memory fullItems,\\n        IEVC.BatchItem[] memory addItems,\\n        uint256 itemIndex,\\n        address owner,\\n        uint256 deadline,\\n        bytes memory signature,\\n        ParamsLocation param\\n    ) internal view returns (uint256) {\\n        // There are two ways this contract can be executed: either the user approves this contract as\\n        // an operator and supplies a pre-approved hash for the operation to take, or they submit a permit hash\\n        // for this specific instance. If its the permit hash route, here we call `permit` instead of `batch` raw so that the EVC can authorize it.\\n        // If there is an issue with the signature, the EVC will revert the batch call, which will bubble up through this contract to revert the entire wrappedSettle call.\\n        if (signature.length > 0) {\\n            fullItems[itemIndex++] = IEVC.BatchItem({\\n                onBehalfOfAccount: address(0),\\n                targetContract: address(EVC),\\n                value: 0,\\n                data: abi.encodeCall(\\n                    IEVC.permit,\\n                    (\\n                        owner,\\n                        address(this),\\n                        uint256(NONCE_NAMESPACE),\\n                        EVC.getNonce(bytes19(bytes20(owner)), NONCE_NAMESPACE),\\n                        deadline,\\n                        0, // value field (no ETH transferred to the EVC)\\n                        _encodePermitData(addItems, param),\\n                        signature\\n                    )\\n                )\\n            });\\n        } else {\\n            // copy the operations to execute. this contract can operate on behalf of the user directly\\n            for (uint256 i; i < addItems.length; i++) {\\n                fullItems[itemIndex + i] = addItems[i];\\n            }\\n\\n            itemIndex += addItems.length;\\n        }\\n\\n        return itemIndex;\\n    }\\n\\n    function _evcInternalSettle(\\n        bytes calldata settleData,\\n        bytes calldata wrapperData,\\n        bytes calldata remainingWrapperData\\n    ) internal virtual;\\n}\\n\"},\"src/CowEvcClosePositionWrapper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity ^0.8;\\n\\nimport {IEVC} from \\\"evc/EthereumVaultConnector.sol\\\";\\n\\nimport {ICowSettlement, CowWrapper} from \\\"./CowWrapper.sol\\\";\\nimport {IERC4626, IBorrowing} from \\\"euler-vault-kit/src/EVault/IEVault.sol\\\";\\nimport {SafeERC20, IERC20} from \\\"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {CowEvcBaseWrapper} from \\\"./CowEvcBaseWrapper.sol\\\";\\nimport {InboxFactory} from \\\"./InboxFactory.sol\\\";\\nimport {Inbox} from \\\"./Inbox.sol\\\";\\n\\n/// @title CowEvcClosePositionWrapper\\n/// @notice A specialized wrapper for closing leveraged positions with EVC\\n/// @dev This wrapper hardcodes the EVC operations needed to close a position:\\n///      1. Transfer the required collateral from the subaccount to the owner within the EVC batch so that the settlement contract can access (if required)\\n///      2. Execute settlement to acquire repayment assets\\n///      3. Repay debt and return remaining assets to the subaccount\\n/// @dev The settle call by this order should be performing the necessary swap\\n/// from collateralVault -> IERC20(borrowVault.asset()). The recipient of the\\n/// swap should be the account returned by `getInbox(address owner, address subaccount)`. The Inbox is used to temporarily hold the swapped hold funds while the transaction is in flight.\\n/// Following this, the Inbox will repay the loan after the settlement returns.\\n/// Due to the potential side effects of multiple orders executing in a single settlement, do not attempt to execute a new close position on the same subaccount until it either expires or is settled.\\n/// If the position will be fully closed, the CoW order should be of type GPv2Order.KIND_BUY to prevent excess repay asset from being sent to the contract, leaving excess dust in the user.\\n/// Leave a small buffer for interest accumulation, and any dust on the buy side will be returned to the owner's wallet.\\ncontract CowEvcClosePositionWrapper is CowEvcBaseWrapper, InboxFactory {\\n    using SafeERC20 for IERC20;\\n\\n    address immutable VAULT_RELAYER;\\n\\n    error NoSwapOutput(address inboxForSwap);\\n    error InsufficientDebt(uint256 expectedMinDebt, uint256 actualDebt);\\n    error UnexpectedRepayResult(uint256 expectedRepayAmount, uint256 actualRepaidAmount);\\n\\n    /// @dev The EIP-712 domain name used for computing the domain separator.\\n    bytes32 constant DOMAIN_NAME = keccak256(\\\"CowEvcClosePositionWrapper\\\");\\n\\n    /// @dev The EIP-712 domain version used for computing the domain separator.\\n    bytes32 constant DOMAIN_VERSION = keccak256(\\\"1\\\");\\n\\n    /// @dev A descriptive label for this contract, as required by CowWrapper\\n    string public override name = \\\"Euler EVC - Close Position\\\";\\n\\n    /// @dev Emitted when a position is closed or reduced in size via this wrapper\\n    /// @param owner The owner of the account that was closed\\n    /// @param account The subaccount that was closed\\n    /// @param borrowVault The vault of the borrowed asset\\n    /// @param collateralVault The collateral asset used to repay\\n    /// @param collateralAmount The amount of collateral that was used to repay the debt\\n    /// @param repaidAmount The actual amount of debt repaid\\n    /// @param leftoverAmount The amount of borrow token (dust) left over after repaying debt, sent back to the owner\\n    event CowEvcPositionClosed(\\n        address indexed owner,\\n        address account,\\n        address indexed borrowVault,\\n        address indexed collateralVault,\\n        uint256 collateralAmount,\\n        uint256 repaidAmount,\\n        uint256 leftoverAmount\\n    );\\n\\n    constructor(address _evc, ICowSettlement _settlement)\\n        CowEvcBaseWrapper(_evc, _settlement, DOMAIN_NAME, DOMAIN_VERSION)\\n        InboxFactory(address(_settlement))\\n    {\\n        PARAMS_SIZE =\\n        abi.encode(\\n            ClosePositionParams({\\n                owner: address(0),\\n                account: address(0),\\n                deadline: 0,\\n                borrowVault: address(0),\\n                collateralVault: address(0),\\n                collateralAmount: 0\\n            })\\n        )\\n        .length;\\n\\n        MAX_BATCH_OPERATIONS = 2;\\n\\n        PARAMS_TYPE_HASH = keccak256(\\n            \\\"ClosePositionParams(address owner,address account,uint256 deadline,address borrowVault,address collateralVault,uint256 collateralAmount)\\\"\\n        );\\n\\n        VAULT_RELAYER = SETTLEMENT.vaultRelayer();\\n    }\\n\\n    /// @notice The information necessary to close a debt position against an euler vault by repaying debt and returning collateral\\n    /// @dev This structure is used, combined with domain separator, to indicate a pre-approved hash.\\n    /// the `deadline` is used for deduplication checking, so be careful to ensure this value is unique.\\n    struct ClosePositionParams {\\n        /// @dev The ethereum address that has permission to operate upon the account\\n        address owner;\\n\\n        /// @dev The subaccount to close the position on. Learn more about Euler subaccounts https://evc.wtf/docs/concepts/internals/sub-accounts\\n        address account;\\n\\n        /// @dev A date by which this operation must be completed. The CoW order `validTo` should ideally be the same as this value.\\n        uint256 deadline;\\n\\n        /// @dev The Euler vault from which debt was borrowed. The CoW order should have `buyToken` as `borrowVault.asset()`\\n        address borrowVault;\\n\\n        /// @dev The Euler vault used as collateral. The CoW order should have `sellToken` as this asset.\\n        address collateralVault;\\n\\n        /// @dev The amount of collateral to use for the repayment. This effectively determines how much collateral will be sent from the account at the beginning of the operation.\\n        /// Any unused amount for the CoW swap will be returned to the account. In all cases, this should be the same as `sellAmount` in the CoW order.\\n        uint256 collateralAmount;\\n    }\\n\\n    /// @notice Decode the wrapper data into ClosePositionParams and signature\\n    /// @param wrapperData The wrapper data excluding length provided to the `wrappedSettle` call `chainedWrapperData`\\n    /// @return params The decoded ClosePositionParams\\n    /// @return signature The signature over the EVC permit data\\n    function _parseClosePositionParams(bytes calldata wrapperData)\\n        internal\\n        pure\\n        returns (ClosePositionParams memory params, bytes memory signature)\\n    {\\n        (params, signature) = abi.decode(wrapperData, (ClosePositionParams, bytes));\\n    }\\n\\n    /// @notice Helper function to compute the hash that would need to be approved via `setPreApprovedHash` for the given `ClosePositionParams`\\n    /// @param params The ClosePositionParams to hash\\n    /// @return The hash of the signed calldata for these params\\n    function getApprovalHash(ClosePositionParams memory params) external view returns (bytes32) {\\n        return _getApprovalHash(memoryLocation(params));\\n    }\\n\\n    /// @inheritdoc CowWrapper\\n    function validateWrapperData(bytes calldata wrapperData) external pure override {\\n        // Validate by attempting to parse the wrapper data\\n        // Will revert if the data is malformed\\n        _parseClosePositionParams(wrapperData);\\n    }\\n\\n    /// @notice Called by an offchain process to determine what data should be signed for the permit flow.\\n    /// This signature should be encoded with the wrapper data in `wrappedSettle`.\\n    /// @param params The parameters object provided as input to the wrapper\\n    /// @return The `EVC` call that would be submitted to `EVC.permit`. This would need to be signed as documented https://evc.wtf/docs/concepts/internals/permit.\\n    function encodePermitData(ClosePositionParams memory params) external view returns (bytes memory) {\\n        (IEVC.BatchItem[] memory items,) = _encodeBatchItemsBefore(memoryLocation(params));\\n        return _encodePermitData(items, memoryLocation(params));\\n    }\\n\\n    /// @inheritdoc CowEvcBaseWrapper\\n    function _encodeBatchItemsBefore(ParamsLocation paramsLocation)\\n        internal\\n        view\\n        override\\n        returns (IEVC.BatchItem[] memory items, bool needsPermission)\\n    {\\n        ClosePositionParams memory params = paramsFromMemory(paramsLocation);\\n        items = new IEVC.BatchItem[](MAX_BATCH_OPERATIONS - 1);\\n\\n        (address inboxAddress,,) = _getInboxAddress(params.owner, params.account);\\n\\n        // For the permissioned operation, transfer collateral directly to the Inbox for this user\\n        items[0] = IEVC.BatchItem({\\n            onBehalfOfAccount: params.account,\\n            targetContract: params.collateralVault,\\n            value: 0,\\n            data: abi.encodeCall(IERC20.transfer, (inboxAddress, params.collateralAmount))\\n        });\\n\\n        needsPermission = true;\\n    }\\n\\n    /// @inheritdoc CowWrapper\\n    function _wrap(bytes calldata settleData, bytes calldata wrapperData, bytes calldata remainingWrapperData)\\n        internal\\n        override\\n    {\\n        // Decode wrapper data into ClosePositionParams\\n        (ClosePositionParams memory params, bytes memory signature) = _parseClosePositionParams(wrapperData);\\n\\n        _invokeEvc(\\n            _makeInternalSettleCallbackData(settleData, wrapperData, remainingWrapperData),\\n            memoryLocation(params),\\n            signature,\\n            params.owner,\\n            params.account,\\n            params.deadline\\n        );\\n    }\\n\\n    /// @inheritdoc CowEvcBaseWrapper\\n    function _evcInternalSettle(\\n        bytes calldata settleData,\\n        bytes calldata wrapperData,\\n        bytes calldata remainingWrapperData\\n    ) internal override {\\n        (ClosePositionParams memory params,) = _parseClosePositionParams(wrapperData);\\n        IERC20 borrowAsset = IERC20(IERC4626(params.borrowVault).asset());\\n        uint256 debtAmount = IBorrowing(params.borrowVault).debtOf(params.account);\\n\\n        Inbox inbox = _getInbox(params.owner, params.account);\\n        inbox.callApprove(params.collateralVault, VAULT_RELAYER, type(uint256).max);\\n\\n        // Use CowWrapper's _internalSettle to call the settlement contract\\n        // wrapperData is empty since we've already processed it in _wrap\\n        _next(settleData, remainingWrapperData);\\n\\n        // what is the maximum amount of debt that can\\n        // be repaid from the owner account?\\n        uint256 swapSourceBalance = IERC20(params.collateralVault).balanceOf(address(inbox));\\n        uint256 swapResultBalance = borrowAsset.balanceOf(address(inbox));\\n\\n        if (swapResultBalance == 0) {\\n            revert NoSwapOutput(address(inbox));\\n        }\\n\\n        // send any source collateral that remains after the swap back to the user's account\\n        if (swapSourceBalance > 0) {\\n            inbox.callTransfer(params.collateralVault, params.account, swapSourceBalance);\\n        }\\n\\n        // the amount we will *actually* repay is the same as however much we get from swapping\\n        uint256 repayAmount = swapResultBalance;\\n\\n        // we can't repay more than the available debt amount\\n        if (repayAmount > debtAmount) {\\n            // There will be leftover funds in the contract after repaying. Lets send that to the owner's account\\n            inbox.callTransfer(address(borrowAsset), params.owner, repayAmount - debtAmount);\\n\\n            repayAmount = debtAmount;\\n        }\\n\\n        // repay what was requested on the vault\\n        uint256 repaidAmount =\\n            inbox.callVaultRepay(params.borrowVault, address(borrowAsset), repayAmount, params.account);\\n\\n        // we already calculated the amount of debt that was going to be repaid, so this is sanity to ensure we repaid as expected\\n        require(repaidAmount == repayAmount, UnexpectedRepayResult(repayAmount, repaidAmount));\\n\\n        emit CowEvcPositionClosed(\\n            params.owner,\\n            params.account,\\n            params.borrowVault,\\n            params.collateralVault,\\n            params.collateralAmount,\\n            repayAmount,\\n            swapResultBalance - repayAmount\\n        );\\n    }\\n\\n    /// @notice Helper to convert memory struct (used by CowEvcBaseWrapper) to ParamsLocation\\n    function memoryLocation(ClosePositionParams memory params) internal pure returns (ParamsLocation location) {\\n        assembly (\\\"memory-safe\\\") {\\n            location := params\\n        }\\n    }\\n\\n    /// @notice Helper to convert ParamsLocation (used by CowEvcBaseWrapper) back to memory struct\\n    function paramsFromMemory(ParamsLocation location) internal pure returns (ClosePositionParams memory params) {\\n        assembly {\\n            params := location\\n        }\\n    }\\n}\\n\"},\"src/CowWrapper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity ^0.8;\\n\\n/**\\n * Title: CoW Wrapper all-in-one integration file\\n * Author: CoW DAO\\n * This file is completely self-contained (ie no dependencies) and can be portably copied to whatever projects it is needed.\\n * It contains:\\n * * CowWrapper -- an abstract base contract which should be inherited by all wrappers\\n * * ICowWrapper -- the required interface for all wrappers\\n * * ICowSettlement -- A minimized interface and base structures for CoW Protocol settlement contract. From https://github.com/cowprotocol/contracts/blob/main/src/contracts/GPv2Settlement.sol\\n * * ICowAuthentication -- The authentication interface used by ICowSettlement. From https://github.com/cowprotocol/contracts/blob/main/src/contracts/interfaces/GPv2Authentication.sol\\n */\\n\\n/// @title CoW Protocol Authentication Interface\\n/// @author CoW DAO developers\\ninterface ICowAuthentication {\\n    /// @dev determines whether the provided address is an authenticated solver.\\n    /// @param prospectiveSolver the address of prospective solver.\\n    /// @return true when prospectiveSolver is an authenticated solver, otherwise false.\\n    function isSolver(address prospectiveSolver) external view returns (bool);\\n}\\n\\n/// @title CoW Protocol Settlement Interface\\n/// @notice Minimal interface for CoW Protocol's settlement contract\\n/// @dev Used for type-safe calls to the settlement contract's settle function\\ninterface ICowSettlement {\\n    /// @notice Trade data structure matching GPv2Settlement\\n    struct Trade {\\n        uint256 sellTokenIndex;\\n        uint256 buyTokenIndex;\\n        address receiver;\\n        uint256 sellAmount;\\n        uint256 buyAmount;\\n        uint32 validTo;\\n        bytes32 appData;\\n        uint256 feeAmount;\\n        uint256 flags;\\n        uint256 executedAmount;\\n        bytes signature;\\n    }\\n\\n    /// @notice Interaction data structure for pre/intra/post-settlement actions which are supplied by the solver to complete the user request\\n    struct Interaction {\\n        address target;\\n        uint256 value;\\n        bytes callData;\\n    }\\n\\n    /// @notice Returns the authentication contract used by the settlement contract.\\n    function authenticator() external view returns (ICowAuthentication);\\n\\n    /// @notice Returns the address of the vaultRelayer, the target for approvals for funds entering the settlement contract.\\n    function vaultRelayer() external view returns (address);\\n\\n    /// @notice Returns the domain separator for EIP-712 signing\\n    function domainSeparator() external view returns (bytes32);\\n\\n    /// @notice Allows for approval of orders by submitting an authorized hash on-chain prior to order execution.\\n    function setPreSignature(bytes calldata orderUid, bool signed) external;\\n\\n    /// @notice Settles a batch of trades atomically\\n    /// @param tokens Array of token addresses involved in the settlement\\n    /// @param clearingPrices Array of clearing prices for each token\\n    /// @param trades Array of trades to execute\\n    /// @param interactions Array of three interaction arrays (pre, intra, post-settlement)\\n    function settle(\\n        address[] calldata tokens,\\n        uint256[] calldata clearingPrices,\\n        Trade[] calldata trades,\\n        Interaction[][3] calldata interactions\\n    ) external;\\n}\\n\\n/// @title CoW Protocol Wrapper Interface\\n/// @notice Interface for wrapper contracts that add custom logic around CoW settlements\\n/// @dev Wrappers can be chained together to compose multiple settlement operations\\ninterface ICowWrapper {\\n    /// @notice A human readable label for this wrapper. Used for display in explorer/analysis UIs\\n    function name() external view returns (string memory);\\n\\n    /// @notice The settlement contract used by this wrapper\\n    /// @return The CowSettlement contract address\\n    function SETTLEMENT() external view returns (ICowSettlement);\\n\\n    /// @notice Initiates a wrapped settlement call\\n    /// @dev This is the entry point for wrapped settlements. The wrapper will execute custom logic\\n    ///      before calling the next wrapper or settlement contract in the chain.\\n    /// @dev SECURITY: `settleData` is NOT guaranteed to remain unchanged through the wrapper chain.\\n    ///      Intermediate wrappers could modify it before passing it along. Do not rely on\\n    ///      `settleData` validation for security-critical checks.\\n    /// @param settleData ABI-encoded call to ICowSettlement.settle() containing trade data\\n    /// @param chainedWrapperData Encoded wrapper chain with the following format:\\n    ///        Structure: [uint16 len1][bytes data1][address wrapper2][uint16 len2][bytes data2][address wrapper3]...\\n    ///\\n    ///        Each wrapper in the chain consists of:\\n    ///        - 2 bytes: uint16 length of wrapper-specific data\\n    ///        - `length` bytes: wrapper-specific data for this wrapper\\n    ///        - 20 bytes: address of next wrapper (omitted for the final wrapper)\\n    ///\\n    ///        The final wrapper in the chain omits the next wrapper address and calls SETTLEMENT directly.\\n    ///\\n    ///        Example: [0x0005][0xAABBCCDDEE][0x1234...ABCD][0x0003][0x112233]\\n    ///                 len   data         next wrapper  len   data (final, no next address)\\n    ///\\n    function wrappedSettle(bytes calldata settleData, bytes calldata chainedWrapperData) external;\\n\\n    /// @notice Confirms validity of wrapper-specific data\\n    /// @dev Used by CowWrapperHelpers to validate wrapper data before execution. Reverts if the wrapper data is not valid for some reason.\\n    /// @param wrapperData The wrapper-specific data to parse\\n    function validateWrapperData(bytes calldata wrapperData) external view;\\n}\\n\\n/// @title CoW Protocol Wrapper Base Contract\\n/// @notice Abstract base contract for creating wrapper contracts around CoW Protocol settlements\\n/// @dev A wrapper enables custom pre/post-settlement and context-setting logic and can be chained with other wrappers.\\n///      Wrappers must:\\n///      - Be approved by the ICowAuthentication contract\\n///      - Verify the caller is an authenticated solver\\n///      - Eventually call settle() on the approved ICowSettlement contract\\n///      - Implement _wrap() for custom logic\\nabstract contract CowWrapper is ICowWrapper {\\n    /// @notice Thrown when the caller is not an authenticated solver\\n    /// @param unauthorized The address that attempted to call wrappedSettle\\n    error NotASolver(address unauthorized);\\n\\n    /// @notice Thrown when settle data doesn't contain the correct function selector\\n    /// @param invalidSettleData The invalid settle data that was provided\\n    error InvalidSettleData(bytes invalidSettleData);\\n\\n    /// @notice The settlement contract\\n    ICowSettlement public immutable SETTLEMENT;\\n\\n    /// @notice The authentication contract used to verify solvers\\n    /// @dev This is derived from `SETTLEMENT.authenticator()`.\\n    ICowAuthentication public immutable AUTHENTICATOR;\\n\\n    /// @notice Constructs a new CowWrapper\\n    /// @param settlement_ The ICowSettlement contract to use at the end of the wrapper chain. Also used for wrapper authentication.\\n    constructor(ICowSettlement settlement_) {\\n        SETTLEMENT = settlement_;\\n        AUTHENTICATOR = settlement_.authenticator();\\n    }\\n\\n    /// @inheritdoc ICowWrapper\\n    function wrappedSettle(bytes calldata settleData, bytes calldata chainedWrapperData) external {\\n        // Revert if not a valid solver\\n        require(AUTHENTICATOR.isSolver(msg.sender), NotASolver(msg.sender));\\n\\n        // Find out how long the next wrapper data is supposed to be\\n        // We use 2 bytes to decode the length of the wrapper data because it allows for up to 64KB of data for each wrapper.\\n        // This should be plenty of length for all identified use-cases of wrappers in the forseeable future.\\n        uint256 nextWrapperDataLen = uint256(uint16(bytes2(chainedWrapperData[0:2])));\\n\\n        // Delegate to the wrapper's custom logic\\n        uint256 remainingWrapperDataStart = 2 + nextWrapperDataLen;\\n        _wrap(\\n            settleData, chainedWrapperData[2:remainingWrapperDataStart], chainedWrapperData[remainingWrapperDataStart:]\\n        );\\n    }\\n\\n    /// @inheritdoc ICowWrapper\\n    function validateWrapperData(bytes calldata wrapperData) external view virtual;\\n\\n    /// @notice Internal function containing the wrapper's custom logic\\n    /// @dev Must be implemented by concrete wrapper contracts. Should execute custom logic\\n    ///      then eventually call _next() to continue the wrapped settlement chain.\\n    /// @param settleData ABI-encoded call to ICowSettlement.settle()\\n    /// @param wrapperData The wrapper data which should be consumed by this wrapper\\n    /// @param remainingWrapperData The reminder bytes resulting from consuming the current's wrapper data from the original `chainedWrapperData` in the `wrappedSettle` call. This should be passed unaltered to `_next` that will call the settlement function if this remainder is empty, or delegate the settlement to the next wrapper\\n    function _wrap(bytes calldata settleData, bytes calldata wrapperData, bytes calldata remainingWrapperData)\\n        internal\\n        virtual;\\n\\n    /// @notice Continues the wrapped settlement chain by calling the next wrapper or settlement contract\\n    /// @dev Extracts the next target address from wrapperData and either:\\n    ///      - Calls ICowSettlement.settle() directly if no more wrappers remain, or\\n    ///      - Calls the next CowWrapper.wrappedSettle() to continue the chain\\n    /// @param settleData ABI-encoded call to ICowSettlement.settle()\\n    /// @param remainingWrapperData Remaining wrapper data starting with the next target address (20 bytes)\\n    function _next(bytes calldata settleData, bytes calldata remainingWrapperData) internal {\\n        if (remainingWrapperData.length == 0) {\\n            // No more wrapper data - we're calling the final settlement contract\\n            // Verify the settle data has the correct function selector\\n            require(bytes4(settleData[:4]) == ICowSettlement.settle.selector, InvalidSettleData(settleData));\\n\\n            // Call the settlement contract directly with the settle data\\n            (bool success, bytes memory returnData) = address(SETTLEMENT).call(settleData);\\n\\n            if (!success) {\\n                // Bubble up the revert reason from the settlement contract\\n                assembly (\\\"memory-safe\\\") {\\n                    revert(add(returnData, 0x20), mload(returnData))\\n                }\\n            }\\n        } else {\\n            // Extract the next wrapper address from the first 20 bytes of wrapperData\\n            address nextWrapper = address(bytes20(remainingWrapperData[:20]));\\n\\n            // Skip past the address we just read\\n            remainingWrapperData = remainingWrapperData[20:];\\n\\n            // More wrapper data remains - call the next wrapper in the chain\\n            CowWrapper(nextWrapper).wrappedSettle(settleData, remainingWrapperData);\\n        }\\n    }\\n}\\n\"},\"src/Inbox.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity ^0.8;\\n\\nimport {IBorrowing} from \\\"euler-vault-kit/src/EVault/IEVault.sol\\\";\\nimport {IERC20} from \\\"openzeppelin-contracts/contracts/interfaces/IERC20.sol\\\";\\nimport {IERC1271} from \\\"openzeppelin-contracts/contracts/interfaces/IERC1271.sol\\\";\\nimport {SafeERC20} from \\\"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {ICowSettlement} from \\\"./CowWrapper.sol\\\";\\n\\n/// @dev Collection of EIP-712 type hashes. These hashes match those used by the CoW settlement contract.\\nlibrary InboxLibrary {\\n    bytes32 internal constant DOMAIN_TYPE_HASH =\\n        keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\");\\n    bytes32 internal constant ORDER_TYPE_HASH = keccak256(\\n        \\\"Order(address sellToken,address buyToken,address receiver,uint256 sellAmount,uint256 buyAmount,uint32 validTo,bytes32 appData,uint256 feeAmount,string kind,bool partiallyFillable,string sellTokenBalance,string buyTokenBalance)\\\"\\n    );\\n\\n    /// @notice Compute the EIP-712 domain separator for the Inbox contract\\n    /// @param creationAddress The address of the Inbox contract\\n    /// @return domainSeparator The computed domain separator\\n    function computeDomainSeparator(address creationAddress) internal view returns (bytes32 domainSeparator) {\\n        return\\n            /// forge-lint: disable-next-line(asm-keccak256)\\n            keccak256(abi.encode(DOMAIN_TYPE_HASH, keccak256(\\\"Inbox\\\"), keccak256(\\\"1\\\"), block.chainid, creationAddress));\\n    }\\n}\\n\\n/// @notice A contract for receiving funds from the CoW Settlement contract which can then be operated upon by a different contract in post (i.e. a wrapper)\\n/// @dev The contract has two associated accounts-- the OPERATOR, and the BENEFICIARY. Both associated accounts have the ability to execute token operations against this contract.\\n/// The purpose of the OPERATOR is to allow the wrapper to execute whatever operations it needs following a settlement contract operation without needing to store funds in the wrapper itself (ex. potentially intermingled with other user's funds) or the user's own wallet.\\n/// The purpose of the BENEFICIARY is to allow the ultimate holder of the funds to be able to access this contract in the case of trouble (ex. funds got stuck, etc.)\\n/// There are two general ways that this contract should be used in accordance with the wrappers:\\n/// 1. If the wrapper authenticates the users through the permit flow, then the user is expected to sign the Inbox order through an ECDSA signature verified through EIP1271.\\n/// 2. If the wrapper authenticates the user through pre-approved hashes, then the user is expected to use the pre-sign flow on CoW Settlement by enabling the order using the `setPreSignature` proxy function.\\ncontract Inbox is IERC1271 {\\n    using SafeERC20 for IERC20;\\n\\n    error Unauthorized(address);\\n    error OrderHashMismatch(bytes32 computed, bytes32 provided);\\n    error InvalidSignatureOrderData(bytes data);\\n\\n    bytes32 public immutable INBOX_DOMAIN_SEPARATOR;\\n    bytes32 public immutable SETTLEMENT_DOMAIN_SEPARATOR;\\n\\n    /// @notice The contract which is taking action on behalf of the user. Is authorized to execute certain operations specified in this contract.\\n    address public immutable OPERATOR;\\n    /// @notice The address to which the funds ultimately belong to. Is authorized to execute certain operations specified in this contract (in case funds are somehow stuck).\\n    address public immutable BENEFICIARY;\\n    /// @notice The CoW settlement contract address for purposes of signature verification\\n    address public immutable SETTLEMENT;\\n\\n    constructor(address executor, address beneficiary, address settlement) {\\n        OPERATOR = executor;\\n        BENEFICIARY = beneficiary;\\n        SETTLEMENT = settlement;\\n\\n        INBOX_DOMAIN_SEPARATOR = InboxLibrary.computeDomainSeparator(address(this));\\n\\n        SETTLEMENT_DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                InboxLibrary.DOMAIN_TYPE_HASH, keccak256(\\\"Gnosis Protocol\\\"), keccak256(\\\"v2\\\"), block.chainid, settlement\\n            )\\n        );\\n    }\\n\\n    /// @notice Implements EIP1271 `isValidSignature`. This function expects a 65 byte RSV signature, followed by the 416 byte CoW order data.\\n    /// The signature should be the same as the EIP-712 hash normally given to the settlement contract, except the domain separator should be `INBOX_DOMAIN_SEPARATOR()` from this contract.\\n    /// The provided order data needs to match up with the currently processed order, as its orderDigest will be checked to match against the `orderDigest` provided by the settlement contract.\\n    /// @dev A large portion of this code was copied from `GPv2Signer`'s' `ecdsaRecover` function. The idea is that the same signature the user would use. However, the order could be replayed between the inbox/user account's orders if we use the orderDigest as is, so we recompute the order digest using a new domain separator for the Inbox\\n    /// for a regular CoW order is also used here.\\n    function isValidSignature(bytes32 orderDigest, bytes calldata signatureData)\\n        external\\n        view\\n        returns (bytes4 magicValue)\\n    {\\n        bytes32 inboxOrderDigest;\\n        {\\n            // Ensure that we have all the order data. 65 for the signature length, plus 384 (12 fields * 32 bytes) for the order data.\\n            require(signatureData.length >= 65 + 384, InvalidSignatureOrderData(signatureData));\\n\\n            bytes memory orderData = signatureData[65:];\\n            bytes32 typeHash = InboxLibrary.ORDER_TYPE_HASH;\\n            bytes32 structHash;\\n\\n            // NOTE: Compute the EIP-712 order struct hash in place. As suggested\\n            // in the EIP proposal, noting that the order struct has 12 fields, and\\n            // prefixing the type hash `(1 + 12) * 32 = 416` bytes to hash.\\n            // <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#rationale-for-encodedata>\\n            assembly {\\n                mstore(orderData, typeHash)\\n                structHash := keccak256(orderData, 416)\\n            }\\n\\n            bytes32 settlementDomainSeparator = SETTLEMENT_DOMAIN_SEPARATOR;\\n            bytes32 inboxDomainSeparator = INBOX_DOMAIN_SEPARATOR;\\n            bytes32 settlementOrderDigest;\\n\\n            bytes memory message = abi.encodePacked(\\\"\\\\x19\\\\x01\\\", inboxDomainSeparator, structHash);\\n\\n            // We use assembly for the keccak256 hashing due to inefficient impl warning by foundry https://getfoundry.sh/forge/linting/#asm-keccak256\\n            assembly (\\\"memory-safe\\\") {\\n                inboxOrderDigest := keccak256(add(message, 32), 66)\\n                // The difference between the inbox and settlement order digests is only the domainSeparator word.\\n                // So we can get both hashes pretty efficiently through assembly by replacing it\\n                // 34 = 32 (length byte) + 2 (\\\"\\\\x19\\\\x01\\\")\\n                mstore(add(message, 34), settlementDomainSeparator)\\n                settlementOrderDigest := keccak256(add(message, 32), 66)\\n            }\\n\\n            if (settlementOrderDigest != orderDigest) {\\n                revert OrderHashMismatch(settlementOrderDigest, orderDigest);\\n            }\\n        }\\n\\n        bytes calldata signature = signatureData[:65];\\n\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // NOTE: Use assembly to efficiently decode signature data.\\n        assembly (\\\"memory-safe\\\") {\\n            // r = uint256(signature[0:32])\\n            r := calldataload(signature.offset)\\n            // s = uint256(signature[32:64])\\n            s := calldataload(add(signature.offset, 32))\\n            // v = uint8(signature[64])\\n            v := shr(248, calldataload(add(signature.offset, 64)))\\n        }\\n\\n        address signer = ecrecover(inboxOrderDigest, v, r, s);\\n        require(signer == BENEFICIARY, Unauthorized(signer));\\n\\n        return IERC1271.isValidSignature.selector;\\n    }\\n\\n    /// @notice Calls the settlement contract function with the same signature to set a pre signature on behalf of the Inbox\\n    /// @param orderUid The order uid to pre-approve\\n    /// @param approved Whether to approve or revoke approval\\n    function setPreSignature(bytes calldata orderUid, bool approved) external {\\n        require(msg.sender == BENEFICIARY, Unauthorized(msg.sender));\\n\\n        ICowSettlement(SETTLEMENT).setPreSignature(orderUid, approved);\\n    }\\n\\n    /// @notice Safe proxy function to set a token approval from this contract\\n    /// @param token The address to call `approve` on\\n    /// @param spender The `spender` parameter to use for the approve call\\n    /// @param amount The `amount` parameter to use for the approve call\\n    function callApprove(address token, address spender, uint256 amount) external {\\n        require(msg.sender == OPERATOR || msg.sender == BENEFICIARY, Unauthorized(msg.sender));\\n        IERC20(token).forceApprove(spender, amount);\\n    }\\n\\n    /// @notice Transfers tokens from this contract to a recipient\\n    /// @param token The ERC20 token to transfer\\n    /// @param to The recipient address\\n    /// @param amount The amount to transfer\\n    function callTransfer(address token, address to, uint256 amount) external {\\n        require(msg.sender == OPERATOR || msg.sender == BENEFICIARY, Unauthorized(msg.sender));\\n        IERC20(token).safeTransfer(to, amount);\\n    }\\n\\n    /// @notice Calls repay on a vault to repay debt from this contract's balance. Will also set the necessary approval for it to happen.\\n    /// @param vault The vault contract to call repay on\\n    /// @param amount The amount to repay\\n    /// @param account The account to repay debt for\\n    /// @return The amount repaid as returned by the vault\\n    function callVaultRepay(address vault, address asset, uint256 amount, address account) external returns (uint256) {\\n        require(msg.sender == OPERATOR || msg.sender == BENEFICIARY, Unauthorized(msg.sender));\\n        IERC20(asset).forceApprove(vault, amount);\\n        return IBorrowing(vault).repay(amount, account);\\n    }\\n}\\n\"},\"src/InboxFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity ^0.8;\\n\\nimport {Create2} from \\\"openzeppelin-contracts/contracts/utils/Create2.sol\\\";\\nimport {Inbox, InboxLibrary} from \\\"./Inbox.sol\\\";\\n\\n/// @title InboxFactory\\n/// @notice Mixin contract for managing Inbox contract creation and address computation\\n/// @dev Provides utilities for computing and deploying Inbox contracts used in wrapper operations\\ncontract InboxFactory {\\n    /// @notice Settlement contract address used for Inbox creation\\n    /// @dev Stored as immutable to avoid name collision with CowWrapper's public SETTLEMENT\\n    address internal immutable INBOX_SETTLEMENT;\\n\\n    /// @notice Indicates that the computed Create2 address does not match the expected address\\n    error Create2AddressMismatch(address expectedAddress);\\n\\n    /// @notice Initialize the factory with a settlement address\\n    /// @param settlement The settlement contract address to use for Inbox creation\\n    constructor(address settlement) {\\n        INBOX_SETTLEMENT = settlement;\\n    }\\n\\n    /// @notice Get or create an Inbox contract for the given owner and subaccount\\n    /// @dev Deploys the Inbox if it doesn't exist yet\\n    /// @param owner The owner address\\n    /// @param subaccount The subaccount address\\n    /// @return The address of the Inbox contract\\n    function getInbox(address owner, address subaccount) external returns (address) {\\n        return address(_getInbox(owner, subaccount));\\n    }\\n\\n    /// @notice Get the creation code used for the deployed Inboxes. Does not include any constructor params that may need to be appended. Useful for computing the deployed Inbox address wihout needing to make an on-chain call\\n    /// @return creationCode The creation code that will be used.\\n    function getInboxCreationCode() external pure returns (bytes memory creationCode) {\\n        return type(Inbox).creationCode;\\n    }\\n\\n    /// @notice Get the address where an Inbox would be deployed without deploying it, and the domain separator needed to sign a message to it\\n    /// @dev This is a view-only function that only returns the address and domain separator\\n    /// @param owner The owner address\\n    /// @param subaccount The subaccount address\\n    /// @return creationAddress The computed Inbox address\\n    /// @return domainSeparator The domain separator for the Inbox contract\\n    function getInboxAddressAndDomainSeparator(address owner, address subaccount)\\n        external\\n        view\\n        returns (address creationAddress, bytes32 domainSeparator)\\n    {\\n        (creationAddress,,) = _getInboxAddress(owner, subaccount);\\n        domainSeparator = InboxLibrary.computeDomainSeparator(creationAddress);\\n    }\\n\\n    /// @notice Compute the Inbox address for a given owner and subaccount (view-only, does not deploy)\\n    /// @param owner The owner address\\n    /// @param subaccount The subaccount address\\n    /// @return creationAddress The computed Inbox address\\n    /// @return creationCode The code needed to create the contract\\n    /// @return salt The salt that should be used to create the contract\\n    function _getInboxAddress(address owner, address subaccount)\\n        internal\\n        view\\n        returns (address creationAddress, bytes memory creationCode, bytes32 salt)\\n    {\\n        salt = bytes32(uint256(uint160(subaccount)));\\n        creationCode = abi.encodePacked(type(Inbox).creationCode, abi.encode(address(this), owner, INBOX_SETTLEMENT));\\n        creationAddress = Create2.computeAddress(salt, keccak256(creationCode));\\n    }\\n\\n    /// @notice Get or create an Inbox contract instance\\n    /// @dev Deploys the Inbox if it doesn't exist yet\\n    /// @param owner The owner address\\n    /// @param subaccount The subaccount address\\n    /// @return The Inbox contract instance\\n    function _getInbox(address owner, address subaccount) internal returns (Inbox) {\\n        (address expectedAddress, bytes memory creationCode, bytes32 salt) = _getInboxAddress(owner, subaccount);\\n\\n        if (expectedAddress.code.length == 0) {\\n            // `require` here is mostly for sanity\\n            // NOTE: its technically possible to deploy create2 directly using new Contract{salt: }(), but openzeppelin usage\\n            // is good for consistency\\n            require(Create2.deploy(0, salt, creationCode) == expectedAddress, Create2AddressMismatch(expectedAddress));\\n        }\\n\\n        return Inbox(expectedAddress);\\n    }\\n}\\n\"},\"src/PreApprovedHashes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity ^0.8;\\n\\n/// @title PreApprovedHashes\\n/// @notice Abstract contract for managing pre-approved operation hashes\\n/// @dev Allows users to pre-approve specific operations without requiring signatures each time\\nabstract contract PreApprovedHashes {\\n    /// @dev Marker value indicating a hash is pre-approved\\n    uint256 internal constant PRE_APPROVED = uint256(keccak256(\\\"PreApprovedHashes.PreApproved\\\"));\\n    uint256 internal constant CONSUMED = uint256(keccak256(\\\"PreApprovedHashes.Consumed\\\"));\\n\\n    /// @notice Storage indicating whether or not a signed calldata hash has been approved by an owner\\n    /// @dev Maps owner -> hash(orderParameters) -> approval status\\n    mapping(address => mapping(bytes32 => uint256)) public preApprovedHashes;\\n\\n    /// @notice Event emitted when an owner pre-approves or revokes a hash\\n    event PreApprovedHash(address indexed owner, bytes32 indexed hash, bool approved);\\n\\n    /// @notice Event emitted when a pre-approved hash is used and is no longer valid because its consumed\\n    event PreApprovedHashConsumed(address indexed owner, bytes32 indexed hash);\\n\\n    /// @notice Revert reason given when a hash has already been consumed, and therefore cannot be used\\n    /// @dev If the hash had simply never been approved in the first place, the error will be HashNotApproved\\n    error AlreadyConsumed(address owner, bytes32 hash);\\n\\n    /// @notice Revert reason given when a pre approved hash is being consumed, but it hasnt actually been approved.\\n    /// @dev If the hash has been approved in the past, but it was consumed, the error will be AlreadyConsumed\\n    error HashNotApproved(address owner, bytes32 hash);\\n\\n    /// @notice Pre-approve a hash of signed calldata for future execution\\n    /// @dev Once a hash is pre-approved, it can only be consumed once. This prevents replay attacks.\\n    /// @param hash The keccak256 hash of the order parameters\\n    /// @param approved True to approve the hash, false to revoke approval\\n    function setPreApprovedHash(bytes32 hash, bool approved) external {\\n        require(preApprovedHashes[msg.sender][hash] != CONSUMED, AlreadyConsumed(msg.sender, hash));\\n\\n        if (approved) {\\n            preApprovedHashes[msg.sender][hash] = PRE_APPROVED;\\n        } else {\\n            preApprovedHashes[msg.sender][hash] = CONSUMED;\\n        }\\n        emit PreApprovedHash(msg.sender, hash, approved);\\n    }\\n\\n    /// @notice Check if a hash is pre-approved for an owner\\n    /// @param owner The owner address\\n    /// @param hash The hash to check\\n    /// @return True if the hash is pre-approved, false otherwise\\n    function isHashPreApproved(address owner, bytes32 hash) external view returns (bool) {\\n        return preApprovedHashes[owner][hash] == PRE_APPROVED;\\n    }\\n\\n    /// @notice Check if a hash is pre-approved for an owner. If it is, changes it to be consumed.\\n    /// @param owner The owner address\\n    /// @param hash The hash to check\\n    function _consumePreApprovedHash(address owner, bytes32 hash) internal {\\n        if (preApprovedHashes[owner][hash] == PRE_APPROVED) {\\n            preApprovedHashes[owner][hash] = CONSUMED;\\n            emit PreApprovedHashConsumed(owner, hash);\\n        } else if (preApprovedHashes[owner][hash] == CONSUMED) {\\n            revert AlreadyConsumed(owner, hash);\\n        } else {\\n            revert HashNotApproved(owner, hash);\\n        }\\n    }\\n}\\n\"}},\"settings\":{\"remappings\":[\"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\"cow/=lib/cow/src/contracts/\",\"ds-test/=lib/evc/lib/forge-std/lib/ds-test/src/\",\"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\"ethereum-vault-connector/=lib/euler-vault-kit/lib/ethereum-vault-connector/src/\",\"euler-vault-kit/=lib/euler-vault-kit/\",\"evc/=lib/euler-vault-kit/lib/ethereum-vault-connector/src/\",\"forge-gas-snapshot/=lib/euler-vault-kit/lib/permit2/lib/forge-gas-snapshot/src/\",\"forge-std/=lib/forge-std/src/\",\"halmos-cheatcodes/=lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/\",\"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\"openzeppelin/=lib/euler-vault-kit/lib/ethereum-vault-connector/lib/openzeppelin-contracts/contracts/\",\"permit2/=lib/euler-vault-kit/lib/permit2/\",\"solmate/=lib/euler-vault-kit/lib/permit2/lib/solmate/\"],\"optimizer\":{\"enabled\":true,\"runs\":200},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"compilationTarget\":{\"src/CowEvcClosePositionWrapper.sol\":\"CowEvcClosePositionWrapper\"},\"evmVersion\":\"prague\",\"libraries\":{},\"viaIR\":true,\"outputSelection\":{\"*\":{\"*\":[\"*\"]}}}}"
      }
    },
    "CowEvcCollateralSwapWrapper": {
      "contractName": "CowEvcCollateralSwapWrapper",
      "sourceName": "src/CowEvcCollateralSwapWrapper.sol",
      "abi": [
        {
          "type": "constructor",
          "inputs": [
            {
              "name": "_evc",
              "type": "address",
              "internalType": "address"
            },
            {
              "name": "_settlement",
              "type": "address",
              "internalType": "contract ICowSettlement"
            }
          ],
          "stateMutability": "nonpayable"
        },
        {
          "type": "function",
          "name": "AUTHENTICATOR",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address",
              "internalType": "contract ICowAuthentication"
            }
          ],
          "stateMutability": "view"
        },
        {
          "type": "function",
          "name": "DOMAIN_SEPARATOR",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bytes32",
              "internalType": "bytes32"
            }
          ],
          "stateMutability": "view"
        },
        {
          "type": "function",
          "name": "DOMAIN_TYPE_HASH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bytes32",
              "internalType": "bytes32"
            }
          ],
          "stateMutability": "view"
        },
        {
          "type": "function",
          "name": "EVC",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address",
              "internalType": "contract IEVC"
            }
          ],
          "stateMutability": "view"
        },
        {
          "type": "function",
          "name": "NONCE_NAMESPACE",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256",
              "internalType": "uint256"
            }
          ],
          "stateMutability": "view"
        },
        {
          "type": "function",
          "name": "PARAMS_TYPE_HASH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bytes32",
              "internalType": "bytes32"
            }
          ],
          "stateMutability": "view"
        },
        {
          "type": "function",
          "name": "SETTLEMENT",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address",
              "internalType": "contract ICowSettlement"
            }
          ],
          "stateMutability": "view"
        },
        {
          "type": "function",
          "name": "encodePermitData",
          "inputs": [
            {
              "name": "params",
              "type": "tuple",
              "internalType": "struct CowEvcCollateralSwapWrapper.CollateralSwapParams",
              "components": [
                {
                  "name": "owner",
                  "type": "address",
                  "internalType": "address"
                },
                {
                  "name": "account",
                  "type": "address",
                  "internalType": "address"
                },
                {
                  "name": "deadline",
                  "type": "uint256",
                  "internalType": "uint256"
                },
                {
                  "name": "fromVault",
                  "type": "address",
                  "internalType": "address"
                },
                {
                  "name": "toVault",
                  "type": "address",
                  "internalType": "address"
                },
                {
                  "name": "fromAmount",
                  "type": "uint256",
                  "internalType": "uint256"
                },
                {
                  "name": "toAmount",
                  "type": "uint256",
                  "internalType": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bytes",
              "internalType": "bytes"
            }
          ],
          "stateMutability": "view"
        },
        {
          "type": "function",
          "name": "evcInternalSettle",
          "inputs": [
            {
              "name": "settleData",
              "type": "bytes",
              "internalType": "bytes"
            },
            {
              "name": "wrapperData",
              "type": "bytes",
              "internalType": "bytes"
            },
            {
              "name": "remainingWrapperData",
              "type": "bytes",
              "internalType": "bytes"
            }
          ],
          "outputs": [],
          "stateMutability": "nonpayable"
        },
        {
          "type": "function",
          "name": "getApprovalHash",
          "inputs": [
            {
              "name": "params",
              "type": "tuple",
              "internalType": "struct CowEvcCollateralSwapWrapper.CollateralSwapParams",
              "components": [
                {
                  "name": "owner",
                  "type": "address",
                  "internalType": "address"
                },
                {
                  "name": "account",
                  "type": "address",
                  "internalType": "address"
                },
                {
                  "name": "deadline",
                  "type": "uint256",
                  "internalType": "uint256"
                },
                {
                  "name": "fromVault",
                  "type": "address",
                  "internalType": "address"
                },
                {
                  "name": "toVault",
                  "type": "address",
                  "internalType": "address"
                },
                {
                  "name": "fromAmount",
                  "type": "uint256",
                  "internalType": "uint256"
                },
                {
                  "name": "toAmount",
                  "type": "uint256",
                  "internalType": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bytes32",
              "internalType": "bytes32"
            }
          ],
          "stateMutability": "view"
        },
        {
          "type": "function",
          "name": "isHashPreApproved",
          "inputs": [
            {
              "name": "owner",
              "type": "address",
              "internalType": "address"
            },
            {
              "name": "hash",
              "type": "bytes32",
              "internalType": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool",
              "internalType": "bool"
            }
          ],
          "stateMutability": "view"
        },
        {
          "type": "function",
          "name": "name",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string",
              "internalType": "string"
            }
          ],
          "stateMutability": "view"
        },
        {
          "type": "function",
          "name": "preApprovedHashes",
          "inputs": [
            {
              "name": "",
              "type": "address",
              "internalType": "address"
            },
            {
              "name": "",
              "type": "bytes32",
              "internalType": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256",
              "internalType": "uint256"
            }
          ],
          "stateMutability": "view"
        },
        {
          "type": "function",
          "name": "setPreApprovedHash",
          "inputs": [
            {
              "name": "hash",
              "type": "bytes32",
              "internalType": "bytes32"
            },
            {
              "name": "approved",
              "type": "bool",
              "internalType": "bool"
            }
          ],
          "outputs": [],
          "stateMutability": "nonpayable"
        },
        {
          "type": "function",
          "name": "validateWrapperData",
          "inputs": [
            {
              "name": "wrapperData",
              "type": "bytes",
              "internalType": "bytes"
            }
          ],
          "outputs": [],
          "stateMutability": "pure"
        },
        {
          "type": "function",
          "name": "wrappedSettle",
          "inputs": [
            {
              "name": "settleData",
              "type": "bytes",
              "internalType": "bytes"
            },
            {
              "name": "chainedWrapperData",
              "type": "bytes",
              "internalType": "bytes"
            }
          ],
          "outputs": [],
          "stateMutability": "nonpayable"
        },
        {
          "type": "event",
          "name": "CowEvcCollateralSwapped",
          "inputs": [
            {
              "name": "owner",
              "type": "address",
              "indexed": true,
              "internalType": "address"
            },
            {
              "name": "account",
              "type": "address",
              "indexed": false,
              "internalType": "address"
            },
            {
              "name": "fromVault",
              "type": "address",
              "indexed": true,
              "internalType": "address"
            },
            {
              "name": "toVault",
              "type": "address",
              "indexed": true,
              "internalType": "address"
            },
            {
              "name": "fromAmount",
              "type": "uint256",
              "indexed": false,
              "internalType": "uint256"
            },
            {
              "name": "toAmount",
              "type": "uint256",
              "indexed": false,
              "internalType": "uint256"
            }
          ],
          "anonymous": false
        },
        {
          "type": "event",
          "name": "PreApprovedHash",
          "inputs": [
            {
              "name": "owner",
              "type": "address",
              "indexed": true,
              "internalType": "address"
            },
            {
              "name": "hash",
              "type": "bytes32",
              "indexed": true,
              "internalType": "bytes32"
            },
            {
              "name": "approved",
              "type": "bool",
              "indexed": false,
              "internalType": "bool"
            }
          ],
          "anonymous": false
        },
        {
          "type": "event",
          "name": "PreApprovedHashConsumed",
          "inputs": [
            {
              "name": "owner",
              "type": "address",
              "indexed": true,
              "internalType": "address"
            },
            {
              "name": "hash",
              "type": "bytes32",
              "indexed": true,
              "internalType": "bytes32"
            }
          ],
          "anonymous": false
        },
        {
          "type": "error",
          "name": "AlreadyConsumed",
          "inputs": [
            {
              "name": "owner",
              "type": "address",
              "internalType": "address"
            },
            {
              "name": "hash",
              "type": "bytes32",
              "internalType": "bytes32"
            }
          ]
        },
        {
          "type": "error",
          "name": "HashNotApproved",
          "inputs": [
            {
              "name": "owner",
              "type": "address",
              "internalType": "address"
            },
            {
              "name": "hash",
              "type": "bytes32",
              "internalType": "bytes32"
            }
          ]
        },
        {
          "type": "error",
          "name": "InvalidCallback",
          "inputs": []
        },
        {
          "type": "error",
          "name": "InvalidSettleData",
          "inputs": [
            {
              "name": "invalidSettleData",
              "type": "bytes",
              "internalType": "bytes"
            }
          ]
        },
        {
          "type": "error",
          "name": "NotASolver",
          "inputs": [
            {
              "name": "unauthorized",
              "type": "address",
              "internalType": "address"
            }
          ]
        },
        {
          "type": "error",
          "name": "OperationDeadlineExceeded",
          "inputs": [
            {
              "name": "validToTimestamp",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "currentTimestamp",
              "type": "uint256",
              "internalType": "uint256"
            }
          ]
        },
        {
          "type": "error",
          "name": "SubaccountMustBeControlledByOwner",
          "inputs": [
            {
              "name": "subaccount",
              "type": "address",
              "internalType": "address"
            },
            {
              "name": "owner",
              "type": "address",
              "internalType": "address"
            }
          ]
        },
        {
          "type": "error",
          "name": "Unauthorized",
          "inputs": [
            {
              "name": "msgSender",
              "type": "address",
              "internalType": "address"
            }
          ]
        },
        {
          "type": "error",
          "name": "UnusedPermitSignature",
          "inputs": []
        }
      ],
      "bytecode": "0x61018080604052346103d55760408161204e803803809161002082856103ec565b8339810103126103d55780516001600160a01b038116918282036103d557602001516001600160a01b038116908181036103d557608052604051632335c76b60e01b815290602090829060049082905afa9081156103e1575f9161039b575b5060a0523b156103565760c052306101005260405160208101907f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f82527f112e2228a6c04d5f949ec3a7d90a0d5c244e1b4cfb0280622833397c566623c760408201527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc660608201524660808201523060a082015260a0815261012360c0826103ec565b51902060e052600154600181811c9116801561034c575b602082101461033857601f8111610303575b507f45756c657220455643202d20436f6c6c61746572616c2053776170000000003660015560405160e081016001600160401b038111828210176102ef576040525f815260208101905f825260408101905f8252606081015f815260808201905f825260c060a08401935f855201935f8552604051955f602088015260018060a01b03905116604087015251606086015260018060a01b03905116608085015260018060a01b0390511660a08401525160c08301525160e082015260e08152610217610100826103ec565b51610120526003610160527f6f3111f44aa446a1be9bd7f7ecd06043885d05cf9479634a958d89d68c0eef4f61014052604051611c3e908161041082396080518181816102570152610acc015260a05181818161095801526109f3015260c0518181816101bd015281816108da01528181610fc5015281816115b6015281816119b50152611b49015260e0518181816105570152610e020152610100518181816104e4015281816119850152611b1901526101205181610dce01526101405181818161083c0152610dab015261016051816115080152f35b634e487b7160e01b5f52604160045260245ffd5b601b81111561014c5760015f52601f60205f20910160051c5f5b81811061032b57505061014c565b5f8382015560010161031d565b634e487b7160e01b5f52602260045260245ffd5b90607f169061013a565b60405162461bcd60e51b815260206004820152601660248201527f455643206164647265737320697320696e76616c6964000000000000000000006044820152606490fd5b90506020813d6020116103d9575b816103b6602093836103ec565b810103126103d557516001600160a01b03811681036103d5575f61007f565b5f80fd5b3d91506103a9565b6040513d5f823e3d90fd5b601f909101601f19168101906001600160401b038211908210176102ef5760405256fe60806040526004361015610011575f80fd5b5f3560e01c8063036b54641461011457806306fdde031461010f5780630c8116701461010a5780631f4975b8146101055780633644e515146101005780634fedcdbf146100fb5780635b0e5556146100f65780636f2b25e0146100f1578063756fe481146100ec5780637e829b31146100e7578063a5a763b1146100e2578063a70354a1146100dd578063c0993eea146100d8578063c6186181146100d3578063d20e71e7146100ce5763ef0fe245146100c9575f80fd5b610ab7565b610987565b610943565b610909565b6108c5565b61085f565b610825565b6107e1565b61079e565b610661565b61062b565b610540565b610507565b6104cd565b6103da565b61014a565b9181601f84011215610146578235916001600160401b038311610146576020838186019501011161014657565b5f80fd5b34610146576060366003190112610146576004356001600160401b0381116101465761017a903690600401610119565b906024356001600160401b0381116101465761019a903690600401610119565b50506044356001600160401b038111610146576101bb903690600401610119565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03163303610330575f5c6101f73636610b16565b6020815191012003610321575f805d80610299575050818161024382826102205f978897610bf3565b6313d79a0b60e01b916001600160e01b03199161023c91611358565b161461138e565b610252604051809381936113c2565b0390827f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165af16102896113cf565b901561029157005b602081519101fd5b80806102ba6102b46102ae6102c09587610bc8565b906112d1565b60601c90565b93610bd6565b9390916001600160a01b031690813b15610146575f80946102f76040519788968795869463d20e71e760e01b865260048601611331565b03925af1801561031c57610308575b005b806103165f61030693610381565b80610343565b610b95565b63f7a632f560e01b5f5260045ffd5b63472511eb60e11b5f523360045260245ffd5b5f91031261014657565b634e487b7160e01b5f52604160045260245ffd5b60e081019081106001600160401b0382111761037c57604052565b61034d565b90601f801991011681019081106001600160401b0382111761037c57604052565b805180835260209291819084018484015e5f828201840152601f01601f1916010190565b9060206103d79281815201906103a2565b90565b34610146575f366003190112610146576040515f6001548060011c90600181169081156104c3575b6020831082146104af5782855260208501919081156104965750600114610444575b6104408461043481860382610381565b604051918291826103c6565b0390f35b60015f9081529250907fb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf65b8184106104825750500161043482610424565b80548484015260209093019260010161046f565b60ff191682525090151560051b01905061043482610424565b634e487b7160e01b5f52602260045260245ffd5b91607f1691610402565b34610146575f3660031901126101465760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b34610146576020366003190112610146576004356001600160401b0381116101465761053a610306913690600401610119565b90610ce4565b34610146575f3660031901126101465760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b60405190610589608083610381565b565b600435906001600160a01b038216820361014657565b35906001600160a01b038216820361014657565b60e090600319011261014657604051906105ce82610361565b816004356001600160a01b03811681036101465781526105ee60246105a1565b6020820152604435604082015261060560646105a1565b606082015261061460846105a1565b608082015260a43560a082015260c060c435910152565b346101465760e036600319011261014657602061064f61064a366105b5565b610da0565b604051908152f35b8015150361014657565b346101465760403660031901126101465760043560243561068181610657565b335f525f60205260405f20825f526020527fc7a17c84cfc6bd62e248dc40d0d98f59040bcfbba3ed5cfe5a87aac90152ca7460405f20541461078757801561074057335f90815260208190526040902061070e906106e99084905b905f5260205260405f2090565b7ffdeb67b02819f1ab9c0e57355ac925e9fe35883f75ef41b364cd780799c5998a9055565b604051901515815233907fc96db6e691f7453f4a948b101f35561af4e2acf852cd1b95698ba775717a816a90602090a3005b335f9081526020819052604090206107829061075d9084906106dc565b7fc7a17c84cfc6bd62e248dc40d0d98f59040bcfbba3ed5cfe5a87aac90152ca749055565b61070e565b5063ae9c304b60e01b5f523360045260245260445ffd5b346101465760e0366003190112610146576104406107cd6107be366105b5565b6107c781610f01565b50611170565b6040519182916020835260208301906103a2565b34610146576040366003190112610146576107fa61058b565b6001600160a01b03165f90815260208181526040808320602435845282529182902054915191825290f35b34610146575f3660031901126101465760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b346101465760403660031901126101465761087861058b565b6024359060018060a01b03165f525f60205260405f20905f5260205260207ffdeb67b02819f1ab9c0e57355ac925e9fe35883f75ef41b364cd780799c5998a60405f205414604051908152f35b34610146575f366003190112610146576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b34610146575f3660031901126101465760206040517f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f8152f35b34610146575f366003190112610146576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b34610146576040366003190112610146576004356001600160401b038111610146576109b7903690600401610119565b6024356001600160401b038111610146576109d6903690600401610119565b6040516302cc250d60e01b815233600482015293916020856024817f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165afa94851561031c5761030695610a3b915f91610a88575b503390610ba0565b610a8082610a6d610a68610a61610a5b610a558588610c01565b90610c44565b60f01c90565b61ffff1690565b610c8e565b610a78818386610c0f565b959094610c2c565b9490936111bd565b610aaa915060203d602011610ab0575b610aa28183610381565b810190610b80565b5f610a33565b503d610a98565b34610146575f366003190112610146576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b6001600160401b03811161037c57601f01601f191660200190565b919091610b2281610afb565b610b2f6040519182610381565b809382825282116101465781815f9384602080950137010152565b929192610b5682610afb565b91610b646040519384610381565b829481845281830111610146578281602093845f960137010152565b9081602091031261014657516103d781610657565b6040513d5f823e3d90fd5b15610ba85750565b6363546f7f60e01b5f9081526001600160a01b0391909116600452602490fd5b906014116101465790601490565b909291928360141161014657831161014657601401916013190190565b906004116101465790600490565b906002116101465790600290565b909291928360021161014657831161014657600201916001190190565b90939293848311610146578411610146578101920390565b356001600160f01b0319811692919060028210610c5f575050565b6001600160f01b031960029290920360031b82901b16169150565b634e487b7160e01b5f52601160045260245ffd5b6002019081600211610c9c57565b610c7a565b91908201809211610c9c57565b60405190610cbb82610361565b5f60c0838281528260208201528260408201528260608201528260808201528260a08201520152565b90610ced610cae565b50810181810361010081126101465760e0136101465760405191610d1083610361565b610d19816105a1565b8352610d27602082016105a1565b602084015260408101356040840152610d42606082016105a1565b6060840152610d53608082016105a1565b608084015260a081013560a084015260c081013560c084015260e0810135906001600160401b03821161014657019080601f8301121561014657816020610d9c93359101610b4a565b9091565b604290601f190180517f000000000000000000000000000000000000000000000000000000000000000082527f0000000000000000000000000000000000000000000000000000000000000000602001822091526040519061190160f01b82527f0000000000000000000000000000000000000000000000000000000000000000600283015260228201522090565b6001600160401b03811161037c5760051b60200190565b90610e5082610e2f565b610e5d6040519182610381565b8281528092610e6e601f1991610e2f565b015f5b818110610e7d57505050565b6040519060808201918083106001600160401b0384111761037c576020926040525f81525f838201525f604082015260608082015282828601015201610e71565b805115610ecb5760200190565b634e487b7160e01b5f52603260045260245ffd5b8051821015610ecb5760209160051b010190565b5f19810191908211610c9c57565b610f0a906113fe565b805160208201805190939261101d9290916001600160a01b039081169116036110c757610fbb610f806080610f71610f4660ff60015b16610e46565b855189519199916001600160a01b039081169116818103611023575b5050516001600160a01b031690565b9301516001600160a01b031690565b604051636a27f72d60e11b60208201526001600160a01b0393841660248201529216604483015281606481015b03601f198101835282610381565b610fc361057a565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152905f60208301525f6040830152606082015261100b8451610ef3565b906110168286610edf565b5283610edf565b50600190565b60608801516110a1906001600160a01b031660a08a015160405163a9059cbb60e01b60208201526001600160a01b03909416602485015260448401529261107783606481015b03601f198101855284610381565b61109161108261057a565b6001600160a01b039095168552565b6001600160a01b03166020840152565b5f604083015260608201526110b58a610ebe565b526110bf89610ebe565b505f80610f62565b610fbb610f806080610f71610f4660ff6002610f40565b602081016020825282518091526040820191602060408360051b8301019401925f915b83831061111057505050505090565b9091929394602080611161600193603f19868203018752608060608b51878060a01b038151168452878060a01b038682015116868501526040810151604085015201519181606082015201906103a2565b97019301930191939290611101565b906020806103d79261119d6040519161064a836110698682019963305ab9e960e21b8b52602483016110de565b6040519586925180918585015e8201908382015203018084520182610381565b919390610fad6112269261125195976112146111d98a8a610ce4565b99909a611202604051998a9862dad51960e21b60208b0152606060248b015260848a0191611311565b87810360231901604489015291611311565b84810360231901606486015291611311565b83516001600160a01b0316602085018051909491906001600160a01b031691866040810151946114a3565b815161126e906001600160a01b031691516001600160a01b031690565b606083810151608085015160a086015160c090960151604080516001600160a01b039687168152602081019890985287015283169490831693909216917fa784500c0af4d640489b0a5e50c4695b9b5c96a74a20a373b97117932c58269d9190a4565b356bffffffffffffffffffffffff198116929190601482106112f1575050565b6bffffffffffffffffffffffff1960149290920360031b82901b16169150565b908060209392818452848401375f828201840152601f01601f1916010190565b929061134a906103d79593604086526040860191611311565b926020818503910152611311565b356001600160e01b0319811692919060048210611373575050565b6001600160e01b031960049290920360031b82901b16169150565b9190911561139a575050565b6113be6040519283926360de6df360e11b8452602060048501526024840191611311565b0390fd5b908092918237015f815290565b3d156113f9573d906113e082610afb565b916113ee6040519384610381565b82523d5f602084013e565b606090565b611406610cae565b5090565b15611413575050565b632bf6252360e21b5f9081526001600160a01b039182166004529116602452604490fd5b15611440575050565b6302232baf60e51b5f5260045260245260445ffd5b60405190611464602083610381565b5f808352366020840137565b5f198114610c9c5760010190565b1561148557565b638533e92760e01b5f5260045ffd5b90816020910312610146575190565b91909394929460018060a01b038616916cffffffffffffffffffffffffff198760601b169486888261158b60018060a01b038716986114f884898d6cffffffffffffffffffffffffff198260601b161461140a565b8651156117b8575b61154a61152c7f0000000000000000000000000000000000000000000000000000000000000000610e46565b9c8d9561153882610f01565b9990918a156117aa578b925b89611951565b90805160208201205f5d61155c61057a565b308152903060208301525f604083015260608201526115848261157e81611470565b96610edf565b528b610edf565b5083156117a2575b916115ac916115b2938c6115a5611455565b928d611ae7565b9161147e565b86527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031695863b15610146575f611605916040518093819263305ab9e960e21b8352600483016110de565b0381838b5af1801561031c5761178e575b505115611626575b505050505050565b60405163b03c130d60e01b81526001600160681b0319949094166004850152306024850152602084604481885afa93841561031c575f9461175d575b5060016001600160a01b03838518161b8416611703575b50141590816116f6575b50611692575b8080808061161e565b803b1561014657604051634fae231560e11b81526001600160a01b039290921660048301523060248301525f60448301819052908290606490829084905af1801561031c576116e2575b80611689565b806103165f6116f093610381565b5f6116dc565b600191501615155f611683565b843b1561014657604051634fae231560e11b81526001600160a01b039190911660048201523060248201525f604482018190528160648183895af1801561031c571561167957806103165f61175793610381565b5f611679565b61178091945060203d602011611787575b6117788183610381565b810190611494565b925f611662565b503d61176e565b806103165f61179c93610381565b5f611616565b5f9350611593565b6117b2611455565b92611544565b6117ca6117c486610da0565b856117dd565b6117d8428442811015611437565b611500565b60018060a01b03811690815f525f60205260405f20835f526020527ffdeb67b02819f1ab9c0e57355ac925e9fe35883f75ef41b364cd780799c5998a60405f2054145f1461186b5761075d836106dc6118459360018060a01b03165f525f60205260405f2090565b7fb7c8974e057303dd6a257526d2baec5ecd92237f586b8e622451647cb37cee6f5f80a3565b6001600160a01b0381165f9081526020819052604090208390815f526020527fc7a17c84cfc6bd62e248dc40d0d98f59040bcfbba3ed5cfe5a87aac90152ca7460405f2054145f146118d75763ae9c304b60e01b5f526001600160a01b0390911660045260245260445ffd5b635ae2147960e01b5f526001600160a01b0390911660045260245260445ffd5b95926103d7979592611943959260018060a01b0316885260018060a01b031660208801526040870152606086015260808501525f60a085015261010060c08501526101008401906103a2565b9160e08184039101526103a2565b91929493905f93825115155f14611a925760405163096b649b60e11b81526001600160681b0319606083901b1660048201527f0000000000000000000000000000000000000000000000000000000000000000602482018190526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016989094906020836044818d5afa90811561031c5761140699611a2696610fad955f94611a6b575b5090611a0791611170565b91604051978896635bedd1cd60e01b60208901523090602489016118f7565b611a40611a3161057a565b6001600160a01b039096168652565b5f60208601525f60408601526060850152611a5a82611470565b93611a658383610edf565b52610edf565b611a0792919450611a8a9060203d602011611787576117788183610381565b9390916119fc565b50935050939250505f5b8151811015611ad95780611ad2611ab560019385610edf565b51611ac0835f610ca1565b90611acb8289610edf565b5286610edf565b5001611a9c565b506103d7919250515f610ca1565b8451929593949193909215611bc25760405163096b649b60e11b81526001600160681b0319606088901b1660048201527f0000000000000000000000000000000000000000000000000000000000000000602482018190526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169790939091906020826044818c5afa801561031c5761140698611a2695610fad945f93611b9d575b50611a07906060611170565b611a07919350611bbb9060203d602011611787576117788183610381565b9290611b91565b505093925090505f5b606051811015611bf85780611bf1611be66001936060610edf565b51611ac08386610ca1565b5001611bcb565b506103d791925060605190610ca156fea264697066735822122008f438e2776db7c3ec71f9b9f2fefbb3b032fed49bbd8ff9cc5e99309928977364736f6c63430008210033",
      "deployedBytecode": "0x60806040526004361015610011575f80fd5b5f3560e01c8063036b54641461011457806306fdde031461010f5780630c8116701461010a5780631f4975b8146101055780633644e515146101005780634fedcdbf146100fb5780635b0e5556146100f65780636f2b25e0146100f1578063756fe481146100ec5780637e829b31146100e7578063a5a763b1146100e2578063a70354a1146100dd578063c0993eea146100d8578063c6186181146100d3578063d20e71e7146100ce5763ef0fe245146100c9575f80fd5b610ab7565b610987565b610943565b610909565b6108c5565b61085f565b610825565b6107e1565b61079e565b610661565b61062b565b610540565b610507565b6104cd565b6103da565b61014a565b9181601f84011215610146578235916001600160401b038311610146576020838186019501011161014657565b5f80fd5b34610146576060366003190112610146576004356001600160401b0381116101465761017a903690600401610119565b906024356001600160401b0381116101465761019a903690600401610119565b50506044356001600160401b038111610146576101bb903690600401610119565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03163303610330575f5c6101f73636610b16565b6020815191012003610321575f805d80610299575050818161024382826102205f978897610bf3565b6313d79a0b60e01b916001600160e01b03199161023c91611358565b161461138e565b610252604051809381936113c2565b0390827f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165af16102896113cf565b901561029157005b602081519101fd5b80806102ba6102b46102ae6102c09587610bc8565b906112d1565b60601c90565b93610bd6565b9390916001600160a01b031690813b15610146575f80946102f76040519788968795869463d20e71e760e01b865260048601611331565b03925af1801561031c57610308575b005b806103165f61030693610381565b80610343565b610b95565b63f7a632f560e01b5f5260045ffd5b63472511eb60e11b5f523360045260245ffd5b5f91031261014657565b634e487b7160e01b5f52604160045260245ffd5b60e081019081106001600160401b0382111761037c57604052565b61034d565b90601f801991011681019081106001600160401b0382111761037c57604052565b805180835260209291819084018484015e5f828201840152601f01601f1916010190565b9060206103d79281815201906103a2565b90565b34610146575f366003190112610146576040515f6001548060011c90600181169081156104c3575b6020831082146104af5782855260208501919081156104965750600114610444575b6104408461043481860382610381565b604051918291826103c6565b0390f35b60015f9081529250907fb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf65b8184106104825750500161043482610424565b80548484015260209093019260010161046f565b60ff191682525090151560051b01905061043482610424565b634e487b7160e01b5f52602260045260245ffd5b91607f1691610402565b34610146575f3660031901126101465760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b34610146576020366003190112610146576004356001600160401b0381116101465761053a610306913690600401610119565b90610ce4565b34610146575f3660031901126101465760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b60405190610589608083610381565b565b600435906001600160a01b038216820361014657565b35906001600160a01b038216820361014657565b60e090600319011261014657604051906105ce82610361565b816004356001600160a01b03811681036101465781526105ee60246105a1565b6020820152604435604082015261060560646105a1565b606082015261061460846105a1565b608082015260a43560a082015260c060c435910152565b346101465760e036600319011261014657602061064f61064a366105b5565b610da0565b604051908152f35b8015150361014657565b346101465760403660031901126101465760043560243561068181610657565b335f525f60205260405f20825f526020527fc7a17c84cfc6bd62e248dc40d0d98f59040bcfbba3ed5cfe5a87aac90152ca7460405f20541461078757801561074057335f90815260208190526040902061070e906106e99084905b905f5260205260405f2090565b7ffdeb67b02819f1ab9c0e57355ac925e9fe35883f75ef41b364cd780799c5998a9055565b604051901515815233907fc96db6e691f7453f4a948b101f35561af4e2acf852cd1b95698ba775717a816a90602090a3005b335f9081526020819052604090206107829061075d9084906106dc565b7fc7a17c84cfc6bd62e248dc40d0d98f59040bcfbba3ed5cfe5a87aac90152ca749055565b61070e565b5063ae9c304b60e01b5f523360045260245260445ffd5b346101465760e0366003190112610146576104406107cd6107be366105b5565b6107c781610f01565b50611170565b6040519182916020835260208301906103a2565b34610146576040366003190112610146576107fa61058b565b6001600160a01b03165f90815260208181526040808320602435845282529182902054915191825290f35b34610146575f3660031901126101465760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b346101465760403660031901126101465761087861058b565b6024359060018060a01b03165f525f60205260405f20905f5260205260207ffdeb67b02819f1ab9c0e57355ac925e9fe35883f75ef41b364cd780799c5998a60405f205414604051908152f35b34610146575f366003190112610146576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b34610146575f3660031901126101465760206040517f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f8152f35b34610146575f366003190112610146576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b34610146576040366003190112610146576004356001600160401b038111610146576109b7903690600401610119565b6024356001600160401b038111610146576109d6903690600401610119565b6040516302cc250d60e01b815233600482015293916020856024817f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165afa94851561031c5761030695610a3b915f91610a88575b503390610ba0565b610a8082610a6d610a68610a61610a5b610a558588610c01565b90610c44565b60f01c90565b61ffff1690565b610c8e565b610a78818386610c0f565b959094610c2c565b9490936111bd565b610aaa915060203d602011610ab0575b610aa28183610381565b810190610b80565b5f610a33565b503d610a98565b34610146575f366003190112610146576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b6001600160401b03811161037c57601f01601f191660200190565b919091610b2281610afb565b610b2f6040519182610381565b809382825282116101465781815f9384602080950137010152565b929192610b5682610afb565b91610b646040519384610381565b829481845281830111610146578281602093845f960137010152565b9081602091031261014657516103d781610657565b6040513d5f823e3d90fd5b15610ba85750565b6363546f7f60e01b5f9081526001600160a01b0391909116600452602490fd5b906014116101465790601490565b909291928360141161014657831161014657601401916013190190565b906004116101465790600490565b906002116101465790600290565b909291928360021161014657831161014657600201916001190190565b90939293848311610146578411610146578101920390565b356001600160f01b0319811692919060028210610c5f575050565b6001600160f01b031960029290920360031b82901b16169150565b634e487b7160e01b5f52601160045260245ffd5b6002019081600211610c9c57565b610c7a565b91908201809211610c9c57565b60405190610cbb82610361565b5f60c0838281528260208201528260408201528260608201528260808201528260a08201520152565b90610ced610cae565b50810181810361010081126101465760e0136101465760405191610d1083610361565b610d19816105a1565b8352610d27602082016105a1565b602084015260408101356040840152610d42606082016105a1565b6060840152610d53608082016105a1565b608084015260a081013560a084015260c081013560c084015260e0810135906001600160401b03821161014657019080601f8301121561014657816020610d9c93359101610b4a565b9091565b604290601f190180517f000000000000000000000000000000000000000000000000000000000000000082527f0000000000000000000000000000000000000000000000000000000000000000602001822091526040519061190160f01b82527f0000000000000000000000000000000000000000000000000000000000000000600283015260228201522090565b6001600160401b03811161037c5760051b60200190565b90610e5082610e2f565b610e5d6040519182610381565b8281528092610e6e601f1991610e2f565b015f5b818110610e7d57505050565b6040519060808201918083106001600160401b0384111761037c576020926040525f81525f838201525f604082015260608082015282828601015201610e71565b805115610ecb5760200190565b634e487b7160e01b5f52603260045260245ffd5b8051821015610ecb5760209160051b010190565b5f19810191908211610c9c57565b610f0a906113fe565b805160208201805190939261101d9290916001600160a01b039081169116036110c757610fbb610f806080610f71610f4660ff60015b16610e46565b855189519199916001600160a01b039081169116818103611023575b5050516001600160a01b031690565b9301516001600160a01b031690565b604051636a27f72d60e11b60208201526001600160a01b0393841660248201529216604483015281606481015b03601f198101835282610381565b610fc361057a565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152905f60208301525f6040830152606082015261100b8451610ef3565b906110168286610edf565b5283610edf565b50600190565b60608801516110a1906001600160a01b031660a08a015160405163a9059cbb60e01b60208201526001600160a01b03909416602485015260448401529261107783606481015b03601f198101855284610381565b61109161108261057a565b6001600160a01b039095168552565b6001600160a01b03166020840152565b5f604083015260608201526110b58a610ebe565b526110bf89610ebe565b505f80610f62565b610fbb610f806080610f71610f4660ff6002610f40565b602081016020825282518091526040820191602060408360051b8301019401925f915b83831061111057505050505090565b9091929394602080611161600193603f19868203018752608060608b51878060a01b038151168452878060a01b038682015116868501526040810151604085015201519181606082015201906103a2565b97019301930191939290611101565b906020806103d79261119d6040519161064a836110698682019963305ab9e960e21b8b52602483016110de565b6040519586925180918585015e8201908382015203018084520182610381565b919390610fad6112269261125195976112146111d98a8a610ce4565b99909a611202604051998a9862dad51960e21b60208b0152606060248b015260848a0191611311565b87810360231901604489015291611311565b84810360231901606486015291611311565b83516001600160a01b0316602085018051909491906001600160a01b031691866040810151946114a3565b815161126e906001600160a01b031691516001600160a01b031690565b606083810151608085015160a086015160c090960151604080516001600160a01b039687168152602081019890985287015283169490831693909216917fa784500c0af4d640489b0a5e50c4695b9b5c96a74a20a373b97117932c58269d9190a4565b356bffffffffffffffffffffffff198116929190601482106112f1575050565b6bffffffffffffffffffffffff1960149290920360031b82901b16169150565b908060209392818452848401375f828201840152601f01601f1916010190565b929061134a906103d79593604086526040860191611311565b926020818503910152611311565b356001600160e01b0319811692919060048210611373575050565b6001600160e01b031960049290920360031b82901b16169150565b9190911561139a575050565b6113be6040519283926360de6df360e11b8452602060048501526024840191611311565b0390fd5b908092918237015f815290565b3d156113f9573d906113e082610afb565b916113ee6040519384610381565b82523d5f602084013e565b606090565b611406610cae565b5090565b15611413575050565b632bf6252360e21b5f9081526001600160a01b039182166004529116602452604490fd5b15611440575050565b6302232baf60e51b5f5260045260245260445ffd5b60405190611464602083610381565b5f808352366020840137565b5f198114610c9c5760010190565b1561148557565b638533e92760e01b5f5260045ffd5b90816020910312610146575190565b91909394929460018060a01b038616916cffffffffffffffffffffffffff198760601b169486888261158b60018060a01b038716986114f884898d6cffffffffffffffffffffffffff198260601b161461140a565b8651156117b8575b61154a61152c7f0000000000000000000000000000000000000000000000000000000000000000610e46565b9c8d9561153882610f01565b9990918a156117aa578b925b89611951565b90805160208201205f5d61155c61057a565b308152903060208301525f604083015260608201526115848261157e81611470565b96610edf565b528b610edf565b5083156117a2575b916115ac916115b2938c6115a5611455565b928d611ae7565b9161147e565b86527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031695863b15610146575f611605916040518093819263305ab9e960e21b8352600483016110de565b0381838b5af1801561031c5761178e575b505115611626575b505050505050565b60405163b03c130d60e01b81526001600160681b0319949094166004850152306024850152602084604481885afa93841561031c575f9461175d575b5060016001600160a01b03838518161b8416611703575b50141590816116f6575b50611692575b8080808061161e565b803b1561014657604051634fae231560e11b81526001600160a01b039290921660048301523060248301525f60448301819052908290606490829084905af1801561031c576116e2575b80611689565b806103165f6116f093610381565b5f6116dc565b600191501615155f611683565b843b1561014657604051634fae231560e11b81526001600160a01b039190911660048201523060248201525f604482018190528160648183895af1801561031c571561167957806103165f61175793610381565b5f611679565b61178091945060203d602011611787575b6117788183610381565b810190611494565b925f611662565b503d61176e565b806103165f61179c93610381565b5f611616565b5f9350611593565b6117b2611455565b92611544565b6117ca6117c486610da0565b856117dd565b6117d8428442811015611437565b611500565b60018060a01b03811690815f525f60205260405f20835f526020527ffdeb67b02819f1ab9c0e57355ac925e9fe35883f75ef41b364cd780799c5998a60405f2054145f1461186b5761075d836106dc6118459360018060a01b03165f525f60205260405f2090565b7fb7c8974e057303dd6a257526d2baec5ecd92237f586b8e622451647cb37cee6f5f80a3565b6001600160a01b0381165f9081526020819052604090208390815f526020527fc7a17c84cfc6bd62e248dc40d0d98f59040bcfbba3ed5cfe5a87aac90152ca7460405f2054145f146118d75763ae9c304b60e01b5f526001600160a01b0390911660045260245260445ffd5b635ae2147960e01b5f526001600160a01b0390911660045260245260445ffd5b95926103d7979592611943959260018060a01b0316885260018060a01b031660208801526040870152606086015260808501525f60a085015261010060c08501526101008401906103a2565b9160e08184039101526103a2565b91929493905f93825115155f14611a925760405163096b649b60e11b81526001600160681b0319606083901b1660048201527f0000000000000000000000000000000000000000000000000000000000000000602482018190526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016989094906020836044818d5afa90811561031c5761140699611a2696610fad955f94611a6b575b5090611a0791611170565b91604051978896635bedd1cd60e01b60208901523090602489016118f7565b611a40611a3161057a565b6001600160a01b039096168652565b5f60208601525f60408601526060850152611a5a82611470565b93611a658383610edf565b52610edf565b611a0792919450611a8a9060203d602011611787576117788183610381565b9390916119fc565b50935050939250505f5b8151811015611ad95780611ad2611ab560019385610edf565b51611ac0835f610ca1565b90611acb8289610edf565b5286610edf565b5001611a9c565b506103d7919250515f610ca1565b8451929593949193909215611bc25760405163096b649b60e11b81526001600160681b0319606088901b1660048201527f0000000000000000000000000000000000000000000000000000000000000000602482018190526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169790939091906020826044818c5afa801561031c5761140698611a2695610fad945f93611b9d575b50611a07906060611170565b611a07919350611bbb9060203d602011611787576117788183610381565b9290611b91565b505093925090505f5b606051811015611bf85780611bf1611be66001936060610edf565b51611ac08386610ca1565b5001611bcb565b506103d791925060605190610ca156fea264697066735822122008f438e2776db7c3ec71f9b9f2fefbb3b032fed49bbd8ff9cc5e99309928977364736f6c63430008210033",
      "linkReferences": {},
      "source": {
        "solcVersion": "0.8.33+commit.64118f21",
        "input": "{\"language\":\"Solidity\",\"sources\":{\"lib/euler-vault-kit/lib/ethereum-vault-connector/src/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport {IEVC} from \\\"./interfaces/IEthereumVaultConnector.sol\\\";\\n\\n/// @title Errors\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice This contract implements the error messages for the Ethereum Vault Connector.\\ncontract Errors {\\n    /// @notice Error for when caller is not authorized to perform an operation.\\n    error EVC_NotAuthorized();\\n    /// @notice Error for when no account has been authenticated to act on behalf of.\\n    error EVC_OnBehalfOfAccountNotAuthenticated();\\n    /// @notice Error for when an operator's to be set is no different from the current one.\\n    error EVC_InvalidOperatorStatus();\\n    /// @notice Error for when a nonce is invalid or already used.\\n    error EVC_InvalidNonce();\\n    /// @notice Error for when an address parameter passed is invalid.\\n    error EVC_InvalidAddress();\\n    /// @notice Error for when a timestamp parameter passed is expired.\\n    error EVC_InvalidTimestamp();\\n    /// @notice Error for when a value parameter passed is invalid or exceeds current balance.\\n    error EVC_InvalidValue();\\n    /// @notice Error for when data parameter passed is empty.\\n    error EVC_InvalidData();\\n    /// @notice Error for when an action is prohibited due to the lockdown mode.\\n    error EVC_LockdownMode();\\n    /// @notice Error for when permit execution is prohibited due to the permit disabled mode.\\n    error EVC_PermitDisabledMode();\\n    /// @notice Error for when checks are in progress and reentrancy is not allowed.\\n    error EVC_ChecksReentrancy();\\n    /// @notice Error for when control collateral is in progress and reentrancy is not allowed.\\n    error EVC_ControlCollateralReentrancy();\\n    /// @notice Error for when there is a different number of controllers enabled than expected.\\n    error EVC_ControllerViolation();\\n    /// @notice Error for when a simulation batch is nested within another simulation batch.\\n    error EVC_SimulationBatchNested();\\n    /// @notice Auxiliary error to pass simulation batch results.\\n    error EVC_RevertedBatchResult(\\n        IEVC.BatchItemResult[] batchItemsResult,\\n        IEVC.StatusCheckResult[] accountsStatusResult,\\n        IEVC.StatusCheckResult[] vaultsStatusResult\\n    );\\n    /// @notice Panic error for when simulation does not behave as expected. Should never be observed.\\n    error EVC_BatchPanic();\\n    /// @notice Error for when an empty or undefined error is thrown.\\n    error EVC_EmptyError();\\n}\\n\"},\"lib/euler-vault-kit/lib/ethereum-vault-connector/src/EthereumVaultConnector.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport {Set, SetStorage} from \\\"./Set.sol\\\";\\nimport {Events} from \\\"./Events.sol\\\";\\nimport {Errors} from \\\"./Errors.sol\\\";\\nimport {ExecutionContext, EC} from \\\"./ExecutionContext.sol\\\";\\nimport {TransientStorage} from \\\"./TransientStorage.sol\\\";\\nimport {IEVC} from \\\"./interfaces/IEthereumVaultConnector.sol\\\";\\nimport {IVault} from \\\"./interfaces/IVault.sol\\\";\\nimport {IERC1271} from \\\"./interfaces/IERC1271.sol\\\";\\n\\n/// @title EthereumVaultConnector\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice This contract implements the Ethereum Vault Connector.\\ncontract EthereumVaultConnector is Events, Errors, TransientStorage, IEVC {\\n    using ExecutionContext for EC;\\n    using Set for SetStorage;\\n\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n    //                                       CONSTANTS                                           //\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Name of the Ethereum Vault Connector.\\n    string public constant name = \\\"Ethereum Vault Connector\\\";\\n\\n    uint160 internal constant ACCOUNT_ID_OFFSET = 8;\\n    bytes32 internal constant HASHED_NAME = keccak256(bytes(name));\\n\\n    bytes32 internal constant TYPE_HASH =\\n        keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\");\\n\\n    bytes32 internal constant PERMIT_TYPEHASH = keccak256(\\n        \\\"Permit(address signer,address sender,uint256 nonceNamespace,uint256 nonce,uint256 deadline,uint256 value,bytes data)\\\"\\n    );\\n\\n    uint256 internal immutable CACHED_CHAIN_ID;\\n    bytes32 internal immutable CACHED_DOMAIN_SEPARATOR;\\n\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n    //                                        STORAGE                                            //\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    // EVC implements controller isolation, meaning that unless in transient state, only one controller per account can\\n    // be enabled. However, this can lead to a suboptimal user experience. In the event a user wants to have multiple\\n    // controllers enabled, a separate wallet must be created and funded. Although there is nothing wrong with having\\n    // many accounts within the same wallet, this can be a bad experience. In order to improve on this, EVC supports\\n    // the concept of an owner that owns 256 accounts within EVC.\\n\\n    // Every Ethereum address has 256 accounts in the EVC (including the primary account - called the owner).\\n    // Each account has an account ID from 0-255, where 0 is the owner account's ID. In order to compute the account\\n    // addresses, the account ID is treated as a uint256 and XORed (exclusive ORed) with the Ethereum address.\\n    // In order to record the owner of a group of 256 accounts, the EVC uses a definition of an address prefix.\\n    // An address prefix is a part of an address having the first 19 bytes common with any of the 256 account\\n    // addresses belonging to the same group.\\n    // account/152 -> prefix/152\\n    // To get an address prefix for the account, it's enough to take the account address and right shift it by 8 bits.\\n\\n    // Yes, this reduces the security of addresses by 8 bits, but creating multiple addresses in the wallet also reduces\\n    // security: if somebody is trying to brute-force one of user's N>1 private keys, they have N times as many chances\\n    // of succeeding per guess. It has to be admitted that the EVC model is weaker because finding a private key for\\n    // an owner gives access to all accounts, but there is still a very comfortable security margin.\\n\\n    // Internal data structure that stores the addressPrefix owner and mode flags\\n    struct OwnerStorage {\\n        // The addressPrefix owner\\n        address owner;\\n        // Flag indicating if the addressPrefix is in lockdown mode\\n        bool isLockdownMode;\\n        // Flag indicating if the permit function is disabled for the addressPrefix\\n        bool isPermitDisabledMode;\\n    }\\n\\n    mapping(bytes19 addressPrefix => OwnerStorage) internal ownerLookup;\\n\\n    mapping(bytes19 addressPrefix => mapping(address operator => uint256 operatorBitField)) internal operatorLookup;\\n\\n    mapping(bytes19 addressPrefix => mapping(uint256 nonceNamespace => uint256 nonce)) internal nonceLookup;\\n\\n    mapping(address account => SetStorage) internal accountCollaterals;\\n\\n    mapping(address account => SetStorage) internal accountControllers;\\n\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n    //                                CONSTRUCTOR, FALLBACKS                                     //\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    constructor() {\\n        CACHED_CHAIN_ID = block.chainid;\\n        CACHED_DOMAIN_SEPARATOR = calculateDomainSeparator();\\n    }\\n\\n    /// @notice Fallback function to receive Ether.\\n    receive() external payable {\\n        // only allows to receive value when checks are deferred\\n        if (!executionContext.areChecksDeferred()) {\\n            revert EVC_NotAuthorized();\\n        }\\n    }\\n\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n    //                                       MODIFIERS                                           //\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice A modifier that allows only the address recorded as an owner of the address prefix to call the function.\\n    /// @dev The owner of an address prefix is an address that matches the address that has previously been recorded (or\\n    /// will be) as an owner in the ownerLookup.\\n    /// @param addressPrefix The address prefix for which it is checked whether the caller is the owner.\\n    modifier onlyOwner(bytes19 addressPrefix) {\\n        authenticateCaller({addressPrefix: addressPrefix, allowOperator: false, checkLockdownMode: false});\\n\\n        _;\\n    }\\n\\n    /// @notice A modifier that allows only the owner or an operator of the account to call the function.\\n    /// @dev The owner of an address prefix is an address that matches the address that has previously been recorded (or\\n    /// will be) as an owner in the ownerLookup. An operator of an account is an address that has been authorized by the\\n    /// owner of an account to perform operations on behalf of the owner.\\n    /// @param account The address of the account for which it is checked whether the caller is the owner or an\\n    /// operator.\\n    modifier onlyOwnerOrOperator(address account) {\\n        authenticateCaller({account: account, allowOperator: true, checkLockdownMode: true});\\n\\n        _;\\n    }\\n\\n    /// @notice A modifier checks whether msg.sender is the only controller for the account.\\n    /// @dev The controller cannot use permit function in conjunction with this modifier.\\n    modifier onlyController(address account) {\\n        {\\n            uint256 numOfControllers = accountControllers[account].numElements;\\n            address controller = accountControllers[account].firstElement;\\n\\n            if (numOfControllers != 1) {\\n                revert EVC_ControllerViolation();\\n            }\\n\\n            if (controller != msg.sender) {\\n                revert EVC_NotAuthorized();\\n            }\\n        }\\n\\n        _;\\n    }\\n\\n    /// @notice A modifier that verifies whether account or vault status checks are re-entered.\\n    modifier nonReentrantChecks() {\\n        if (executionContext.areChecksInProgress()) {\\n            revert EVC_ChecksReentrancy();\\n        }\\n\\n        _;\\n    }\\n\\n    /// @notice A modifier that verifies whether account or vault status checks are re-entered as well as checks for\\n    /// controlCollateral re-entrancy.\\n    modifier nonReentrantChecksAndControlCollateral() {\\n        {\\n            EC context = executionContext;\\n\\n            if (context.areChecksInProgress()) {\\n                revert EVC_ChecksReentrancy();\\n            }\\n\\n            if (context.isControlCollateralInProgress()) {\\n                revert EVC_ControlCollateralReentrancy();\\n            }\\n        }\\n\\n        _;\\n    }\\n\\n    /// @notice A modifier that verifies whether account or vault status checks are re-entered and sets the lock.\\n    /// @dev This modifier also clears the current account on behalf of which the operation is performed as it shouldn't\\n    /// be relied upon when the checks are in progress.\\n    modifier nonReentrantChecksAcquireLock() {\\n        EC contextCache = executionContext;\\n\\n        if (contextCache.areChecksInProgress()) {\\n            revert EVC_ChecksReentrancy();\\n        }\\n\\n        executionContext = contextCache.setChecksInProgress().setOnBehalfOfAccount(address(0));\\n\\n        _;\\n\\n        executionContext = contextCache;\\n    }\\n\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n    //                                   PUBLIC FUNCTIONS                                        //\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    // Execution internals\\n\\n    /// @inheritdoc IEVC\\n    function getRawExecutionContext() external view returns (uint256 context) {\\n        context = EC.unwrap(executionContext);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function getCurrentOnBehalfOfAccount(address controllerToCheck)\\n        external\\n        view\\n        returns (address onBehalfOfAccount, bool controllerEnabled)\\n    {\\n        onBehalfOfAccount = executionContext.getOnBehalfOfAccount();\\n\\n        // for safety, revert if no account has been authenticated\\n        if (onBehalfOfAccount == address(0)) {\\n            revert EVC_OnBehalfOfAccountNotAuthenticated();\\n        }\\n\\n        controllerEnabled =\\n            controllerToCheck == address(0) ? false : accountControllers[onBehalfOfAccount].contains(controllerToCheck);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function areChecksDeferred() external view returns (bool) {\\n        return executionContext.areChecksDeferred();\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function areChecksInProgress() external view returns (bool) {\\n        return executionContext.areChecksInProgress();\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function isControlCollateralInProgress() external view returns (bool) {\\n        return executionContext.isControlCollateralInProgress();\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function isOperatorAuthenticated() external view returns (bool) {\\n        return executionContext.isOperatorAuthenticated();\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function isSimulationInProgress() external view returns (bool) {\\n        return executionContext.isSimulationInProgress();\\n    }\\n\\n    // Owners and operators\\n\\n    /// @inheritdoc IEVC\\n    function haveCommonOwner(address account, address otherAccount) external pure returns (bool) {\\n        return haveCommonOwnerInternal(account, otherAccount);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function getAddressPrefix(address account) external pure returns (bytes19) {\\n        return getAddressPrefixInternal(account);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function getAccountOwner(address account) external view returns (address) {\\n        bytes19 addressPrefix = getAddressPrefixInternal(account);\\n        return ownerLookup[addressPrefix].owner;\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function isLockdownMode(bytes19 addressPrefix) external view returns (bool) {\\n        return ownerLookup[addressPrefix].isLockdownMode;\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function isPermitDisabledMode(bytes19 addressPrefix) external view returns (bool) {\\n        return ownerLookup[addressPrefix].isPermitDisabledMode;\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function getNonce(bytes19 addressPrefix, uint256 nonceNamespace) external view returns (uint256) {\\n        return nonceLookup[addressPrefix][nonceNamespace];\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function getOperator(bytes19 addressPrefix, address operator) external view returns (uint256) {\\n        return operatorLookup[addressPrefix][operator];\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function isAccountOperatorAuthorized(address account, address operator) external view returns (bool) {\\n        return isAccountOperatorAuthorizedInternal(account, operator);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function setLockdownMode(bytes19 addressPrefix, bool enabled) public payable virtual onlyOwner(addressPrefix) {\\n        if (ownerLookup[addressPrefix].isLockdownMode != enabled) {\\n            // to increase user security, it is prohibited to disable this mode within the self-call of the permit\\n            // function or within a checks-deferrable call. to disable this mode, the setLockdownMode function must be\\n            // called directly\\n            if (!enabled && (executionContext.areChecksDeferred() || inPermitSelfCall())) {\\n                revert EVC_NotAuthorized();\\n            }\\n\\n            ownerLookup[addressPrefix].isLockdownMode = enabled;\\n            emit LockdownModeStatus(addressPrefix, enabled);\\n        }\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function setPermitDisabledMode(\\n        bytes19 addressPrefix,\\n        bool enabled\\n    ) public payable virtual onlyOwner(addressPrefix) {\\n        if (ownerLookup[addressPrefix].isPermitDisabledMode != enabled) {\\n            // to increase user security, it is prohibited to disable this mode within the self-call of the permit\\n            // function (verified in the permit function) or within a checks-deferrable call. to disable this mode the\\n            // setPermitDisabledMode function must be called directly\\n            if (!enabled && executionContext.areChecksDeferred()) {\\n                revert EVC_NotAuthorized();\\n            }\\n\\n            ownerLookup[addressPrefix].isPermitDisabledMode = enabled;\\n            emit PermitDisabledModeStatus(addressPrefix, enabled);\\n        }\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function setNonce(\\n        bytes19 addressPrefix,\\n        uint256 nonceNamespace,\\n        uint256 nonce\\n    ) public payable virtual onlyOwner(addressPrefix) {\\n        uint256 currentNonce = nonceLookup[addressPrefix][nonceNamespace];\\n\\n        if (currentNonce >= nonce) {\\n            revert EVC_InvalidNonce();\\n        }\\n\\n        nonceLookup[addressPrefix][nonceNamespace] = nonce;\\n\\n        emit NonceStatus(addressPrefix, nonceNamespace, currentNonce, nonce);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    /// @dev Uses authenticateCaller() function instead of onlyOwner() modifier to authenticate and get the caller\\n    /// address at once.\\n    function setOperator(bytes19 addressPrefix, address operator, uint256 operatorBitField) public payable virtual {\\n        address msgSender =\\n            authenticateCaller({addressPrefix: addressPrefix, allowOperator: false, checkLockdownMode: false});\\n\\n        // the operator can neither be the EVC nor can be one of 256 accounts of the owner\\n        if (operator == address(this) || haveCommonOwnerInternal(msgSender, operator)) {\\n            revert EVC_InvalidAddress();\\n        }\\n\\n        if (operatorLookup[addressPrefix][operator] == operatorBitField) {\\n            revert EVC_InvalidOperatorStatus();\\n        } else {\\n            operatorLookup[addressPrefix][operator] = operatorBitField;\\n\\n            emit OperatorStatus(addressPrefix, operator, operatorBitField);\\n        }\\n    }\\n\\n    /// @inheritdoc IEVC\\n    /// @dev Uses authenticateCaller() function instead of onlyOwnerOrOperator() modifier to authenticate and get the\\n    /// caller address at once.\\n    function setAccountOperator(address account, address operator, bool authorized) public payable virtual {\\n        address msgSender = authenticateCaller({account: account, allowOperator: true, checkLockdownMode: false});\\n        bytes19 addressPrefix = getAddressPrefixInternal(account);\\n\\n        // if the account and the caller have a common owner, the caller must be the owner. if the account and the\\n        // caller don't have a common owner, the caller must be an operator and the owner address is taken from the\\n        // storage. the caller authentication above guarantees that the account owner is already registered hence\\n        // non-zero\\n        address owner = haveCommonOwnerInternal(account, msgSender) ? msgSender : ownerLookup[addressPrefix].owner;\\n\\n        // if it's an operator calling, it can only act for itself and must not be able to change other operators status\\n        if (owner != msgSender && operator != msgSender) {\\n            revert EVC_NotAuthorized();\\n        }\\n\\n        // the operator can neither be the EVC nor can be one of 256 accounts of the owner\\n        if (operator == address(this) || haveCommonOwnerInternal(owner, operator)) {\\n            revert EVC_InvalidAddress();\\n        }\\n\\n        // The bitMask defines which accounts the operator is authorized for. The bitMask is created from the account\\n        // number which is a number up to 2^8 in binary, or 256. 1 << (uint160(owner) ^ uint160(account)) transforms\\n        // that number in an 256-position binary array like 0...010...0, marking the account positionally in a uint256.\\n        uint256 bitMask = 1 << (uint160(owner) ^ uint160(account));\\n\\n        // The operatorBitField is a 256-position binary array, where each 1 signals by position the account that the\\n        // operator is authorized for.\\n        uint256 oldOperatorBitField = operatorLookup[addressPrefix][operator];\\n        uint256 newOperatorBitField = authorized ? oldOperatorBitField | bitMask : oldOperatorBitField & ~bitMask;\\n\\n        if (oldOperatorBitField == newOperatorBitField) {\\n            revert EVC_InvalidOperatorStatus();\\n        } else {\\n            operatorLookup[addressPrefix][operator] = newOperatorBitField;\\n\\n            emit OperatorStatus(addressPrefix, operator, newOperatorBitField);\\n        }\\n    }\\n\\n    // Collaterals management\\n\\n    /// @inheritdoc IEVC\\n    function getCollaterals(address account) external view returns (address[] memory) {\\n        return accountCollaterals[account].get();\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function isCollateralEnabled(address account, address vault) external view returns (bool) {\\n        return accountCollaterals[account].contains(vault);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function enableCollateral(\\n        address account,\\n        address vault\\n    ) public payable virtual nonReentrantChecksAndControlCollateral onlyOwnerOrOperator(account) {\\n        if (vault == address(this)) revert EVC_InvalidAddress();\\n\\n        if (accountCollaterals[account].insert(vault)) {\\n            emit CollateralStatus(account, vault, true);\\n        }\\n        requireAccountStatusCheck(account);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function disableCollateral(\\n        address account,\\n        address vault\\n    ) public payable virtual nonReentrantChecksAndControlCollateral onlyOwnerOrOperator(account) {\\n        if (accountCollaterals[account].remove(vault)) {\\n            emit CollateralStatus(account, vault, false);\\n        }\\n        requireAccountStatusCheck(account);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function reorderCollaterals(\\n        address account,\\n        uint8 index1,\\n        uint8 index2\\n    ) public payable virtual nonReentrantChecksAndControlCollateral onlyOwnerOrOperator(account) {\\n        accountCollaterals[account].reorder(index1, index2);\\n        requireAccountStatusCheck(account);\\n    }\\n\\n    // Controllers management\\n\\n    /// @inheritdoc IEVC\\n    function getControllers(address account) external view returns (address[] memory) {\\n        return accountControllers[account].get();\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function isControllerEnabled(address account, address vault) external view returns (bool) {\\n        return accountControllers[account].contains(vault);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function enableController(\\n        address account,\\n        address vault\\n    ) public payable virtual nonReentrantChecksAndControlCollateral onlyOwnerOrOperator(account) {\\n        if (vault == address(this)) revert EVC_InvalidAddress();\\n\\n        if (accountControllers[account].insert(vault)) {\\n            emit ControllerStatus(account, vault, true);\\n        }\\n        requireAccountStatusCheck(account);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function disableController(address account) public payable virtual nonReentrantChecksAndControlCollateral {\\n        if (accountControllers[account].remove(msg.sender)) {\\n            emit ControllerStatus(account, msg.sender, false);\\n        }\\n        requireAccountStatusCheck(account);\\n    }\\n\\n    // Permit\\n\\n    /// @inheritdoc IEVC\\n    function permit(\\n        address signer,\\n        address sender,\\n        uint256 nonceNamespace,\\n        uint256 nonce,\\n        uint256 deadline,\\n        uint256 value,\\n        bytes calldata data,\\n        bytes calldata signature\\n    ) public payable virtual nonReentrantChecksAndControlCollateral {\\n        // cannot be called within the self-call of the permit function; can occur for nested calls.\\n        // the permit function can be called only by the specified sender, unless address zero is specified in which\\n        // case anyone can call it\\n        if (inPermitSelfCall() || (sender != address(0) && sender != msg.sender)) {\\n            revert EVC_NotAuthorized();\\n        }\\n\\n        if (signer == address(0) || !isSignerValid(signer)) {\\n            revert EVC_InvalidAddress();\\n        }\\n\\n        bytes19 addressPrefix = getAddressPrefixInternal(signer);\\n\\n        if (ownerLookup[addressPrefix].isPermitDisabledMode) {\\n            revert EVC_PermitDisabledMode();\\n        }\\n\\n        {\\n            uint256 currentNonce = nonceLookup[addressPrefix][nonceNamespace];\\n\\n            if (currentNonce == type(uint256).max || currentNonce != nonce) {\\n                revert EVC_InvalidNonce();\\n            }\\n        }\\n\\n        if (deadline < block.timestamp) {\\n            revert EVC_InvalidTimestamp();\\n        }\\n\\n        if (data.length == 0) {\\n            revert EVC_InvalidData();\\n        }\\n\\n        bytes32 permitHash = getPermitHash(signer, sender, nonceNamespace, nonce, deadline, value, data);\\n\\n        if (\\n            signer != recoverECDSASigner(permitHash, signature)\\n                && !isValidERC1271Signature(signer, permitHash, signature)\\n        ) {\\n            revert EVC_NotAuthorized();\\n        }\\n\\n        unchecked {\\n            nonceLookup[addressPrefix][nonceNamespace] = nonce + 1;\\n        }\\n\\n        emit NonceUsed(addressPrefix, nonceNamespace, nonce);\\n\\n        // EVC address becomes the msg.sender for the duration this self-call, no authentication is required here.\\n        // the signer will be later on authenticated as per data, depending on the functions that will be called\\n        (bool success, bytes memory result) = callWithContextInternal(address(this), signer, value, data);\\n\\n        if (!success) revertBytes(result);\\n    }\\n\\n    // Calls forwarding\\n\\n    /// @inheritdoc IEVC\\n    function call(\\n        address targetContract,\\n        address onBehalfOfAccount,\\n        uint256 value,\\n        bytes calldata data\\n    ) public payable virtual nonReentrantChecksAndControlCollateral returns (bytes memory result) {\\n        EC contextCache = executionContext;\\n        executionContext = contextCache.setChecksDeferred();\\n\\n        bool success;\\n        (success, result) = callWithAuthenticationInternal(targetContract, onBehalfOfAccount, value, data);\\n\\n        if (!success) revertBytes(result);\\n\\n        restoreExecutionContext(contextCache);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function controlCollateral(\\n        address targetCollateral,\\n        address onBehalfOfAccount,\\n        uint256 value,\\n        bytes calldata data\\n    )\\n        public\\n        payable\\n        virtual\\n        nonReentrantChecksAndControlCollateral\\n        onlyController(onBehalfOfAccount)\\n        returns (bytes memory result)\\n    {\\n        if (!accountCollaterals[onBehalfOfAccount].contains(targetCollateral)) {\\n            revert EVC_NotAuthorized();\\n        }\\n\\n        EC contextCache = executionContext;\\n        executionContext = contextCache.setChecksDeferred().setControlCollateralInProgress();\\n\\n        bool success;\\n        (success, result) = callWithContextInternal(targetCollateral, onBehalfOfAccount, value, data);\\n\\n        if (!success) revertBytes(result);\\n\\n        restoreExecutionContext(contextCache);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function batch(BatchItem[] calldata items) public payable virtual nonReentrantChecksAndControlCollateral {\\n        EC contextCache = executionContext;\\n        executionContext = contextCache.setChecksDeferred();\\n\\n        uint256 length = items.length;\\n        for (uint256 i; i < length; ++i) {\\n            BatchItem calldata item = items[i];\\n            (bool success, bytes memory result) =\\n                callWithAuthenticationInternal(item.targetContract, item.onBehalfOfAccount, item.value, item.data);\\n\\n            if (!success) revertBytes(result);\\n        }\\n\\n        restoreExecutionContext(contextCache);\\n    }\\n\\n    // Simulations\\n\\n    /// @inheritdoc IEVC\\n    function batchRevert(BatchItem[] calldata items) public payable virtual nonReentrantChecksAndControlCollateral {\\n        BatchItemResult[] memory batchItemsResult;\\n        StatusCheckResult[] memory accountsStatusCheckResult;\\n        StatusCheckResult[] memory vaultsStatusCheckResult;\\n\\n        EC contextCache = executionContext;\\n\\n        if (contextCache.areChecksDeferred()) {\\n            revert EVC_SimulationBatchNested();\\n        }\\n\\n        executionContext = contextCache.setChecksDeferred().setSimulationInProgress();\\n\\n        uint256 length = items.length;\\n        batchItemsResult = new BatchItemResult[](length);\\n\\n        for (uint256 i; i < length; ++i) {\\n            BatchItem calldata item = items[i];\\n            (batchItemsResult[i].success, batchItemsResult[i].result) =\\n                callWithAuthenticationInternal(item.targetContract, item.onBehalfOfAccount, item.value, item.data);\\n        }\\n\\n        executionContext = contextCache.setChecksInProgress().setOnBehalfOfAccount(address(0));\\n\\n        accountsStatusCheckResult = checkStatusAllWithResult(SetType.Account);\\n        vaultsStatusCheckResult = checkStatusAllWithResult(SetType.Vault);\\n\\n        executionContext = contextCache;\\n\\n        revert EVC_RevertedBatchResult(batchItemsResult, accountsStatusCheckResult, vaultsStatusCheckResult);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function batchSimulation(BatchItem[] calldata items)\\n        external\\n        payable\\n        virtual\\n        returns (\\n            BatchItemResult[] memory batchItemsResult,\\n            StatusCheckResult[] memory accountsStatusCheckResult,\\n            StatusCheckResult[] memory vaultsStatusCheckResult\\n        )\\n    {\\n        (bool success, bytes memory result) = address(this).delegatecall(abi.encodeCall(this.batchRevert, items));\\n\\n        if (success) {\\n            revert EVC_BatchPanic();\\n        } else if (result.length < 4 || bytes4(result) != EVC_RevertedBatchResult.selector) {\\n            revertBytes(result);\\n        }\\n\\n        assembly {\\n            let length := mload(result)\\n            // skip 4-byte EVC_RevertedBatchResult selector\\n            result := add(result, 4)\\n            // write new array length = original length - 4-byte selector\\n            // cannot underflow as we require result.length >= 4 above\\n            mstore(result, sub(length, 4))\\n        }\\n\\n        (batchItemsResult, accountsStatusCheckResult, vaultsStatusCheckResult) =\\n            abi.decode(result, (BatchItemResult[], StatusCheckResult[], StatusCheckResult[]));\\n    }\\n\\n    // Account Status Check\\n\\n    /// @inheritdoc IEVC\\n    function getLastAccountStatusCheckTimestamp(address account) external view nonReentrantChecks returns (uint256) {\\n        return accountControllers[account].getMetadata();\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function isAccountStatusCheckDeferred(address account) external view nonReentrantChecks returns (bool) {\\n        return accountStatusChecks.contains(account);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function requireAccountStatusCheck(address account) public payable virtual {\\n        if (executionContext.areChecksDeferred()) {\\n            accountStatusChecks.insert(account);\\n        } else {\\n            requireAccountStatusCheckInternalNonReentrantChecks(account);\\n        }\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function forgiveAccountStatusCheck(address account)\\n        public\\n        payable\\n        virtual\\n        nonReentrantChecksAcquireLock\\n        onlyController(account)\\n    {\\n        accountStatusChecks.remove(account);\\n    }\\n\\n    // Vault Status Check\\n\\n    /// @inheritdoc IEVC\\n    function isVaultStatusCheckDeferred(address vault) external view nonReentrantChecks returns (bool) {\\n        return vaultStatusChecks.contains(vault);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function requireVaultStatusCheck() public payable virtual {\\n        if (executionContext.areChecksDeferred()) {\\n            vaultStatusChecks.insert(msg.sender);\\n        } else {\\n            requireVaultStatusCheckInternalNonReentrantChecks(msg.sender);\\n        }\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function forgiveVaultStatusCheck() public payable virtual nonReentrantChecksAcquireLock {\\n        vaultStatusChecks.remove(msg.sender);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function requireAccountAndVaultStatusCheck(address account) public payable virtual {\\n        if (executionContext.areChecksDeferred()) {\\n            accountStatusChecks.insert(account);\\n            vaultStatusChecks.insert(msg.sender);\\n        } else {\\n            requireAccountStatusCheckInternalNonReentrantChecks(account);\\n            requireVaultStatusCheckInternalNonReentrantChecks(msg.sender);\\n        }\\n    }\\n\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n    //                                  INTERNAL FUNCTIONS                                       //\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Authenticates the caller of a function.\\n    /// @dev This function checks if the caller is the owner or an authorized operator of the account, and if the\\n    /// account is not in lockdown mode.\\n    /// @param account The account address to authenticate the caller against.\\n    /// @param allowOperator A boolean indicating if operators are allowed to authenticate as the caller.\\n    /// @param checkLockdownMode A boolean indicating if the function should check for lockdown mode on the account.\\n    /// @return The address of the authenticated caller.\\n    function authenticateCaller(\\n        address account,\\n        bool allowOperator,\\n        bool checkLockdownMode\\n    ) internal virtual returns (address) {\\n        bytes19 addressPrefix = getAddressPrefixInternal(account);\\n        address owner = ownerLookup[addressPrefix].owner;\\n        bool lockdownMode = ownerLookup[addressPrefix].isLockdownMode;\\n        address msgSender = _msgSender();\\n        bool authenticated = false;\\n\\n        // check if the caller is the owner of the account\\n        if (haveCommonOwnerInternal(account, msgSender)) {\\n            // if the owner is not registered, register it\\n            if (owner == address(0)) {\\n                ownerLookup[addressPrefix].owner = owner = msgSender;\\n                emit OwnerRegistered(addressPrefix, msgSender);\\n                authenticated = true;\\n            } else if (owner == msgSender) {\\n                authenticated = true;\\n            }\\n        }\\n\\n        // if the caller is not the owner, check if it is an operator if operators are allowed\\n        if (!authenticated && allowOperator && isAccountOperatorAuthorizedInternal(account, msgSender)) {\\n            authenticated = true;\\n        }\\n\\n        // if the authenticated account is non-owner, prevent its account from being a smart contract\\n        if (authenticated && owner != account && account.code.length != 0) {\\n            authenticated = false;\\n        }\\n\\n        // must revert if neither the owner nor the operator were authenticated\\n        if (!authenticated) {\\n            revert EVC_NotAuthorized();\\n        }\\n\\n        // revert if the account is in lockdown mode unless the lockdown mode is not being checked\\n        if (checkLockdownMode && lockdownMode) {\\n            revert EVC_LockdownMode();\\n        }\\n\\n        return msgSender;\\n    }\\n\\n    /// @notice Authenticates the caller of a function.\\n    /// @dev This function either passes the address prefix owner address, if the address prefix owner is already\\n    /// registered, or converts the bytes19 address prefix into an account address which will belong to the owner when\\n    /// it's finally registered.\\n    /// @param addressPrefix The bytes19 address prefix to authenticate the caller against.\\n    /// @param allowOperator A boolean indicating if operators are allowed to authenticate as the caller.\\n    /// @param checkLockdownMode A boolean indicating if the function should check for lockdown mode on the account.\\n    /// @return The address of the authenticated caller.\\n    function authenticateCaller(\\n        bytes19 addressPrefix,\\n        bool allowOperator,\\n        bool checkLockdownMode\\n    ) internal virtual returns (address) {\\n        address owner = ownerLookup[addressPrefix].owner;\\n\\n        return authenticateCaller({\\n            account: owner == address(0) ? address(uint160(uint152(addressPrefix)) << ACCOUNT_ID_OFFSET) : owner,\\n            allowOperator: allowOperator,\\n            checkLockdownMode: checkLockdownMode\\n        });\\n    }\\n\\n    /// @notice Internal function to make a call to a target contract with a specific context.\\n    /// @dev This function sets the execution context for the duration of the call.\\n    /// @param targetContract The contract address to call.\\n    /// @param onBehalfOfAccount The account address on behalf of which the call is made.\\n    /// @param value The amount of value to send with the call.\\n    /// @param data The calldata to send with the call.\\n    function callWithContextInternal(\\n        address targetContract,\\n        address onBehalfOfAccount,\\n        uint256 value,\\n        bytes calldata data\\n    ) internal virtual returns (bool success, bytes memory result) {\\n        if (value == type(uint256).max) {\\n            value = address(this).balance;\\n        } else if (value > address(this).balance) {\\n            revert EVC_InvalidValue();\\n        }\\n\\n        EC contextCache = executionContext;\\n        address msgSender = _msgSender();\\n\\n        // set the onBehalfOfAccount in the execution context for the duration of the external call.\\n        // considering that the operatorAuthenticated is only meant to be observable by external\\n        // contracts, it is sufficient to set it here rather than in the authentication function.\\n        // apart from the usual scenario (when an owner operates on behalf of its account),\\n        // the operatorAuthenticated should be cleared when about to execute the permit self-call, when\\n        // target contract is equal to the msg.sender in call() and batch(), or when the controlCollateral is in\\n        // progress (in which case the operatorAuthenticated is not relevant)\\n        if (\\n            haveCommonOwnerInternal(onBehalfOfAccount, msgSender) || targetContract == msg.sender\\n                || targetContract == address(this) || contextCache.isControlCollateralInProgress()\\n        ) {\\n            executionContext = contextCache.setOnBehalfOfAccount(onBehalfOfAccount).clearOperatorAuthenticated();\\n        } else {\\n            executionContext = contextCache.setOnBehalfOfAccount(onBehalfOfAccount).setOperatorAuthenticated();\\n        }\\n\\n        emit CallWithContext(\\n            msgSender, getAddressPrefixInternal(onBehalfOfAccount), onBehalfOfAccount, targetContract, bytes4(data)\\n        );\\n\\n        (success, result) = targetContract.call{value: value}(data);\\n\\n        executionContext = contextCache;\\n    }\\n\\n    /// @notice Internal function to call a target contract with necessary authentication.\\n    /// @dev This function decides whether to use delegatecall or a regular call based on the target contract.\\n    /// If the target contract is this contract, it uses delegatecall to preserve msg.sender for authentication.\\n    /// Otherwise, it authenticates the caller if needed and proceeds with a regular call.\\n    /// @param targetContract The contract address to call.\\n    /// @param onBehalfOfAccount The account address on behalf of which the call is made.\\n    /// @param value The amount of value to send with the call.\\n    /// @param data The calldata to send with the call.\\n    /// @return success A boolean indicating if the call was successful.\\n    /// @return result The bytes returned from the call.\\n    function callWithAuthenticationInternal(\\n        address targetContract,\\n        address onBehalfOfAccount,\\n        uint256 value,\\n        bytes calldata data\\n    ) internal virtual returns (bool success, bytes memory result) {\\n        if (targetContract == address(this)) {\\n            if (onBehalfOfAccount != address(0)) {\\n                revert EVC_InvalidAddress();\\n            }\\n\\n            if (value != 0) {\\n                revert EVC_InvalidValue();\\n            }\\n\\n            // delegatecall is used here to preserve msg.sender in order to be able to perform authentication\\n            (success, result) = address(this).delegatecall(data);\\n        } else {\\n            // when the target contract is equal to the msg.sender, both in call() and batch(), authentication is not\\n            // required\\n            if (targetContract != msg.sender) {\\n                authenticateCaller({account: onBehalfOfAccount, allowOperator: true, checkLockdownMode: true});\\n            }\\n\\n            (success, result) = callWithContextInternal(targetContract, onBehalfOfAccount, value, data);\\n        }\\n    }\\n\\n    /// @notice Restores the execution context from a cached state.\\n    /// @dev This function restores the execution context to a previously cached state, performing necessary status\\n    /// checks if they are no longer deferred. If checks are no longer deferred, it sets the execution context to\\n    /// indicate checks are in progress and clears the 'on behalf of' account. It then performs status checks for both\\n    /// accounts and vaults before restoring the execution context to the cached state.\\n    /// @param contextCache The cached execution context to restore from.\\n    function restoreExecutionContext(EC contextCache) internal virtual {\\n        if (!contextCache.areChecksDeferred()) {\\n            executionContext = contextCache.setChecksInProgress().setOnBehalfOfAccount(address(0));\\n\\n            checkStatusAll(SetType.Account);\\n            checkStatusAll(SetType.Vault);\\n        }\\n\\n        executionContext = contextCache;\\n    }\\n\\n    /// @notice Checks the status of an account internally.\\n    /// @dev This function first checks the number of controllers for the account. If there are no controllers enabled,\\n    /// it returns true immediately, indicating the account status is valid without further checks. If there is more\\n    /// than one controller, it reverts with an EVC_ControllerViolation error. For a single controller, it proceeds to\\n    /// call the controller to check the account status.\\n    /// @param account The account address to check the status for.\\n    /// @return isValid A boolean indicating if the account status is valid.\\n    /// @return result The bytes returned from the controller call, indicating the account status.\\n    function checkAccountStatusInternal(address account) internal virtual returns (bool isValid, bytes memory result) {\\n        SetStorage storage accountControllersStorage = accountControllers[account];\\n        uint256 numOfControllers = accountControllersStorage.numElements;\\n        address controller = accountControllersStorage.firstElement;\\n        uint8 stamp = accountControllersStorage.stamp;\\n\\n        if (numOfControllers == 0) return (true, \\\"\\\");\\n        else if (numOfControllers > 1) return (false, abi.encodeWithSelector(EVC_ControllerViolation.selector));\\n\\n        bool success;\\n        (success, result) = controller.staticcall(\\n            abi.encodeCall(IVault.checkAccountStatus, (account, accountCollaterals[account].get()))\\n        );\\n\\n        isValid = success && result.length == 32\\n            && abi.decode(result, (bytes32)) == bytes32(IVault.checkAccountStatus.selector);\\n\\n        if (isValid) {\\n            accountControllersStorage.numElements = uint8(numOfControllers);\\n            accountControllersStorage.firstElement = controller;\\n            accountControllersStorage.metadata = uint80(block.timestamp);\\n            accountControllersStorage.stamp = stamp;\\n        }\\n\\n        emit AccountStatusCheck(account, controller);\\n    }\\n\\n    function requireAccountStatusCheckInternal(address account) internal virtual {\\n        (bool isValid, bytes memory result) = checkAccountStatusInternal(account);\\n\\n        if (!isValid) {\\n            revertBytes(result);\\n        }\\n    }\\n\\n    function requireAccountStatusCheckInternalNonReentrantChecks(address account)\\n        internal\\n        virtual\\n        nonReentrantChecksAcquireLock\\n    {\\n        requireAccountStatusCheckInternal(account);\\n    }\\n\\n    /// @notice Checks the status of a vault internally.\\n    /// @dev This function makes an external call to the vault to check its status.\\n    /// @param vault The address of the vault to check the status for.\\n    /// @return isValid A boolean indicating if the vault status is valid.\\n    /// @return result The bytes returned from the vault call, indicating the vault status.\\n    function checkVaultStatusInternal(address vault) internal virtual returns (bool isValid, bytes memory result) {\\n        bool success;\\n        (success, result) = vault.call(abi.encodeCall(IVault.checkVaultStatus, ()));\\n\\n        isValid =\\n            success && result.length == 32 && abi.decode(result, (bytes32)) == bytes32(IVault.checkVaultStatus.selector);\\n\\n        emit VaultStatusCheck(vault);\\n    }\\n\\n    function requireVaultStatusCheckInternal(address vault) internal virtual {\\n        (bool isValid, bytes memory result) = checkVaultStatusInternal(vault);\\n\\n        if (!isValid) {\\n            revertBytes(result);\\n        }\\n    }\\n\\n    function requireVaultStatusCheckInternalNonReentrantChecks(address vault)\\n        internal\\n        virtual\\n        nonReentrantChecksAcquireLock\\n    {\\n        requireVaultStatusCheckInternal(vault);\\n    }\\n\\n    /// @notice Checks the status of all entities in a set, either accounts or vaults, and clears the checks.\\n    /// @dev Iterates over either accountStatusChecks or vaultStatusChecks based on the setType and performs status\\n    /// checks.\\n    /// Clears the checks while performing them.\\n    /// @param setType The type of set to perform the status checks on, either accounts or vaults.\\n    function checkStatusAll(SetType setType) internal virtual {\\n        setType == SetType.Account\\n            ? accountStatusChecks.forEachAndClear(requireAccountStatusCheckInternal)\\n            : vaultStatusChecks.forEachAndClear(requireVaultStatusCheckInternal);\\n    }\\n\\n    function checkStatusAllWithResult(SetType setType)\\n        internal\\n        virtual\\n        returns (StatusCheckResult[] memory checksResult)\\n    {\\n        bytes[] memory callbackResult = setType == SetType.Account\\n            ? accountStatusChecks.forEachAndClearWithResult(checkAccountStatusInternal)\\n            : vaultStatusChecks.forEachAndClearWithResult(checkVaultStatusInternal);\\n\\n        uint256 length = callbackResult.length;\\n        checksResult = new StatusCheckResult[](length);\\n\\n        for (uint256 i; i < length; ++i) {\\n            (address checkedAddress, bool isValid, bytes memory result) =\\n                abi.decode(callbackResult[i], (address, bool, bytes));\\n            checksResult[i] = StatusCheckResult({checkedAddress: checkedAddress, isValid: isValid, result: result});\\n        }\\n    }\\n\\n    // Permit-related functions\\n\\n    /// @notice Determines if the signer address is valid.\\n    /// @dev It's important to revisit this logic when deploying on chains other than the Ethereum mainnet. If new\\n    /// precompiles had been added to the Ethereum mainnet, the current implementation of the function would not be\\n    /// future-proof and would need to be updated.\\n    /// @param signer The address of the signer to validate.\\n    /// @return bool Returns true if the signer is valid, false otherwise.\\n    function isSignerValid(address signer) internal pure virtual returns (bool) {\\n        // not valid if the signer address falls into any of the precompiles/predeploys\\n        // addresses space (depends on the chain ID).\\n        return !haveCommonOwnerInternal(signer, address(0));\\n    }\\n\\n    /// @notice Computes the permit hash for a given set of parameters.\\n    /// @dev This function generates a permit hash using EIP712 typed data signing.\\n    /// @param signer The address of the signer.\\n    /// @param nonceNamespace The namespace of the nonce.\\n    /// @param nonce The nonce value, ensuring permits are used once.\\n    /// @param deadline The time until when the permit is valid.\\n    /// @param value The value associated with the permit.\\n    /// @param data Calldata associated with the permit.\\n    /// @return permitHash The computed permit hash.\\n    function getPermitHash(\\n        address signer,\\n        address sender,\\n        uint256 nonceNamespace,\\n        uint256 nonce,\\n        uint256 deadline,\\n        uint256 value,\\n        bytes calldata data\\n    ) internal view returns (bytes32 permitHash) {\\n        bytes32 domainSeparator =\\n            block.chainid == CACHED_CHAIN_ID ? CACHED_DOMAIN_SEPARATOR : calculateDomainSeparator();\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(PERMIT_TYPEHASH, signer, sender, nonceNamespace, nonce, deadline, value, keccak256(data))\\n        );\\n\\n        // This code overwrites the two most significant bytes of the free memory pointer,\\n        // and restores them to 0 after\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, \\\"\\\\x19\\\\x01\\\")\\n            mstore(0x02, domainSeparator)\\n            mstore(0x22, structHash)\\n            permitHash := keccak256(0x00, 0x42)\\n            mstore(0x22, 0)\\n        }\\n    }\\n\\n    /// @notice Recovers the signer address from a hash and a signature.\\n    /// Based on:\\n    /// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol\\n    /// Note that the function returns zero address if the signature is invalid hence the result always has to be\\n    /// checked against address zero.\\n    /// @param hash The hash of the signed data.\\n    /// @param signature The signature to recover the signer from.\\n    /// @return signer The address of the signer, or the zero address if signature recovery fails.\\n    function recoverECDSASigner(bytes32 hash, bytes memory signature) internal pure returns (address signer) {\\n        if (signature.length != 65) return address(0);\\n\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // ecrecover takes the signature parameters, and the only way to get them\\n        // currently is to use assembly.\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return address(0);\\n        }\\n\\n        // return the signer address (note that it might be zero address)\\n        signer = ecrecover(hash, v, r, s);\\n    }\\n\\n    /// @notice Checks if a given signature is valid according to ERC-1271 standard.\\n    /// @dev This function is based on the implementation found in OpenZeppelin's SignatureChecker.\\n    /// See:\\n    /// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/SignatureChecker.sol\\n    /// It performs a static call to the signer's address with the signature data and checks if the returned value\\n    /// matches the expected valid signature selector.\\n    /// @param signer The address of the signer to validate the signature against.\\n    /// @param hash The hash of the data that was signed.\\n    /// @param signature The signature to validate.\\n    /// @return isValid True if the signature is valid according to ERC-1271, false otherwise.\\n    function isValidERC1271Signature(\\n        address signer,\\n        bytes32 hash,\\n        bytes memory signature\\n    ) internal view returns (bool isValid) {\\n        if (signer.code.length == 0) return false;\\n\\n        (bool success, bytes memory result) =\\n            signer.staticcall(abi.encodeCall(IERC1271.isValidSignature, (hash, signature)));\\n\\n        isValid = success && result.length == 32\\n            && abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector);\\n    }\\n\\n    /// @notice Calculates the EIP-712 domain separator for the contract.\\n    /// @return The calculated EIP-712 domain separator as a bytes32 value.\\n    function calculateDomainSeparator() internal view returns (bytes32) {\\n        return keccak256(abi.encode(TYPE_HASH, HASHED_NAME, block.chainid, address(this)));\\n    }\\n\\n    // Auxiliary functions\\n\\n    /// @notice Returns the message sender's address.\\n    /// @dev In the context of a permit self-call, it returns the account on behalf of which the call is made.\\n    /// Otherwise, it returns `msg.sender`.\\n    /// @return The address of the message sender or the account on behalf of which the call is made.\\n    function _msgSender() internal view virtual returns (address) {\\n        return inPermitSelfCall() ? executionContext.getOnBehalfOfAccount() : msg.sender;\\n    }\\n\\n    /// @notice Checks if the contract is in the context of a permit self-call.\\n    /// @dev EVC can only be `msg.sender` during the self-call in the permit function.\\n    /// @return True if the current call is a self-call within the permit function, false otherwise.\\n    function inPermitSelfCall() internal view returns (bool) {\\n        return address(this) == msg.sender;\\n    }\\n\\n    /// @notice Determines if two accounts have a common owner by comparing their address prefixes.\\n    /// @param account The first account address to compare.\\n    /// @param otherAccount The second account address to compare.\\n    /// @return result True if the accounts have a common owner, false otherwise.\\n    function haveCommonOwnerInternal(address account, address otherAccount) internal pure returns (bool result) {\\n        assembly {\\n            result := lt(xor(account, otherAccount), 0x100)\\n        }\\n    }\\n\\n    /// @notice Computes the address prefix for a given account address.\\n    /// @dev The address prefix is derived by right-shifting the account address by 8 bits which effectively reduces the\\n    /// address size to 19 bytes.\\n    /// @param account The account address to compute the prefix for.\\n    /// @return The computed address prefix as a bytes19 value.\\n    function getAddressPrefixInternal(address account) internal pure returns (bytes19) {\\n        return bytes19(uint152(uint160(account) >> ACCOUNT_ID_OFFSET));\\n    }\\n\\n    /// @notice Checks if an operator is authorized for a specific account.\\n    /// @dev Determines operator authorization by checking if the operator's bit is set in the operator's bit field for\\n    /// the account's address prefix. If the owner is not registered (address(0)), it implies the operator cannot be\\n    /// authorized, hence returns false. The bitMask is calculated by shifting 1 left by the XOR of the owner's and\\n    /// account's address, effectively checking the operator's authorization for the specific account.\\n    /// @param account The account address to check the operator authorization for.\\n    /// @param operator The operator address to check authorization status.\\n    /// @return isAuthorized True if the operator is authorized for the account, false otherwise.\\n    function isAccountOperatorAuthorizedInternal(\\n        address account,\\n        address operator\\n    ) internal view returns (bool isAuthorized) {\\n        bytes19 addressPrefix = getAddressPrefixInternal(account);\\n        address owner = ownerLookup[addressPrefix].owner;\\n\\n        // if the owner is not registered yet, it means that the operator couldn't have been authorized\\n        if (owner == address(0)) return false;\\n\\n        // The bitMask defines which accounts the operator is authorized for. The bitMask is created from the account\\n        // number which is a number up to 2^8 in binary, or 256. 1 << (uint160(owner) ^ uint160(account)) transforms\\n        // that number in an 256-position binary array like 0...010...0, marking the account positionally in a uint256.\\n        uint256 bitMask = 1 << (uint160(owner) ^ uint160(account));\\n\\n        return operatorLookup[addressPrefix][operator] & bitMask != 0;\\n    }\\n\\n    /// @notice Reverts the transaction with a custom error message if provided, otherwise reverts with a generic empty\\n    /// error.\\n    /// @param errMsg The custom error message to revert the transaction with.\\n    function revertBytes(bytes memory errMsg) internal pure {\\n        if (errMsg.length != 0) {\\n            assembly {\\n                revert(add(32, errMsg), mload(errMsg))\\n            }\\n        }\\n        revert EVC_EmptyError();\\n    }\\n}\\n\"},\"lib/euler-vault-kit/lib/ethereum-vault-connector/src/Events.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\n/// @title Events\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice This contract implements the events for the Ethereum Vault Connector.\\ncontract Events {\\n    /// @notice Emitted when an owner is registered for an address prefix.\\n    /// @param addressPrefix The address prefix for which the owner is registered.\\n    /// @param owner The address of the owner registered.\\n    event OwnerRegistered(bytes19 indexed addressPrefix, address indexed owner);\\n\\n    /// @notice Emitted when the lockdown mode status is changed for an address prefix.\\n    /// @param addressPrefix The address prefix for which the lockdown mode status is changed.\\n    /// @param enabled True if the lockdown mode is enabled, false otherwise.\\n    event LockdownModeStatus(bytes19 indexed addressPrefix, bool enabled);\\n\\n    /// @notice Emitted when the permit disabled mode status is changed for an address prefix.\\n    /// @param addressPrefix The address prefix for which the permit disabled mode status is changed.\\n    /// @param enabled True if the permit disabled mode is enabled, false otherwise.\\n    event PermitDisabledModeStatus(bytes19 indexed addressPrefix, bool enabled);\\n\\n    /// @notice Emitted when the nonce status is updated for a given address prefix and nonce namespace.\\n    /// @param addressPrefix The prefix of the address for which the nonce status is updated.\\n    /// @param nonceNamespace The namespace of the nonce being updated.\\n    /// @param oldNonce The previous nonce value before the update.\\n    /// @param newNonce The new nonce value after the update.\\n    event NonceStatus(\\n        bytes19 indexed addressPrefix, uint256 indexed nonceNamespace, uint256 oldNonce, uint256 newNonce\\n    );\\n\\n    /// @notice Emitted when a nonce is used for an address prefix and nonce namespace as part of permit execution.\\n    /// @param addressPrefix The address prefix for which the nonce is used.\\n    /// @param nonceNamespace The namespace of the nonce used.\\n    /// @param nonce The nonce that was used.\\n    event NonceUsed(bytes19 indexed addressPrefix, uint256 indexed nonceNamespace, uint256 nonce);\\n\\n    /// @notice Emitted when the operator status is changed for an address prefix.\\n    /// @param addressPrefix The address prefix for which the operator status is changed.\\n    /// @param operator The address of the operator.\\n    /// @param accountOperatorAuthorized The new authorization bitfield of the operator.\\n    event OperatorStatus(bytes19 indexed addressPrefix, address indexed operator, uint256 accountOperatorAuthorized);\\n\\n    /// @notice Emitted when the collateral status is changed for an account.\\n    /// @param account The account for which the collateral status is changed.\\n    /// @param collateral The address of the collateral.\\n    /// @param enabled True if the collateral is enabled, false otherwise.\\n    event CollateralStatus(address indexed account, address indexed collateral, bool enabled);\\n\\n    /// @notice Emitted when the controller status is changed for an account.\\n    /// @param account The account for which the controller status is changed.\\n    /// @param controller The address of the controller.\\n    /// @param enabled True if the controller is enabled, false otherwise.\\n    event ControllerStatus(address indexed account, address indexed controller, bool enabled);\\n\\n    /// @notice Emitted when an external call is made through the EVC.\\n    /// @param caller The address of the caller.\\n    /// @param onBehalfOfAddressPrefix The address prefix of the account on behalf of which the call is made.\\n    /// @param onBehalfOfAccount The account on behalf of which the call is made.\\n    /// @param targetContract The target contract of the call.\\n    /// @param selector The selector of the function called on the target contract.\\n    event CallWithContext(\\n        address indexed caller,\\n        bytes19 indexed onBehalfOfAddressPrefix,\\n        address onBehalfOfAccount,\\n        address indexed targetContract,\\n        bytes4 selector\\n    );\\n\\n    /// @notice Emitted when an account status check is performed.\\n    /// @param account The account for which the status check is performed.\\n    /// @param controller The controller performing the status check.\\n    event AccountStatusCheck(address indexed account, address indexed controller);\\n\\n    /// @notice Emitted when a vault status check is performed.\\n    /// @param vault The vault for which the status check is performed.\\n    event VaultStatusCheck(address indexed vault);\\n}\\n\"},\"lib/euler-vault-kit/lib/ethereum-vault-connector/src/ExecutionContext.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\ntype EC is uint256;\\n\\n/// @title ExecutionContext\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice This library provides functions for managing the execution context in the Ethereum Vault Connector.\\n/// @dev The execution context is a bit field that stores the following information:\\n/// @dev - on behalf of account - an account on behalf of which the currently executed operation is being performed\\n/// @dev - checks deferred flag - used to indicate whether checks are deferred\\n/// @dev - checks in progress flag - used to indicate that the account/vault status checks are in progress. This flag is\\n/// used to prevent re-entrancy.\\n/// @dev - control collateral in progress flag - used to indicate that the control collateral is in progress. This flag\\n/// is used to prevent re-entrancy.\\n/// @dev - operator authenticated flag - used to indicate that the currently executed operation is being performed by\\n/// the account operator\\n/// @dev - simulation flag - used to indicate that the currently executed batch call is a simulation\\n/// @dev - stamp - dummy value for optimization purposes\\nlibrary ExecutionContext {\\n    uint256 internal constant ON_BEHALF_OF_ACCOUNT_MASK =\\n        0x000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n    uint256 internal constant CHECKS_DEFERRED_MASK = 0x0000000000000000000000FF0000000000000000000000000000000000000000;\\n    uint256 internal constant CHECKS_IN_PROGRESS_MASK =\\n        0x00000000000000000000FF000000000000000000000000000000000000000000;\\n    uint256 internal constant CONTROL_COLLATERAL_IN_PROGRESS_LOCK_MASK =\\n        0x000000000000000000FF00000000000000000000000000000000000000000000;\\n    uint256 internal constant OPERATOR_AUTHENTICATED_MASK =\\n        0x0000000000000000FF0000000000000000000000000000000000000000000000;\\n    uint256 internal constant SIMULATION_MASK = 0x00000000000000FF000000000000000000000000000000000000000000000000;\\n    uint256 internal constant STAMP_OFFSET = 200;\\n\\n    // None of the functions below modifies the state. All the functions operate on the copy\\n    // of the execution context and return its modified value as a result. In order to update\\n    // one should use the result of the function call as a new execution context value.\\n\\n    function getOnBehalfOfAccount(EC self) internal pure returns (address result) {\\n        result = address(uint160(EC.unwrap(self) & ON_BEHALF_OF_ACCOUNT_MASK));\\n    }\\n\\n    function setOnBehalfOfAccount(EC self, address account) internal pure returns (EC result) {\\n        result = EC.wrap((EC.unwrap(self) & ~ON_BEHALF_OF_ACCOUNT_MASK) | uint160(account));\\n    }\\n\\n    function areChecksDeferred(EC self) internal pure returns (bool result) {\\n        result = EC.unwrap(self) & CHECKS_DEFERRED_MASK != 0;\\n    }\\n\\n    function setChecksDeferred(EC self) internal pure returns (EC result) {\\n        result = EC.wrap(EC.unwrap(self) | CHECKS_DEFERRED_MASK);\\n    }\\n\\n    function areChecksInProgress(EC self) internal pure returns (bool result) {\\n        result = EC.unwrap(self) & CHECKS_IN_PROGRESS_MASK != 0;\\n    }\\n\\n    function setChecksInProgress(EC self) internal pure returns (EC result) {\\n        result = EC.wrap(EC.unwrap(self) | CHECKS_IN_PROGRESS_MASK);\\n    }\\n\\n    function isControlCollateralInProgress(EC self) internal pure returns (bool result) {\\n        result = EC.unwrap(self) & CONTROL_COLLATERAL_IN_PROGRESS_LOCK_MASK != 0;\\n    }\\n\\n    function setControlCollateralInProgress(EC self) internal pure returns (EC result) {\\n        result = EC.wrap(EC.unwrap(self) | CONTROL_COLLATERAL_IN_PROGRESS_LOCK_MASK);\\n    }\\n\\n    function isOperatorAuthenticated(EC self) internal pure returns (bool result) {\\n        result = EC.unwrap(self) & OPERATOR_AUTHENTICATED_MASK != 0;\\n    }\\n\\n    function setOperatorAuthenticated(EC self) internal pure returns (EC result) {\\n        result = EC.wrap(EC.unwrap(self) | OPERATOR_AUTHENTICATED_MASK);\\n    }\\n\\n    function clearOperatorAuthenticated(EC self) internal pure returns (EC result) {\\n        result = EC.wrap(EC.unwrap(self) & ~OPERATOR_AUTHENTICATED_MASK);\\n    }\\n\\n    function isSimulationInProgress(EC self) internal pure returns (bool result) {\\n        result = EC.unwrap(self) & SIMULATION_MASK != 0;\\n    }\\n\\n    function setSimulationInProgress(EC self) internal pure returns (EC result) {\\n        result = EC.wrap(EC.unwrap(self) | SIMULATION_MASK);\\n    }\\n}\\n\"},\"lib/euler-vault-kit/lib/ethereum-vault-connector/src/Set.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\n/// @dev Represents the maximum number of elements that can be stored in the set.\\n/// Must not exceed 255 due to the uint8 data type limit.\\nuint8 constant SET_MAX_ELEMENTS = 10;\\n\\n/// @title ElementStorage\\n/// @notice This struct is used to store the value and stamp of an element.\\n/// @dev The stamp field is used to keep the storage slot non-zero when the element is removed.\\n/// @dev It allows for cheaper SSTORE when an element is inserted.\\nstruct ElementStorage {\\n    /// @notice The value of the element.\\n    address value;\\n    /// @notice The stamp of the element.\\n    uint96 stamp;\\n}\\n\\n/// @title SetStorage\\n/// @notice This struct is used to store the set data.\\n/// @dev To optimize the gas consumption, firstElement is stored in the same storage slot as the numElements\\n/// @dev so that for sets with one element, only one storage slot has to be read/written. To keep the elements\\n/// @dev array indexing consistent and because the first element is stored outside of the array, the elements[0]\\n/// @dev is not utilized. The stamp field is used to keep the storage slot non-zero when the element is removed.\\n/// @dev It allows for cheaper SSTORE when an element is inserted.\\nstruct SetStorage {\\n    /// @notice The number of elements in the set.\\n    uint8 numElements;\\n    /// @notice The first element in the set.\\n    address firstElement;\\n    /// @notice The metadata of the set.\\n    uint80 metadata;\\n    /// @notice The stamp of the set.\\n    uint8 stamp;\\n    /// @notice The array of elements in the set. Stores the elements starting from index 1.\\n    ElementStorage[SET_MAX_ELEMENTS] elements;\\n}\\n\\n/// @title Set\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice This library provides functions for managing sets of addresses.\\n/// @dev The maximum number of elements in the set is defined by the constant SET_MAX_ELEMENTS.\\nlibrary Set {\\n    error TooManyElements();\\n    error InvalidIndex();\\n\\n    uint8 internal constant EMPTY_ELEMENT_OFFSET = 1; // must be 1\\n    uint8 internal constant DUMMY_STAMP = 1;\\n\\n    /// @notice Initializes the set by setting the stamp field of the SetStorage and the stamp field of elements to\\n    /// DUMMY_STAMP.\\n    /// @dev The stamp field is used to keep the storage slot non-zero when the element is removed. It allows for\\n    /// cheaper SSTORE when an element is inserted.\\n    /// @param setStorage The set storage whose stamp fields will be initialized.\\n    function initialize(SetStorage storage setStorage) internal {\\n        setStorage.stamp = DUMMY_STAMP;\\n\\n        for (uint256 i = EMPTY_ELEMENT_OFFSET; i < SET_MAX_ELEMENTS; ++i) {\\n            setStorage.elements[i].stamp = DUMMY_STAMP;\\n        }\\n    }\\n\\n    /// @notice Inserts an element and returns information whether the element was inserted or not.\\n    /// @dev Reverts if the set is full but the element is not in the set storage.\\n    /// @param setStorage The set storage to which the element will be inserted.\\n    /// @param element The element to be inserted.\\n    /// @return A boolean value that indicates whether the element was inserted or not. If the element was already in\\n    /// the set storage, it returns false.\\n    function insert(SetStorage storage setStorage, address element) internal returns (bool) {\\n        address firstElement = setStorage.firstElement;\\n        uint256 numElements = setStorage.numElements;\\n        uint80 metadata = setStorage.metadata;\\n\\n        if (numElements == 0) {\\n            // gas optimization:\\n            // on the first element insertion, set the stamp to non-zero value to keep the storage slot non-zero when\\n            // the element is removed. when a new element is inserted after the removal, it should be cheaper\\n            setStorage.numElements = 1;\\n            setStorage.firstElement = element;\\n            setStorage.metadata = metadata;\\n            setStorage.stamp = DUMMY_STAMP;\\n            return true;\\n        }\\n\\n        if (firstElement == element) return false;\\n\\n        for (uint256 i = EMPTY_ELEMENT_OFFSET; i < numElements; ++i) {\\n            if (setStorage.elements[i].value == element) return false;\\n        }\\n\\n        if (numElements == SET_MAX_ELEMENTS) revert TooManyElements();\\n\\n        setStorage.elements[numElements].value = element;\\n\\n        unchecked {\\n            setStorage.numElements = uint8(numElements + 1);\\n        }\\n\\n        return true;\\n    }\\n\\n    /// @notice Removes an element and returns information whether the element was removed or not.\\n    /// @dev This operation may affect the order of elements in the array of elements obtained using get() function. This\\n    /// function does not modify the metadata of the set, even if it becomes empty as a result of invoking this\\n    /// function.\\n    /// @param setStorage The set storage from which the element will be removed.\\n    /// @param element The element to be removed.\\n    /// @return A boolean value that indicates whether the element was removed or not. If the element was not in the set\\n    /// storage, it returns false.\\n    function remove(SetStorage storage setStorage, address element) internal returns (bool) {\\n        address firstElement = setStorage.firstElement;\\n        uint256 numElements = setStorage.numElements;\\n        uint80 metadata = setStorage.metadata;\\n\\n        if (numElements == 0) return false;\\n\\n        uint256 searchIndex;\\n        if (firstElement != element) {\\n            for (searchIndex = EMPTY_ELEMENT_OFFSET; searchIndex < numElements; ++searchIndex) {\\n                if (setStorage.elements[searchIndex].value == element) break;\\n            }\\n\\n            if (searchIndex == numElements) return false;\\n        }\\n\\n        // write full slot at once to avoid SLOAD and bit masking\\n        if (numElements == 1) {\\n            setStorage.numElements = 0;\\n            setStorage.firstElement = address(0);\\n            setStorage.metadata = metadata;\\n            setStorage.stamp = DUMMY_STAMP;\\n            return true;\\n        }\\n\\n        uint256 lastIndex;\\n        unchecked {\\n            lastIndex = numElements - 1;\\n        }\\n\\n        // set numElements for every execution path to avoid SSTORE and bit masking when the element removed is\\n        // firstElement\\n        ElementStorage storage lastElement = setStorage.elements[lastIndex];\\n        if (searchIndex != lastIndex) {\\n            if (searchIndex == 0) {\\n                setStorage.firstElement = lastElement.value;\\n                setStorage.numElements = uint8(lastIndex);\\n                setStorage.metadata = metadata;\\n                setStorage.stamp = DUMMY_STAMP;\\n            } else {\\n                setStorage.elements[searchIndex].value = lastElement.value;\\n\\n                setStorage.firstElement = firstElement;\\n                setStorage.numElements = uint8(lastIndex);\\n                setStorage.metadata = metadata;\\n                setStorage.stamp = DUMMY_STAMP;\\n            }\\n        } else {\\n            setStorage.firstElement = firstElement;\\n            setStorage.numElements = uint8(lastIndex);\\n            setStorage.metadata = metadata;\\n            setStorage.stamp = DUMMY_STAMP;\\n        }\\n\\n        lastElement.value = address(0);\\n\\n        return true;\\n    }\\n\\n    /// @notice Swaps the position of two elements so that they appear switched in the array of elements obtained using\\n    /// get() function.\\n    /// @dev The first index must not be greater than or equal to the second index. Indices must not be out of bounds.\\n    /// The function will revert if the indices are invalid.\\n    /// @param setStorage The set storage for which the elements will be swapped.\\n    /// @param index1 The index of the first element to be swapped.\\n    /// @param index2 The index of the second element to be swapped.\\n    function reorder(SetStorage storage setStorage, uint8 index1, uint8 index2) internal {\\n        address firstElement = setStorage.firstElement;\\n        uint256 numElements = setStorage.numElements;\\n\\n        if (index1 >= index2 || index2 >= numElements) {\\n            revert InvalidIndex();\\n        }\\n\\n        if (index1 == 0) {\\n            (setStorage.firstElement, setStorage.elements[index2].value) =\\n                (setStorage.elements[index2].value, firstElement);\\n        } else {\\n            (setStorage.elements[index1].value, setStorage.elements[index2].value) =\\n                (setStorage.elements[index2].value, setStorage.elements[index1].value);\\n        }\\n    }\\n\\n    /// @notice Sets the metadata for the set storage.\\n    /// @param setStorage The storage structure where metadata will be set.\\n    /// @param metadata The metadata value to set.\\n    function setMetadata(SetStorage storage setStorage, uint80 metadata) internal {\\n        setStorage.metadata = metadata;\\n    }\\n\\n    /// @notice Returns an array of elements contained in the storage.\\n    /// @dev The order of the elements in the array may be affected by performing operations on the set.\\n    /// @param setStorage The set storage to be processed.\\n    /// @return An array that contains the same elements as the set storage.\\n    function get(SetStorage storage setStorage) internal view returns (address[] memory) {\\n        address firstElement = setStorage.firstElement;\\n        uint256 numElements = setStorage.numElements;\\n        address[] memory output = new address[](numElements);\\n\\n        if (numElements == 0) return output;\\n\\n        output[0] = firstElement;\\n\\n        for (uint256 i = EMPTY_ELEMENT_OFFSET; i < numElements; ++i) {\\n            output[i] = setStorage.elements[i].value;\\n        }\\n\\n        return output;\\n    }\\n\\n    /// @notice Retrieves the metadata from the set storage.\\n    /// @param setStorage The storage structure from which metadata is retrieved.\\n    /// @return The metadata value.\\n    function getMetadata(SetStorage storage setStorage) internal view returns (uint80) {\\n        return setStorage.metadata;\\n    }\\n\\n    /// @notice Checks if the set storage contains a given element and returns a boolean value that indicates the\\n    /// result.\\n    /// @param setStorage The set storage to be searched.\\n    /// @param element The element to be searched for.\\n    /// @return A boolean value that indicates whether the set storage includes the element or not.\\n    function contains(SetStorage storage setStorage, address element) internal view returns (bool) {\\n        address firstElement = setStorage.firstElement;\\n        uint256 numElements = setStorage.numElements;\\n\\n        if (numElements == 0) return false;\\n        if (firstElement == element) return true;\\n\\n        for (uint256 i = EMPTY_ELEMENT_OFFSET; i < numElements; ++i) {\\n            if (setStorage.elements[i].value == element) return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /// @notice Iterates over each element in the set and applies the callback function to it.\\n    /// @dev The set is cleared as a result of this call. Considering that this function does not follow the\\n    /// Checks-Effects-Interactions pattern, the function using it must prevent re-entrancy. This function does not\\n    /// modify the metadata of the set.\\n    /// @param setStorage The set storage to be processed.\\n    /// @param callback The function to be applied to each element.\\n    function forEachAndClear(SetStorage storage setStorage, function(address) callback) internal {\\n        uint256 numElements = setStorage.numElements;\\n        address firstElement = setStorage.firstElement;\\n        uint80 metadata = setStorage.metadata;\\n\\n        if (numElements == 0) return;\\n\\n        setStorage.numElements = 0;\\n        setStorage.firstElement = address(0);\\n        setStorage.metadata = metadata;\\n        setStorage.stamp = DUMMY_STAMP;\\n\\n        callback(firstElement);\\n\\n        for (uint256 i = EMPTY_ELEMENT_OFFSET; i < numElements; ++i) {\\n            address element = setStorage.elements[i].value;\\n            setStorage.elements[i] = ElementStorage({value: address(0), stamp: DUMMY_STAMP});\\n\\n            callback(element);\\n        }\\n    }\\n\\n    /// @notice Iterates over each element in the set and applies the callback function to it, returning the array of\\n    /// callback results.\\n    /// @dev The set is cleared as a result of this call. Considering that this function does not follow the\\n    /// Checks-Effects-Interactions pattern, the function using it must prevent re-entrancy. This function does not\\n    /// modify the metadata of the set.\\n    /// @param setStorage The set storage to be processed.\\n    /// @param callback The function to be applied to each element.\\n    /// @return result An array of encoded bytes that are the addresses passed to the callback function and results of\\n    /// calling it.\\n    function forEachAndClearWithResult(\\n        SetStorage storage setStorage,\\n        function(address) returns (bool, bytes memory) callback\\n    ) internal returns (bytes[] memory) {\\n        uint256 numElements = setStorage.numElements;\\n        address firstElement = setStorage.firstElement;\\n        uint80 metadata = setStorage.metadata;\\n        bytes[] memory results = new bytes[](numElements);\\n\\n        if (numElements == 0) return results;\\n\\n        setStorage.numElements = 0;\\n        setStorage.firstElement = address(0);\\n        setStorage.metadata = metadata;\\n        setStorage.stamp = DUMMY_STAMP;\\n\\n        (bool success, bytes memory result) = callback(firstElement);\\n        results[0] = abi.encode(firstElement, success, result);\\n\\n        for (uint256 i = EMPTY_ELEMENT_OFFSET; i < numElements; ++i) {\\n            address element = setStorage.elements[i].value;\\n            setStorage.elements[i] = ElementStorage({value: address(0), stamp: DUMMY_STAMP});\\n\\n            (success, result) = callback(element);\\n            results[i] = abi.encode(element, success, result);\\n        }\\n\\n        return results;\\n    }\\n}\\n\"},\"lib/euler-vault-kit/lib/ethereum-vault-connector/src/TransientStorage.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport {ExecutionContext, EC} from \\\"./ExecutionContext.sol\\\";\\nimport {Set, SetStorage} from \\\"./Set.sol\\\";\\n\\n/// @title TransientStorage\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice This contract provides transient storage for the Ethereum Vault Connector.\\n/// @dev All the variables in this contract are considered transient meaning that their state does not change between\\n/// invocations.\\nabstract contract TransientStorage {\\n    using ExecutionContext for EC;\\n    using Set for SetStorage;\\n\\n    enum SetType {\\n        Account,\\n        Vault\\n    }\\n\\n    EC internal executionContext;\\n    SetStorage internal accountStatusChecks;\\n    SetStorage internal vaultStatusChecks;\\n\\n    constructor() {\\n        // set the execution context to non-zero value to always keep the storage slot in non-zero state.\\n        // it allows for cheaper SSTOREs when the execution context is in its default state\\n        executionContext = EC.wrap(1 << ExecutionContext.STAMP_OFFSET);\\n\\n        // there are two types of data that are stored using SetStorage type:\\n        // - the data that is transient in nature (accountStatusChecks and vaultStatusChecks)\\n        // - the data that is permanent (accountControllers and accountCollaterals from the EthereumVaultConnector\\n        // contract)\\n\\n        // for the permanent data, there's no need to care that much about optimizations. each account has its two sets.\\n        // usually, an address inserted to either of them won't be removed within the same transaction. the only\\n        // optimization applied (directly in the Set contract) is that on the first element insertion, the stamp is set\\n        // to non-zero value to always keep that storage slot in non-zero state. it allows for cheaper SSTORE when an\\n        // element is inserted again after clearing the set.\\n\\n        // for the transient data, an address insertion should be as cheap as possible. hence on construction, we store\\n        // dummy values for all the storage slots where the elements will be stored later on. it is important\\n        // considering that both accountStatusChecks and vaultStatusChecks are always cleared at the end of the\\n        // transaction. with dummy values set, the transition from zero to non-zero and back to zero will be\\n        // significantly cheaper than it would be otherwise\\n        accountStatusChecks.initialize();\\n        vaultStatusChecks.initialize();\\n    }\\n}\\n\"},\"lib/euler-vault-kit/lib/ethereum-vault-connector/src/interfaces/IERC1271.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\\n\\npragma solidity >=0.8.0;\\n\\n/// @dev Interface of the ERC1271 standard signature validation method for\\n/// contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\ninterface IERC1271 {\\n    /// @dev Should return whether the signature provided is valid for the provided data\\n    /// @param hash Hash of the data to be signed\\n    /// @param signature Signature byte array associated with _data\\n    /// @return magicValue Must return the bytes4 magic value 0x1626ba7e (which is a selector of this function) when\\n    /// the signature is valid.\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\"},\"lib/euler-vault-kit/lib/ethereum-vault-connector/src/interfaces/IEthereumVaultConnector.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.8.0;\\n\\n/// @title IEVC\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice This interface defines the methods for the Ethereum Vault Connector.\\ninterface IEVC {\\n    /// @notice A struct representing a batch item.\\n    /// @dev Each batch item represents a single operation to be performed within a checks deferred context.\\n    struct BatchItem {\\n        /// @notice The target contract to be called.\\n        address targetContract;\\n        /// @notice The account on behalf of which the operation is to be performed. msg.sender must be authorized to\\n        /// act on behalf of this account. Must be address(0) if the target contract is the EVC itself.\\n        address onBehalfOfAccount;\\n        /// @notice The amount of value to be forwarded with the call. If the value is type(uint256).max, the whole\\n        /// balance of the EVC contract will be forwarded. Must be 0 if the target contract is the EVC itself.\\n        uint256 value;\\n        /// @notice The encoded data which is called on the target contract.\\n        bytes data;\\n    }\\n\\n    /// @notice A struct representing the result of a batch item operation.\\n    /// @dev Used only for simulation purposes.\\n    struct BatchItemResult {\\n        /// @notice A boolean indicating whether the operation was successful.\\n        bool success;\\n        /// @notice The result of the operation.\\n        bytes result;\\n    }\\n\\n    /// @notice A struct representing the result of the account or vault status check.\\n    /// @dev Used only for simulation purposes.\\n    struct StatusCheckResult {\\n        /// @notice The address of the account or vault for which the check was performed.\\n        address checkedAddress;\\n        /// @notice A boolean indicating whether the status of the account or vault is valid.\\n        bool isValid;\\n        /// @notice The result of the check.\\n        bytes result;\\n    }\\n\\n    /// @notice Returns current raw execution context.\\n    /// @dev When checks in progress, on behalf of account is always address(0).\\n    /// @return context Current raw execution context.\\n    function getRawExecutionContext() external view returns (uint256 context);\\n\\n    /// @notice Returns an account on behalf of which the operation is being executed at the moment and whether the\\n    /// controllerToCheck is an enabled controller for that account.\\n    /// @dev This function should only be used by external smart contracts if msg.sender is the EVC. Otherwise, the\\n    /// account address returned must not be trusted.\\n    /// @dev When checks in progress, on behalf of account is always address(0). When address is zero, the function\\n    /// reverts to protect the consumer from ever relying on the on behalf of account address which is in its default\\n    /// state.\\n    /// @param controllerToCheck The address of the controller for which it is checked whether it is an enabled\\n    /// controller for the account on behalf of which the operation is being executed at the moment.\\n    /// @return onBehalfOfAccount An account that has been authenticated and on behalf of which the operation is being\\n    /// executed at the moment.\\n    /// @return controllerEnabled A boolean value that indicates whether controllerToCheck is an enabled controller for\\n    /// the account on behalf of which the operation is being executed at the moment. Always false if controllerToCheck\\n    /// is address(0).\\n    function getCurrentOnBehalfOfAccount(address controllerToCheck)\\n        external\\n        view\\n        returns (address onBehalfOfAccount, bool controllerEnabled);\\n\\n    /// @notice Checks if checks are deferred.\\n    /// @return A boolean indicating whether checks are deferred.\\n    function areChecksDeferred() external view returns (bool);\\n\\n    /// @notice Checks if checks are in progress.\\n    /// @return A boolean indicating whether checks are in progress.\\n    function areChecksInProgress() external view returns (bool);\\n\\n    /// @notice Checks if control collateral is in progress.\\n    /// @return A boolean indicating whether control collateral is in progress.\\n    function isControlCollateralInProgress() external view returns (bool);\\n\\n    /// @notice Checks if an operator is authenticated.\\n    /// @return A boolean indicating whether an operator is authenticated.\\n    function isOperatorAuthenticated() external view returns (bool);\\n\\n    /// @notice Checks if a simulation is in progress.\\n    /// @return A boolean indicating whether a simulation is in progress.\\n    function isSimulationInProgress() external view returns (bool);\\n\\n    /// @notice Checks whether the specified account and the other account have the same owner.\\n    /// @dev The function is used to check whether one account is authorized to perform operations on behalf of the\\n    /// other. Accounts are considered to have a common owner if they share the first 19 bytes of their address.\\n    /// @param account The address of the account that is being checked.\\n    /// @param otherAccount The address of the other account that is being checked.\\n    /// @return A boolean flag that indicates whether the accounts have the same owner.\\n    function haveCommonOwner(address account, address otherAccount) external pure returns (bool);\\n\\n    /// @notice Returns the address prefix of the specified account.\\n    /// @dev The address prefix is the first 19 bytes of the account address.\\n    /// @param account The address of the account whose address prefix is being retrieved.\\n    /// @return A bytes19 value that represents the address prefix of the account.\\n    function getAddressPrefix(address account) external pure returns (bytes19);\\n\\n    /// @notice Returns the owner for the specified account.\\n    /// @dev The function returns address(0) if the owner is not registered. Registration of the owner happens on the\\n    /// initial\\n    /// interaction with the EVC that requires authentication of an owner.\\n    /// @param account The address of the account whose owner is being retrieved.\\n    /// @return owner The address of the account owner. An account owner is an EOA/smart contract which address matches\\n    /// the first 19 bytes of the account address.\\n    function getAccountOwner(address account) external view returns (address);\\n\\n    /// @notice Checks if lockdown mode is enabled for a given address prefix.\\n    /// @param addressPrefix The address prefix to check for lockdown mode status.\\n    /// @return A boolean indicating whether lockdown mode is enabled.\\n    function isLockdownMode(bytes19 addressPrefix) external view returns (bool);\\n\\n    /// @notice Checks if permit functionality is disabled for a given address prefix.\\n    /// @param addressPrefix The address prefix to check for permit functionality status.\\n    /// @return A boolean indicating whether permit functionality is disabled.\\n    function isPermitDisabledMode(bytes19 addressPrefix) external view returns (bool);\\n\\n    /// @notice Returns the current nonce for a given address prefix and nonce namespace.\\n    /// @dev Each nonce namespace provides 256 bit nonce that has to be used sequentially. There's no requirement to use\\n    /// all the nonces for a given nonce namespace before moving to the next one which allows to use permit messages in\\n    /// a non-sequential manner.\\n    /// @param addressPrefix The address prefix for which the nonce is being retrieved.\\n    /// @param nonceNamespace The nonce namespace for which the nonce is being retrieved.\\n    /// @return nonce The current nonce for the given address prefix and nonce namespace.\\n    function getNonce(bytes19 addressPrefix, uint256 nonceNamespace) external view returns (uint256 nonce);\\n\\n    /// @notice Returns the bit field for a given address prefix and operator.\\n    /// @dev The bit field is used to store information about authorized operators for a given address prefix. Each bit\\n    /// in the bit field corresponds to one account belonging to the same owner. If the bit is set, the operator is\\n    /// authorized for the account.\\n    /// @param addressPrefix The address prefix for which the bit field is being retrieved.\\n    /// @param operator The address of the operator for which the bit field is being retrieved.\\n    /// @return operatorBitField The bit field for the given address prefix and operator. The bit field defines which\\n    /// accounts the operator is authorized for. It is a 256-position binary array like 0...010...0, marking the account\\n    /// positionally in a uint256. The position in the bit field corresponds to the account ID (0-255), where 0 is the\\n    /// owner account's ID.\\n    function getOperator(bytes19 addressPrefix, address operator) external view returns (uint256 operatorBitField);\\n\\n    /// @notice Returns whether a given operator has been authorized for a given account.\\n    /// @param account The address of the account whose operator is being checked.\\n    /// @param operator The address of the operator that is being checked.\\n    /// @return authorized A boolean value that indicates whether the operator is authorized for the account.\\n    function isAccountOperatorAuthorized(address account, address operator) external view returns (bool authorized);\\n\\n    /// @notice Enables or disables lockdown mode for a given address prefix.\\n    /// @dev This function can only be called by the owner of the address prefix. To disable this mode, the EVC\\n    /// must be called directly. It is not possible to disable this mode by using checks-deferrable call or\\n    /// permit message.\\n    /// @param addressPrefix The address prefix for which the lockdown mode is being set.\\n    /// @param enabled A boolean indicating whether to enable or disable lockdown mode.\\n    function setLockdownMode(bytes19 addressPrefix, bool enabled) external payable;\\n\\n    /// @notice Enables or disables permit functionality for a given address prefix.\\n    /// @dev This function can only be called by the owner of the address prefix. To disable this mode, the EVC\\n    /// must be called directly. It is not possible to disable this mode by using checks-deferrable call or (by\\n    /// definition) permit message. To support permit functionality by default, note that the logic was inverted here. To\\n    /// disable  the permit functionality, one must pass true as the second argument. To enable the permit\\n    /// functionality, one must pass false as the second argument.\\n    /// @param addressPrefix The address prefix for which the permit functionality is being set.\\n    /// @param enabled A boolean indicating whether to enable or disable the disable-permit mode.\\n    function setPermitDisabledMode(bytes19 addressPrefix, bool enabled) external payable;\\n\\n    /// @notice Sets the nonce for a given address prefix and nonce namespace.\\n    /// @dev This function can only be called by the owner of the address prefix. Each nonce namespace provides a 256\\n    /// bit nonce that has to be used sequentially. There's no requirement to use all the nonces for a given nonce\\n    /// namespace before moving to the next one which allows the use of permit messages in a non-sequential manner. To\\n    /// invalidate signed permit messages, set the nonce for a given nonce namespace accordingly. To invalidate all the\\n    /// permit messages for a given nonce namespace, set the nonce to type(uint).max.\\n    /// @param addressPrefix The address prefix for which the nonce is being set.\\n    /// @param nonceNamespace The nonce namespace for which the nonce is being set.\\n    /// @param nonce The new nonce for the given address prefix and nonce namespace.\\n    function setNonce(bytes19 addressPrefix, uint256 nonceNamespace, uint256 nonce) external payable;\\n\\n    /// @notice Sets the bit field for a given address prefix and operator.\\n    /// @dev This function can only be called by the owner of the address prefix. Each bit in the bit field corresponds\\n    /// to one account belonging to the same owner. If the bit is set, the operator is authorized for the account.\\n    /// @param addressPrefix The address prefix for which the bit field is being set.\\n    /// @param operator The address of the operator for which the bit field is being set. Can neither be the EVC address\\n    /// nor an address belonging to the same address prefix.\\n    /// @param operatorBitField The new bit field for the given address prefix and operator. Reverts if the provided\\n    /// value is equal to the currently stored value.\\n    function setOperator(bytes19 addressPrefix, address operator, uint256 operatorBitField) external payable;\\n\\n    /// @notice Authorizes or deauthorizes an operator for the account.\\n    /// @dev Only the owner or authorized operator of the account can call this function. An operator is an address that\\n    /// can perform actions for an account on behalf of the owner. If it's an operator calling this function, it can\\n    /// only deauthorize itself.\\n    /// @param account The address of the account whose operator is being set or unset.\\n    /// @param operator The address of the operator that is being installed or uninstalled. Can neither be the EVC\\n    /// address nor an address belonging to the same owner as the account.\\n    /// @param authorized A boolean value that indicates whether the operator is being authorized or deauthorized.\\n    /// Reverts if the provided value is equal to the currently stored value.\\n    function setAccountOperator(address account, address operator, bool authorized) external payable;\\n\\n    /// @notice Returns an array of collaterals enabled for an account.\\n    /// @dev A collateral is a vault for which an account's balances are under the control of the currently enabled\\n    /// controller vault.\\n    /// @param account The address of the account whose collaterals are being queried.\\n    /// @return An array of addresses that are enabled collaterals for the account.\\n    function getCollaterals(address account) external view returns (address[] memory);\\n\\n    /// @notice Returns whether a collateral is enabled for an account.\\n    /// @dev A collateral is a vault for which account's balances are under the control of the currently enabled\\n    /// controller vault.\\n    /// @param account The address of the account that is being checked.\\n    /// @param vault The address of the collateral that is being checked.\\n    /// @return A boolean value that indicates whether the vault is an enabled collateral for the account or not.\\n    function isCollateralEnabled(address account, address vault) external view returns (bool);\\n\\n    /// @notice Enables a collateral for an account.\\n    /// @dev A collaterals is a vault for which account's balances are under the control of the currently enabled\\n    /// controller vault. Only the owner or an operator of the account can call this function. Unless it's a duplicate,\\n    /// the collateral is added to the end of the array. There can be at most 10 unique collaterals enabled at a time.\\n    /// Account status checks are performed.\\n    /// @param account The account address for which the collateral is being enabled.\\n    /// @param vault The address being enabled as a collateral.\\n    function enableCollateral(address account, address vault) external payable;\\n\\n    /// @notice Disables a collateral for an account.\\n    /// @dev This function does not preserve the order of collaterals in the array obtained using the getCollaterals\\n    /// function; the order may change. A collateral is a vault for which accounts balances are under the control of\\n    /// the currently enabled controller vault. Only the owner or an operator of the account can call this function.\\n    /// Disabling a collateral might change the order of collaterals in the array obtained using getCollaterals\\n    /// function. Account status checks are performed.\\n    /// @param account The account address for which the collateral is being disabled.\\n    /// @param vault The address of a collateral being disabled.\\n    function disableCollateral(address account, address vault) external payable;\\n\\n    /// @notice Swaps the position of two collaterals so that they appear switched in the array of collaterals for a\\n    /// given account obtained by calling getCollaterals function.\\n    /// @dev A collateral is a vault for which accounts balances are under the control of the currently enabled\\n    /// controller vault. Only the owner or an operator of the account can call this function. The order of collaterals\\n    /// can be changed by specifying the indices of the two collaterals to be swapped. Indices are zero-based and must\\n    /// be in the range of 0 to the number of collaterals minus 1. index1 must be lower than index2. Account status\\n    /// checks are performed.\\n    /// @param account The address of the account for which the collaterals are being reordered.\\n    /// @param index1 The index of the first collateral to be swapped.\\n    /// @param index2 The index of the second collateral to be swapped.\\n    function reorderCollaterals(address account, uint8 index1, uint8 index2) external payable;\\n\\n    /// @notice Returns an array of enabled controllers for an account.\\n    /// @dev A controller is a vault that has been chosen for an account to have special control over the account's\\n    /// balances in enabled collaterals vaults. A user can have multiple controllers during a call execution, but at\\n    /// most one can be selected when the account status check is performed.\\n    /// @param account The address of the account whose controllers are being queried.\\n    /// @return An array of addresses that are the enabled controllers for the account.\\n    function getControllers(address account) external view returns (address[] memory);\\n\\n    /// @notice Returns whether a controller is enabled for an account.\\n    /// @dev A controller is a vault that has been chosen for an account to have special control over accounts\\n    /// balances in the enabled collaterals vaults.\\n    /// @param account The address of the account that is being checked.\\n    /// @param vault The address of the controller that is being checked.\\n    /// @return A boolean value that indicates whether the vault is enabled controller for the account or not.\\n    function isControllerEnabled(address account, address vault) external view returns (bool);\\n\\n    /// @notice Enables a controller for an account.\\n    /// @dev A controller is a vault that has been chosen for an account to have special control over accounts\\n    /// balances in the enabled collaterals vaults. Only the owner or an operator of the account can call this function.\\n    /// Unless it's a duplicate, the controller is added to the end of the array. Transiently, there can be at most 10\\n    /// unique controllers enabled at a time, but at most one can be enabled after the outermost checks-deferrable\\n    /// call concludes. Account status checks are performed.\\n    /// @param account The address for which the controller is being enabled.\\n    /// @param vault The address of the controller being enabled.\\n    function enableController(address account, address vault) external payable;\\n\\n    /// @notice Disables a controller for an account.\\n    /// @dev A controller is a vault that has been chosen for an account to have special control over accounts\\n    /// balances in the enabled collaterals vaults. Only the vault itself can call this function. Disabling a controller\\n    /// might change the order of controllers in the array obtained using getControllers function. Account status checks\\n    /// are performed.\\n    /// @param account The address for which the calling controller is being disabled.\\n    function disableController(address account) external payable;\\n\\n    /// @notice Executes signed arbitrary data by self-calling into the EVC.\\n    /// @dev Low-level call function is used to execute the arbitrary data signed by the owner or the operator on the\\n    /// EVC contract. During that call, EVC becomes msg.sender.\\n    /// @param signer The address signing the permit message (ECDSA) or verifying the permit message signature\\n    /// (ERC-1271). It's also the owner or the operator of all the accounts for which authentication will be needed\\n    /// during the execution of the arbitrary data call.\\n    /// @param sender The address of the msg.sender which is expected to execute the data signed by the signer. If\\n    /// address(0) is passed, the msg.sender is ignored.\\n    /// @param nonceNamespace The nonce namespace for which the nonce is being used.\\n    /// @param nonce The nonce for the given account and nonce namespace. A valid nonce value is considered to be the\\n    /// value currently stored and can take any value between 0 and type(uint256).max - 1.\\n    /// @param deadline The timestamp after which the permit is considered expired.\\n    /// @param value The amount of value to be forwarded with the call. If the value is type(uint256).max, the whole\\n    /// balance of the EVC contract will be forwarded.\\n    /// @param data The encoded data which is self-called on the EVC contract.\\n    /// @param signature The signature of the data signed by the signer.\\n    function permit(\\n        address signer,\\n        address sender,\\n        uint256 nonceNamespace,\\n        uint256 nonce,\\n        uint256 deadline,\\n        uint256 value,\\n        bytes calldata data,\\n        bytes calldata signature\\n    ) external payable;\\n\\n    /// @notice Calls into a target contract as per data encoded.\\n    /// @dev This function defers the account and vault status checks (it's a checks-deferrable call). If the outermost\\n    /// call ends, the account and vault status checks are performed.\\n    /// @dev This function can be used to interact with any contract while checks are deferred. If the target contract\\n    /// is msg.sender, msg.sender is called back with the calldata provided and the context set up according to the\\n    /// account provided. If the target contract is not msg.sender, only the owner or the operator of the account\\n    /// provided can call this function.\\n    /// @dev This function can be used to recover the remaining value from the EVC contract.\\n    /// @param targetContract The address of the contract to be called.\\n    /// @param onBehalfOfAccount  If the target contract is msg.sender, the address of the account which will be set\\n    /// in the context. It assumes msg.sender has authenticated the account themselves. If the target contract is\\n    /// not msg.sender, the address of the account for which it is checked whether msg.sender is authorized to act\\n    /// on behalf of.\\n    /// @param value The amount of value to be forwarded with the call. If the value is type(uint256).max, the whole\\n    /// balance of the EVC contract will be forwarded.\\n    /// @param data The encoded data which is called on the target contract.\\n    /// @return result The result of the call.\\n    function call(\\n        address targetContract,\\n        address onBehalfOfAccount,\\n        uint256 value,\\n        bytes calldata data\\n    ) external payable returns (bytes memory result);\\n\\n    /// @notice For a given account, calls into one of the enabled collateral vaults from the currently enabled\\n    /// controller vault as per data encoded.\\n    /// @dev This function defers the account and vault status checks (it's a checks-deferrable call). If the outermost\\n    /// call ends, the account and vault status checks are performed.\\n    /// @dev This function can be used to interact with any contract while checks are deferred as long as the contract\\n    /// is enabled as a collateral of the account and the msg.sender is the only enabled controller of the account.\\n    /// @param targetCollateral The collateral address to be called.\\n    /// @param onBehalfOfAccount The address of the account for which it is checked whether msg.sender is authorized to\\n    /// act on behalf.\\n    /// @param value The amount of value to be forwarded with the call. If the value is type(uint256).max, the whole\\n    /// balance of the EVC contract will be forwarded.\\n    /// @param data The encoded data which is called on the target collateral.\\n    /// @return result The result of the call.\\n    function controlCollateral(\\n        address targetCollateral,\\n        address onBehalfOfAccount,\\n        uint256 value,\\n        bytes calldata data\\n    ) external payable returns (bytes memory result);\\n\\n    /// @notice Executes multiple calls into the target contracts while checks deferred as per batch items provided.\\n    /// @dev This function defers the account and vault status checks (it's a checks-deferrable call). If the outermost\\n    /// call ends, the account and vault status checks are performed.\\n    /// @dev The authentication rules for each batch item are the same as for the call function.\\n    /// @param items An array of batch items to be executed.\\n    function batch(BatchItem[] calldata items) external payable;\\n\\n    /// @notice Executes multiple calls into the target contracts while checks deferred as per batch items provided.\\n    /// @dev This function always reverts as it's only used for simulation purposes. This function cannot be called\\n    /// within a checks-deferrable call.\\n    /// @param items An array of batch items to be executed.\\n    function batchRevert(BatchItem[] calldata items) external payable;\\n\\n    /// @notice Executes multiple calls into the target contracts while checks deferred as per batch items provided.\\n    /// @dev This function does not modify state and should only be used for simulation purposes. This function cannot\\n    /// be called within a checks-deferrable call.\\n    /// @param items An array of batch items to be executed.\\n    /// @return batchItemsResult An array of batch item results for each item.\\n    /// @return accountsStatusCheckResult An array of account status check results for each account.\\n    /// @return vaultsStatusCheckResult An array of vault status check results for each vault.\\n    function batchSimulation(BatchItem[] calldata items)\\n        external\\n        payable\\n        returns (\\n            BatchItemResult[] memory batchItemsResult,\\n            StatusCheckResult[] memory accountsStatusCheckResult,\\n            StatusCheckResult[] memory vaultsStatusCheckResult\\n        );\\n\\n    /// @notice Retrieves the timestamp of the last successful account status check performed for a specific account.\\n    /// @dev This function reverts if the checks are in progress.\\n    /// @dev The account status check is considered to be successful if it calls into the selected controller vault and\\n    /// obtains expected magic value. This timestamp does not change if the account status is considered valid when no\\n    /// controller enabled. When consuming, one might need to ensure that the account status check is not deferred at\\n    /// the moment.\\n    /// @param account The address of the account for which the last status check timestamp is being queried.\\n    /// @return The timestamp of the last status check as a uint256.\\n    function getLastAccountStatusCheckTimestamp(address account) external view returns (uint256);\\n\\n    /// @notice Checks whether the status check is deferred for a given account.\\n    /// @dev This function reverts if the checks are in progress.\\n    /// @param account The address of the account for which it is checked whether the status check is deferred.\\n    /// @return A boolean flag that indicates whether the status check is deferred or not.\\n    function isAccountStatusCheckDeferred(address account) external view returns (bool);\\n\\n    /// @notice Checks the status of an account and reverts if it is not valid.\\n    /// @dev If checks deferred, the account is added to the set of accounts to be checked at the end of the outermost\\n    /// checks-deferrable call. There can be at most 10 unique accounts added to the set at a time. Account status\\n    /// check is performed by calling into the selected controller vault and passing the array of currently enabled\\n    /// collaterals. If controller is not selected, the account is always considered valid.\\n    /// @param account The address of the account to be checked.\\n    function requireAccountStatusCheck(address account) external payable;\\n\\n    /// @notice Forgives previously deferred account status check.\\n    /// @dev Account address is removed from the set of addresses for which status checks are deferred. This function\\n    /// can only be called by the currently enabled controller of a given account. Depending on the vault\\n    /// implementation, may be needed in the liquidation flow.\\n    /// @param account The address of the account for which the status check is forgiven.\\n    function forgiveAccountStatusCheck(address account) external payable;\\n\\n    /// @notice Checks whether the status check is deferred for a given vault.\\n    /// @dev This function reverts if the checks are in progress.\\n    /// @param vault The address of the vault for which it is checked whether the status check is deferred.\\n    /// @return A boolean flag that indicates whether the status check is deferred or not.\\n    function isVaultStatusCheckDeferred(address vault) external view returns (bool);\\n\\n    /// @notice Checks the status of a vault and reverts if it is not valid.\\n    /// @dev If checks deferred, the vault is added to the set of vaults to be checked at the end of the outermost\\n    /// checks-deferrable call. There can be at most 10 unique vaults added to the set at a time. This function can\\n    /// only be called by the vault itself.\\n    function requireVaultStatusCheck() external payable;\\n\\n    /// @notice Forgives previously deferred vault status check.\\n    /// @dev Vault address is removed from the set of addresses for which status checks are deferred. This function can\\n    /// only be called by the vault itself.\\n    function forgiveVaultStatusCheck() external payable;\\n\\n    /// @notice Checks the status of an account and a vault and reverts if it is not valid.\\n    /// @dev If checks deferred, the account and the vault are added to the respective sets of accounts and vaults to be\\n    /// checked at the end of the outermost checks-deferrable call. Account status check is performed by calling into\\n    /// selected controller vault and passing the array of currently enabled collaterals. If controller is not selected,\\n    /// the account is always considered valid. This function can only be called by the vault itself.\\n    /// @param account The address of the account to be checked.\\n    function requireAccountAndVaultStatusCheck(address account) external payable;\\n}\\n\"},\"lib/euler-vault-kit/lib/ethereum-vault-connector/src/interfaces/IVault.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.8.0;\\n\\n/// @title IVault\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice This interface defines the methods for the Vault for the purpose of integration with the Ethereum Vault\\n/// Connector.\\ninterface IVault {\\n    /// @notice Disables a controller (this vault) for the authenticated account.\\n    /// @dev A controller is a vault that has been chosen for an account to have special control over accounts\\n    /// balances in the enabled collaterals vaults. User calls this function in order for the vault to disable itself\\n    /// for the account if the conditions are met (i.e. user has repaid debt in full). If the conditions are not met,\\n    /// the function reverts.\\n    function disableController() external;\\n\\n    /// @notice Checks the status of an account.\\n    /// @dev This function must only deliberately revert if the account status is invalid. If this function reverts due\\n    /// to any other reason, it may render the account unusable with possibly no way to recover funds.\\n    /// @param account The address of the account to be checked.\\n    /// @param collaterals The array of enabled collateral addresses to be considered for the account status check.\\n    /// @return magicValue Must return the bytes4 magic value 0xb168c58f (which is a selector of this function) when\\n    /// account status is valid, or revert otherwise.\\n    function checkAccountStatus(\\n        address account,\\n        address[] calldata collaterals\\n    ) external view returns (bytes4 magicValue);\\n\\n    /// @notice Checks the status of the vault.\\n    /// @dev This function must only deliberately revert if the vault status is invalid. If this function reverts due to\\n    /// any other reason, it may render some accounts unusable with possibly no way to recover funds.\\n    /// @return magicValue Must return the bytes4 magic value 0x4b3d1223 (which is a selector of this function) when\\n    /// account status is valid, or revert otherwise.\\n    function checkVaultStatus() external returns (bytes4 magicValue);\\n}\\n\"},\"lib/euler-vault-kit/src/EVault/IEVault.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.8.0;\\n\\nimport {IVault as IEVCVault} from \\\"ethereum-vault-connector/interfaces/IVault.sol\\\";\\n\\n// Full interface of EVault and all it's modules\\n\\n/// @title IInitialize\\n/// @notice Interface of the initialization module of EVault\\ninterface IInitialize {\\n    /// @notice Initialization of the newly deployed proxy contract\\n    /// @param proxyCreator Account which created the proxy or should be the initial governor\\n    function initialize(address proxyCreator) external;\\n}\\n\\n/// @title IERC20\\n/// @notice Interface of the EVault's Initialize module\\ninterface IERC20 {\\n    /// @notice Vault share token (eToken) name, ie \\\"Euler Vault: DAI\\\"\\n    /// @return The name of the eToken\\n    function name() external view returns (string memory);\\n\\n    /// @notice Vault share token (eToken) symbol, ie \\\"eDAI\\\"\\n    /// @return The symbol of the eToken\\n    function symbol() external view returns (string memory);\\n\\n    /// @notice Decimals, the same as the asset's or 18 if the asset doesn't implement `decimals()`\\n    /// @return The decimals of the eToken\\n    function decimals() external view returns (uint8);\\n\\n    /// @notice Sum of all eToken balances\\n    /// @return The total supply of the eToken\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Balance of a particular account, in eTokens\\n    /// @param account Address to query\\n    /// @return The balance of the account\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /// @notice Retrieve the current allowance\\n    /// @param holder The account holding the eTokens\\n    /// @param spender Trusted address\\n    /// @return The allowance from holder for spender\\n    function allowance(address holder, address spender) external view returns (uint256);\\n\\n    /// @notice Transfer eTokens to another address\\n    /// @param to Recipient account\\n    /// @param amount In shares.\\n    /// @return True if transfer succeeded\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /// @notice Transfer eTokens from one address to another\\n    /// @param from This address must've approved the to address\\n    /// @param to Recipient account\\n    /// @param amount In shares\\n    /// @return True if transfer succeeded\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n\\n    /// @notice Allow spender to access an amount of your eTokens\\n    /// @param spender Trusted address\\n    /// @param amount Use max uint for \\\"infinite\\\" allowance\\n    /// @return True if approval succeeded\\n    function approve(address spender, uint256 amount) external returns (bool);\\n}\\n\\n/// @title IToken\\n/// @notice Interface of the EVault's Token module\\ninterface IToken is IERC20 {\\n    /// @notice Transfer the full eToken balance of an address to another\\n    /// @param from This address must've approved the to address\\n    /// @param to Recipient account\\n    /// @return True if transfer succeeded\\n    function transferFromMax(address from, address to) external returns (bool);\\n}\\n\\n/// @title IERC4626\\n/// @notice Interface of an ERC4626 vault\\ninterface IERC4626 {\\n    /// @notice Vault's underlying asset\\n    /// @return The vault's underlying asset\\n    function asset() external view returns (address);\\n\\n    /// @notice Total amount of managed assets, cash and borrows\\n    /// @return The total amount of assets\\n    function totalAssets() external view returns (uint256);\\n\\n    /// @notice Calculate amount of assets corresponding to the requested shares amount\\n    /// @param shares Amount of shares to convert\\n    /// @return The amount of assets\\n    function convertToAssets(uint256 shares) external view returns (uint256);\\n\\n    /// @notice Calculate amount of shares corresponding to the requested assets amount\\n    /// @param assets Amount of assets to convert\\n    /// @return The amount of shares\\n    function convertToShares(uint256 assets) external view returns (uint256);\\n\\n    /// @notice Fetch the maximum amount of assets a user can deposit\\n    /// @param account Address to query\\n    /// @return The max amount of assets the account can deposit\\n    function maxDeposit(address account) external view returns (uint256);\\n\\n    /// @notice Calculate an amount of shares that would be created by depositing assets\\n    /// @param assets Amount of assets deposited\\n    /// @return Amount of shares received\\n    function previewDeposit(uint256 assets) external view returns (uint256);\\n\\n    /// @notice Fetch the maximum amount of shares a user can mint\\n    /// @param account Address to query\\n    /// @return The max amount of shares the account can mint\\n    function maxMint(address account) external view returns (uint256);\\n\\n    /// @notice Calculate an amount of assets that would be required to mint requested amount of shares\\n    /// @param shares Amount of shares to be minted\\n    /// @return Required amount of assets\\n    function previewMint(uint256 shares) external view returns (uint256);\\n\\n    /// @notice Fetch the maximum amount of assets a user is allowed to withdraw\\n    /// @param owner Account holding the shares\\n    /// @return The maximum amount of assets the owner is allowed to withdraw\\n    function maxWithdraw(address owner) external view returns (uint256);\\n\\n    /// @notice Calculate the amount of shares that will be burned when withdrawing requested amount of assets\\n    /// @param assets Amount of assets withdrawn\\n    /// @return Amount of shares burned\\n    function previewWithdraw(uint256 assets) external view returns (uint256);\\n\\n    /// @notice Fetch the maximum amount of shares a user is allowed to redeem for assets\\n    /// @param owner Account holding the shares\\n    /// @return The maximum amount of shares the owner is allowed to redeem\\n    function maxRedeem(address owner) external view returns (uint256);\\n\\n    /// @notice Calculate the amount of assets that will be transferred when redeeming requested amount of shares\\n    /// @param shares Amount of shares redeemed\\n    /// @return Amount of assets transferred\\n    function previewRedeem(uint256 shares) external view returns (uint256);\\n\\n    /// @notice Transfer requested amount of underlying tokens from sender to the vault pool in return for shares\\n    /// @param amount Amount of assets to deposit (use max uint256 for full underlying token balance)\\n    /// @param receiver An account to receive the shares\\n    /// @return Amount of shares minted\\n    /// @dev Deposit will round down the amount of assets that are converted to shares. To prevent losses consider using\\n    /// mint instead.\\n    function deposit(uint256 amount, address receiver) external returns (uint256);\\n\\n    /// @notice Transfer underlying tokens from sender to the vault pool in return for requested amount of shares\\n    /// @param amount Amount of shares to be minted\\n    /// @param receiver An account to receive the shares\\n    /// @return Amount of assets deposited\\n    function mint(uint256 amount, address receiver) external returns (uint256);\\n\\n    /// @notice Transfer requested amount of underlying tokens from the vault and decrease account's shares balance\\n    /// @param amount Amount of assets to withdraw\\n    /// @param receiver Account to receive the withdrawn assets\\n    /// @param owner Account holding the shares to burn\\n    /// @return Amount of shares burned\\n    function withdraw(uint256 amount, address receiver, address owner) external returns (uint256);\\n\\n    /// @notice Burn requested shares and transfer corresponding underlying tokens from the vault to the receiver\\n    /// @param amount Amount of shares to burn (use max uint256 to burn full owner balance)\\n    /// @param receiver Account to receive the withdrawn assets\\n    /// @param owner Account holding the shares to burn.\\n    /// @return Amount of assets transferred\\n    function redeem(uint256 amount, address receiver, address owner) external returns (uint256);\\n}\\n\\n/// @title IVault\\n/// @notice Interface of the EVault's Vault module\\ninterface IVault is IERC4626 {\\n    /// @notice Balance of the fees accumulator, in shares\\n    /// @return The accumulated fees in shares\\n    function accumulatedFees() external view returns (uint256);\\n\\n    /// @notice Balance of the fees accumulator, in underlying units\\n    /// @return The accumulated fees in asset units\\n    function accumulatedFeesAssets() external view returns (uint256);\\n\\n    /// @notice Address of the original vault creator\\n    /// @return The address of the creator\\n    function creator() external view returns (address);\\n\\n    /// @notice Creates shares for the receiver, from excess asset balances of the vault (not accounted for in `cash`)\\n    /// @param amount Amount of assets to claim (use max uint256 to claim all available assets)\\n    /// @param receiver An account to receive the shares\\n    /// @return Amount of shares minted\\n    /// @dev Could be used as an alternative deposit flow in certain scenarios. E.g. swap directly to the vault, call\\n    /// `skim` to claim deposit.\\n    function skim(uint256 amount, address receiver) external returns (uint256);\\n}\\n\\n/// @title IBorrowing\\n/// @notice Interface of the EVault's Borrowing module\\ninterface IBorrowing {\\n    /// @notice Sum of all outstanding debts, in underlying units (increases as interest is accrued)\\n    /// @return The total borrows in asset units\\n    function totalBorrows() external view returns (uint256);\\n\\n    /// @notice Sum of all outstanding debts, in underlying units scaled up by shifting\\n    /// INTERNAL_DEBT_PRECISION_SHIFT bits\\n    /// @return The total borrows in internal debt precision\\n    function totalBorrowsExact() external view returns (uint256);\\n\\n    /// @notice Balance of vault assets as tracked by deposits/withdrawals and borrows/repays\\n    /// @return The amount of assets the vault tracks as current direct holdings\\n    function cash() external view returns (uint256);\\n\\n    /// @notice Debt owed by a particular account, in underlying units\\n    /// @param account Address to query\\n    /// @return The debt of the account in asset units\\n    function debtOf(address account) external view returns (uint256);\\n\\n    /// @notice Debt owed by a particular account, in underlying units scaled up by shifting\\n    /// INTERNAL_DEBT_PRECISION_SHIFT bits\\n    /// @param account Address to query\\n    /// @return The debt of the account in internal precision\\n    function debtOfExact(address account) external view returns (uint256);\\n\\n    /// @notice Retrieves the current interest rate for an asset\\n    /// @return The interest rate in yield-per-second, scaled by 10**27\\n    function interestRate() external view returns (uint256);\\n\\n    /// @notice Retrieves the current interest rate accumulator for an asset\\n    /// @return An opaque accumulator that increases as interest is accrued\\n    function interestAccumulator() external view returns (uint256);\\n\\n    /// @notice Returns an address of the sidecar DToken\\n    /// @return The address of the DToken\\n    function dToken() external view returns (address);\\n\\n    /// @notice Transfer underlying tokens from the vault to the sender, and increase sender's debt\\n    /// @param amount Amount of assets to borrow (use max uint256 for all available tokens)\\n    /// @param receiver Account receiving the borrowed tokens\\n    /// @return Amount of assets borrowed\\n    function borrow(uint256 amount, address receiver) external returns (uint256);\\n\\n    /// @notice Transfer underlying tokens from the sender to the vault, and decrease receiver's debt\\n    /// @param amount Amount of debt to repay in assets (use max uint256 for full debt)\\n    /// @param receiver Account holding the debt to be repaid\\n    /// @return Amount of assets repaid\\n    function repay(uint256 amount, address receiver) external returns (uint256);\\n\\n    /// @notice Pay off liability with shares (\\\"self-repay\\\")\\n    /// @param amount In asset units (use max uint256 to repay the debt in full or up to the available deposit)\\n    /// @param receiver Account to remove debt from by burning sender's shares\\n    /// @return shares Amount of shares burned\\n    /// @return debt Amount of debt removed in assets\\n    /// @dev Equivalent to withdrawing and repaying, but no assets are needed to be present in the vault\\n    /// @dev Contrary to a regular `repay`, if account is unhealthy, the repay amount must bring the account back to\\n    /// health, or the operation will revert during account status check\\n    function repayWithShares(uint256 amount, address receiver) external returns (uint256 shares, uint256 debt);\\n\\n    /// @notice Take over debt from another account\\n    /// @param amount Amount of debt in asset units (use max uint256 for all the account's debt)\\n    /// @param from Account to pull the debt from\\n    /// @dev Due to internal debt precision accounting, the liability reported on either or both accounts after\\n    /// calling `pullDebt` may not match the `amount` requested precisely\\n    function pullDebt(uint256 amount, address from) external;\\n\\n    /// @notice Request a flash-loan. A onFlashLoan() callback in msg.sender will be invoked, which must repay the loan\\n    /// to the main Euler address prior to returning.\\n    /// @param amount In asset units\\n    /// @param data Passed through to the onFlashLoan() callback, so contracts don't need to store transient data in\\n    /// storage\\n    function flashLoan(uint256 amount, bytes calldata data) external;\\n\\n    /// @notice Updates interest accumulator and totalBorrows, credits reserves, re-targets interest rate, and logs\\n    /// vault status\\n    function touch() external;\\n}\\n\\n/// @title ILiquidation\\n/// @notice Interface of the EVault's Liquidation module\\ninterface ILiquidation {\\n    /// @notice Checks to see if a liquidation would be profitable, without actually doing anything\\n    /// @param liquidator Address that will initiate the liquidation\\n    /// @param violator Address that may be in collateral violation\\n    /// @param collateral Collateral which is to be seized\\n    /// @return maxRepay Max amount of debt that can be repaid, in asset units\\n    /// @return maxYield Yield in collateral corresponding to max allowed amount of debt to be repaid, in collateral\\n    /// balance (shares for vaults)\\n    function checkLiquidation(address liquidator, address violator, address collateral)\\n        external\\n        view\\n        returns (uint256 maxRepay, uint256 maxYield);\\n\\n    /// @notice Attempts to perform a liquidation\\n    /// @param violator Address that may be in collateral violation\\n    /// @param collateral Collateral which is to be seized\\n    /// @param repayAssets The amount of underlying debt to be transferred from violator to sender, in asset units (use\\n    /// max uint256 to repay the maximum possible amount). Meant as slippage check together with `minYieldBalance`\\n    /// @param minYieldBalance The minimum acceptable amount of collateral to be transferred from violator to sender, in\\n    /// collateral balance units (shares for vaults).  Meant as slippage check together with `repayAssets`\\n    /// @dev If `repayAssets` is set to max uint256 it is assumed the caller will perform their own slippage checks to\\n    /// make sure they are not taking on too much debt. This option is mainly meant for smart contract liquidators\\n    function liquidate(address violator, address collateral, uint256 repayAssets, uint256 minYieldBalance) external;\\n}\\n\\n/// @title IRiskManager\\n/// @notice Interface of the EVault's RiskManager module\\ninterface IRiskManager is IEVCVault {\\n    /// @notice Retrieve account's total liquidity\\n    /// @param account Account holding debt in this vault\\n    /// @param liquidation Flag to indicate if the calculation should be performed in liquidation vs account status\\n    /// check mode, where different LTV values might apply.\\n    /// @return collateralValue Total risk adjusted value of all collaterals in unit of account\\n    /// @return liabilityValue Value of debt in unit of account\\n    function accountLiquidity(address account, bool liquidation)\\n        external\\n        view\\n        returns (uint256 collateralValue, uint256 liabilityValue);\\n\\n    /// @notice Retrieve account's liquidity per collateral\\n    /// @param account Account holding debt in this vault\\n    /// @param liquidation Flag to indicate if the calculation should be performed in liquidation vs account status\\n    /// check mode, where different LTV values might apply.\\n    /// @return collaterals Array of collaterals enabled\\n    /// @return collateralValues Array of risk adjusted collateral values corresponding to items in collaterals array.\\n    /// In unit of account\\n    /// @return liabilityValue Value of debt in unit of account\\n    function accountLiquidityFull(address account, bool liquidation)\\n        external\\n        view\\n        returns (address[] memory collaterals, uint256[] memory collateralValues, uint256 liabilityValue);\\n\\n    /// @notice Release control of the account on EVC if no outstanding debt is present\\n    function disableController() external;\\n\\n    /// @notice Checks the status of an account and reverts if account is not healthy\\n    /// @param account The address of the account to be checked\\n    /// @return magicValue Must return the bytes4 magic value 0xb168c58f (which is a selector of this function) when\\n    /// account status is valid, or revert otherwise.\\n    /// @dev Only callable by EVC during status checks\\n    function checkAccountStatus(address account, address[] calldata collaterals) external view returns (bytes4);\\n\\n    /// @notice Checks the status of the vault and reverts if caps are exceeded\\n    /// @return magicValue Must return the bytes4 magic value 0x4b3d1223 (which is a selector of this function) when\\n    /// account status is valid, or revert otherwise.\\n    /// @dev Only callable by EVC during status checks\\n    function checkVaultStatus() external returns (bytes4);\\n}\\n\\n/// @title IBalanceForwarder\\n/// @notice Interface of the EVault's BalanceForwarder module\\ninterface IBalanceForwarder {\\n    /// @notice Retrieve the address of rewards contract, tracking changes in account's balances\\n    /// @return The balance tracker address\\n    function balanceTrackerAddress() external view returns (address);\\n\\n    /// @notice Retrieves boolean indicating if the account opted in to forward balance changes to the rewards contract\\n    /// @param account Address to query\\n    /// @return True if balance forwarder is enabled\\n    function balanceForwarderEnabled(address account) external view returns (bool);\\n\\n    /// @notice Enables balance forwarding for the authenticated account\\n    /// @dev Only the authenticated account can enable balance forwarding for itself\\n    /// @dev Should call the IBalanceTracker hook with the current account's balance\\n    function enableBalanceForwarder() external;\\n\\n    /// @notice Disables balance forwarding for the authenticated account\\n    /// @dev Only the authenticated account can disable balance forwarding for itself\\n    /// @dev Should call the IBalanceTracker hook with the account's balance of 0\\n    function disableBalanceForwarder() external;\\n}\\n\\n/// @title IGovernance\\n/// @notice Interface of the EVault's Governance module\\ninterface IGovernance {\\n    /// @notice Retrieves the address of the governor\\n    /// @return The governor address\\n    function governorAdmin() external view returns (address);\\n\\n    /// @notice Retrieves address of the governance fee receiver\\n    /// @return The fee receiver address\\n    function feeReceiver() external view returns (address);\\n\\n    /// @notice Retrieves the interest fee in effect for the vault\\n    /// @return Amount of interest that is redirected as a fee, as a fraction scaled by 1e4\\n    function interestFee() external view returns (uint16);\\n\\n    /// @notice Looks up an asset's currently configured interest rate model\\n    /// @return Address of the interest rate contract or address zero to indicate 0% interest\\n    function interestRateModel() external view returns (address);\\n\\n    /// @notice Retrieves the ProtocolConfig address\\n    /// @return The protocol config address\\n    function protocolConfigAddress() external view returns (address);\\n\\n    /// @notice Retrieves the protocol fee share\\n    /// @return A percentage share of fees accrued belonging to the protocol, in 1e4 scale\\n    function protocolFeeShare() external view returns (uint256);\\n\\n    /// @notice Retrieves the address which will receive protocol's fees\\n    /// @notice The protocol fee receiver address\\n    function protocolFeeReceiver() external view returns (address);\\n\\n    /// @notice Retrieves supply and borrow caps in AmountCap format\\n    /// @return supplyCap The supply cap in AmountCap format\\n    /// @return borrowCap The borrow cap in AmountCap format\\n    function caps() external view returns (uint16 supplyCap, uint16 borrowCap);\\n\\n    /// @notice Retrieves the borrow LTV of the collateral, which is used to determine if the account is healthy during\\n    /// account status checks.\\n    /// @param collateral The address of the collateral to query\\n    /// @return Borrowing LTV in 1e4 scale\\n    function LTVBorrow(address collateral) external view returns (uint16);\\n\\n    /// @notice Retrieves the current liquidation LTV, which is used to determine if the account is eligible for\\n    /// liquidation\\n    /// @param collateral The address of the collateral to query\\n    /// @return Liquidation LTV in 1e4 scale\\n    function LTVLiquidation(address collateral) external view returns (uint16);\\n\\n    /// @notice Retrieves LTV configuration for the collateral\\n    /// @param collateral Collateral asset\\n    /// @return borrowLTV The current value of borrow LTV for originating positions\\n    /// @return liquidationLTV The value of fully converged liquidation LTV\\n    /// @return initialLiquidationLTV The initial value of the liquidation LTV, when the ramp began\\n    /// @return targetTimestamp The timestamp when the liquidation LTV is considered fully converged\\n    /// @return rampDuration The time it takes for the liquidation LTV to converge from the initial value to the fully\\n    /// converged value\\n    function LTVFull(address collateral)\\n        external\\n        view\\n        returns (\\n            uint16 borrowLTV,\\n            uint16 liquidationLTV,\\n            uint16 initialLiquidationLTV,\\n            uint48 targetTimestamp,\\n            uint32 rampDuration\\n        );\\n\\n    /// @notice Retrieves a list of collaterals with configured LTVs\\n    /// @return List of asset collaterals\\n    /// @dev Returned assets could have the ltv disabled (set to zero)\\n    function LTVList() external view returns (address[] memory);\\n\\n    /// @notice Retrieves the maximum liquidation discount\\n    /// @return The maximum liquidation discount in 1e4 scale\\n    /// @dev The default value, which is zero, is deliberately bad, as it means there would be no incentive to liquidate\\n    /// unhealthy users. The vault creator must take care to properly select the limit, given the underlying and\\n    /// collaterals used.\\n    function maxLiquidationDiscount() external view returns (uint16);\\n\\n    /// @notice Retrieves liquidation cool-off time, which must elapse after successful account status check before\\n    /// account can be liquidated\\n    /// @return The liquidation cool off time in seconds\\n    function liquidationCoolOffTime() external view returns (uint16);\\n\\n    /// @notice Retrieves a hook target and a bitmask indicating which operations call the hook target\\n    /// @return hookTarget Address of the hook target contract\\n    /// @return hookedOps Bitmask with operations that should call the hooks. See Constants.sol for a list of operations\\n    function hookConfig() external view returns (address hookTarget, uint32 hookedOps);\\n\\n    /// @notice Retrieves a bitmask indicating enabled config flags\\n    /// @return Bitmask with config flags enabled\\n    function configFlags() external view returns (uint32);\\n\\n    /// @notice Address of EthereumVaultConnector contract\\n    /// @return The EVC address\\n    function EVC() external view returns (address);\\n\\n    /// @notice Retrieves a reference asset used for liquidity calculations\\n    /// @return The address of the reference asset\\n    function unitOfAccount() external view returns (address);\\n\\n    /// @notice Retrieves the address of the oracle contract\\n    /// @return The address of the oracle\\n    function oracle() external view returns (address);\\n\\n    /// @notice Retrieves the Permit2 contract address\\n    /// @return The address of the Permit2 contract\\n    function permit2Address() external view returns (address);\\n\\n    /// @notice Splits accrued fees balance according to protocol fee share and transfers shares to the governor fee\\n    /// receiver and protocol fee receiver\\n    function convertFees() external;\\n\\n    /// @notice Set a new governor address\\n    /// @param newGovernorAdmin The new governor address\\n    /// @dev Set to zero address to renounce privileges and make the vault non-governed\\n    function setGovernorAdmin(address newGovernorAdmin) external;\\n\\n    /// @notice Set a new governor fee receiver address\\n    /// @param newFeeReceiver The new fee receiver address\\n    function setFeeReceiver(address newFeeReceiver) external;\\n\\n    /// @notice Set a new LTV config\\n    /// @param collateral Address of collateral to set LTV for\\n    /// @param borrowLTV New borrow LTV, for assessing account's health during account status checks, in 1e4 scale\\n    /// @param liquidationLTV New liquidation LTV after ramp ends in 1e4 scale\\n    /// @param rampDuration Ramp duration in seconds\\n    function setLTV(address collateral, uint16 borrowLTV, uint16 liquidationLTV, uint32 rampDuration) external;\\n\\n    /// @notice Set a new maximum liquidation discount\\n    /// @param newDiscount New maximum liquidation discount in 1e4 scale\\n    /// @dev If the discount is zero (the default), the liquidators will not be incentivized to liquidate unhealthy\\n    /// accounts\\n    function setMaxLiquidationDiscount(uint16 newDiscount) external;\\n\\n    /// @notice Set a new liquidation cool off time, which must elapse after successful account status check before\\n    /// account can be liquidated\\n    /// @param newCoolOffTime The new liquidation cool off time in seconds\\n    /// @dev Setting cool off time to zero allows liquidating the account in the same block as the last successful\\n    /// account status check\\n    function setLiquidationCoolOffTime(uint16 newCoolOffTime) external;\\n\\n    /// @notice Set a new interest rate model contract\\n    /// @param newModel The new IRM address\\n    /// @dev If the new model reverts, perhaps due to governor error, the vault will silently use a zero interest\\n    /// rate. Governor should make sure the new interest rates are computed as expected.\\n    function setInterestRateModel(address newModel) external;\\n\\n    /// @notice Set a new hook target and a new bitmap indicating which operations should call the hook target.\\n    /// Operations are defined in Constants.sol.\\n    /// @param newHookTarget The new hook target address. Use address(0) to simply disable hooked operations\\n    /// @param newHookedOps Bitmask with the new hooked operations\\n    /// @dev All operations are initially disabled in a newly created vault. The vault creator must set their\\n    /// own configuration to make the vault usable\\n    function setHookConfig(address newHookTarget, uint32 newHookedOps) external;\\n\\n    /// @notice Set new bitmap indicating which config flags should be enabled. Flags are defined in Constants.sol\\n    /// @param newConfigFlags Bitmask with the new config flags\\n    function setConfigFlags(uint32 newConfigFlags) external;\\n\\n    /// @notice Set new supply and borrow caps in AmountCap format\\n    /// @param supplyCap The new supply cap in AmountCap fromat\\n    /// @param borrowCap The new borrow cap in AmountCap fromat\\n    function setCaps(uint16 supplyCap, uint16 borrowCap) external;\\n\\n    /// @notice Set a new interest fee\\n    /// @param newFee The new interest fee\\n    function setInterestFee(uint16 newFee) external;\\n}\\n\\n/// @title IEVault\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice Interface of the EVault, an EVC enabled lending vault\\ninterface IEVault is\\n    IInitialize,\\n    IToken,\\n    IVault,\\n    IBorrowing,\\n    ILiquidation,\\n    IRiskManager,\\n    IBalanceForwarder,\\n    IGovernance\\n{\\n    /// @notice Fetch address of the `Initialize` module\\n    function MODULE_INITIALIZE() external view returns (address);\\n    /// @notice Fetch address of the `Token` module\\n    function MODULE_TOKEN() external view returns (address);\\n    /// @notice Fetch address of the `Vault` module\\n    function MODULE_VAULT() external view returns (address);\\n    /// @notice Fetch address of the `Borrowing` module\\n    function MODULE_BORROWING() external view returns (address);\\n    /// @notice Fetch address of the `Liquidation` module\\n    function MODULE_LIQUIDATION() external view returns (address);\\n    /// @notice Fetch address of the `RiskManager` module\\n    function MODULE_RISKMANAGER() external view returns (address);\\n    /// @notice Fetch address of the `BalanceForwarder` module\\n    function MODULE_BALANCE_FORWARDER() external view returns (address);\\n    /// @notice Fetch address of the `Governance` module\\n    function MODULE_GOVERNANCE() external view returns (address);\\n}\\n\"},\"src/CowEvcBaseWrapper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity ^0.8;\\n\\nimport {IEVC} from \\\"evc/EthereumVaultConnector.sol\\\";\\n\\nimport {CowWrapper, ICowSettlement} from \\\"./CowWrapper.sol\\\";\\nimport {PreApprovedHashes} from \\\"./PreApprovedHashes.sol\\\";\\n\\n/// @title CowEvcBaseWrapper\\n/// @notice Shared components for implementing Euler wrappers.\\nabstract contract CowEvcBaseWrapper is CowWrapper, PreApprovedHashes {\\n    /// @dev location in memory of the parameters describing the wrapper implementation.\\n    type ParamsLocation is bytes32;\\n\\n    IEVC public immutable EVC;\\n\\n    /// @dev The EIP-712 domain type hash used for computing the domain\\n    /// separator.\\n    bytes32 public constant DOMAIN_TYPE_HASH =\\n        keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\");\\n\\n    /// @dev The marker value for a sell order for computing the order struct\\n    /// hash. This allows the EIP-712 compatible wallets to display a\\n    /// descriptive string for the order kind (instead of 0 or 1).\\n    bytes32 internal constant KIND_SELL = keccak256(\\\"sell\\\");\\n\\n    /// @dev The OrderKind marker value for a buy order for computing the order\\n    /// struct hash.\\n    bytes32 internal constant KIND_BUY = keccak256(\\\"buy\\\");\\n\\n    /// @dev Used by EIP-712 signing to prevent signatures from being replayed\\n    bytes32 public immutable DOMAIN_SEPARATOR;\\n\\n    /// @dev The EVC nonce namespace to use when calling `EVC.permit` to authorize this contract.\\n    /// See: https://evc.wtf/docs/concepts/internals/permit/#nonce-namespaces\\n    uint256 public immutable NONCE_NAMESPACE;\\n\\n    /// @dev The length of the parameters consumed by this wrapper. Used in order to know how much data to read after the ParamsLocation for the hash.\\n    /// Ideally this should be computed by creating the parameters struct and then `abi.encode().length` to ensure its always the correct size.\\n    uint256 internal immutable PARAMS_SIZE;\\n\\n    /// @dev The EIP-712 type hash of the parameters structure used by this wrapper.\\n    bytes32 public immutable PARAMS_TYPE_HASH;\\n\\n    /// @dev How long to make the `items` array without calculating it. Determines the maximum number of EVC operations that can be batched.\\n    /// This value depends on the each concrete wrapper implementation. It should include the settlement and any operations before and after it.\\n    uint256 internal immutable MAX_BATCH_OPERATIONS;\\n\\n    /// @dev Indicates that the current operation cannot be completed with the given msgSender\\n    error Unauthorized(address msgSender);\\n\\n    /// @dev Indicates that the pre-approved hash is no longer able to be executed because the block timestamp is too old\\n    error OperationDeadlineExceeded(uint256 validToTimestamp, uint256 currentTimestamp);\\n\\n    /// @dev Indicates that a user attempted to interact with an account that is not their own\\n    error SubaccountMustBeControlledByOwner(address subaccount, address owner);\\n\\n    /// @dev Indicates that the EVC called `evcInternalSettle` in an invalid way\\n    error InvalidCallback();\\n\\n    /// @dev Indicates that neither `_encodeBatchItemsBefore` nor `_encodeBatchItemsAfter` requested permission, meaning the provided permit signature is unused.\\n    error UnusedPermitSignature();\\n\\n    /// @dev Used to ensure that the EVC is calling back this contract with the correct data\\n    bytes32 internal transient expectedEvcInternalSettleCallHash;\\n\\n    constructor(address _evc, ICowSettlement _settlement, bytes32 _domainName, bytes32 _domainVersion)\\n        CowWrapper(_settlement)\\n    {\\n        require(_evc.code.length > 0, \\\"EVC address is invalid\\\");\\n        EVC = IEVC(_evc);\\n        NONCE_NAMESPACE = uint256(uint160(address(this)));\\n        DOMAIN_SEPARATOR =\\n            keccak256(abi.encode(DOMAIN_TYPE_HASH, _domainName, _domainVersion, block.chainid, address(this)));\\n    }\\n\\n    /// @notice Encode batch items to execute before the settlement\\n    /// @dev By default we return the default value (empty array, false).\\n    /// At least one between this function and `_encodeBatchItemsAfter` should need permission (i.e., use the permit signature) for the permit flow to be secure.\\n    /// @param location The memory storage position where the parameters needed to encode the batch items have been saved\\n    /// @return items Array of batch items to execute\\n    /// @return needsPermission Whether these items require user signature or prior authorization as an operator\\n    function _encodeBatchItemsBefore(ParamsLocation location)\\n        internal\\n        view\\n        virtual\\n        returns (IEVC.BatchItem[] memory items, bool needsPermission)\\n    {}\\n\\n    /// @notice Encode batch items to execute after the settlement\\n    /// @dev By default we return the default value (empty array, false).\\n    /// At least one between this function and `_encodeBatchItemsBefore` should need permission (i.e., use the permit signature) for the permit flow to be secure.\\n    /// @param location The memory storage position where the parameters needed to encode the batch items have been saved\\n    /// @return items Array of batch items to execute\\n    /// @return needsPermission Whether these items require user signature or prior authorization as an operator\\n    function _encodeBatchItemsAfter(ParamsLocation location)\\n        internal\\n        view\\n        virtual\\n        returns (IEVC.BatchItem[] memory items, bool needsPermission)\\n    {}\\n\\n    /// @dev This function makes strong assumptions on the memory layout of the struct in memory.\\n    /// It assumes:\\n    ///  - The struct itself doesn't contain any dynamic-length types.\\n    ///  - The struct is encoded in memory with zero padding.\\n    /// @param params The memory location of the struct data\\n    /// @return digest The EIP-712 compliant digest\\n    function _getApprovalHash(ParamsLocation params) internal view returns (bytes32 digest) {\\n        bytes32 structHash;\\n        bytes32 separator = DOMAIN_SEPARATOR;\\n        bytes32 typeHash = PARAMS_TYPE_HASH;\\n        uint256 paramsSize = PARAMS_SIZE;\\n        assembly {\\n            // Build structHash = keccak256(typeHash || encodeData(params))\\n            let wordBeforeParamPtr := sub(params, 0x20)\\n            // Subtraction overflow causes the next line to revert with out of gas if params isn't allocated\\n            let wordBeforeParam := mload(wordBeforeParamPtr)\\n            mstore(wordBeforeParamPtr, typeHash)\\n            structHash := keccak256(wordBeforeParamPtr, add(0x20, paramsSize))\\n            // Restore original content\\n            mstore(wordBeforeParamPtr, wordBeforeParam)\\n\\n            // Build digest = keccak256(\\\"\\\\x19\\\\x01\\\" || domainSeparator || structHash)\\n            let ptr := mload(0x40)\\n            mstore(ptr, \\\"\\\\x19\\\\x01\\\")\\n            mstore(add(ptr, 0x02), separator)\\n            mstore(add(ptr, 0x22), structHash)\\n            digest := keccak256(ptr, 0x42)\\n        }\\n    }\\n\\n    /// @notice Generates the permit data that would be used for the given EVC batch items (presumably generated from params)\\n    function _encodePermitData(IEVC.BatchItem[] memory items, ParamsLocation params)\\n        internal\\n        view\\n        returns (bytes memory)\\n    {\\n        // The abi.encodeCall() part consists of the batch call that we want to execute. The additional data tacked on the end is to ensure\\n        // the provided parameters are all validated against the user signature, even if `items` doesn't completely use the parameters in effect.\\n        return abi.encodePacked(abi.encodeCall(IEVC.batch, items), _getApprovalHash(params));\\n    }\\n\\n    /// @notice This function is called by EVC and continues the CoW settlement process inside an EVC batch while including any necessary security check.\\n    function evcInternalSettle(\\n        bytes calldata settleData,\\n        bytes calldata wrapperData,\\n        bytes calldata remainingWrapperData\\n    ) external {\\n        require(msg.sender == address(EVC), Unauthorized(msg.sender));\\n        require(expectedEvcInternalSettleCallHash == keccak256(msg.data), InvalidCallback());\\n        expectedEvcInternalSettleCallHash = bytes32(0);\\n\\n        _evcInternalSettle(settleData, wrapperData, remainingWrapperData);\\n    }\\n\\n    function _makeInternalSettleCallbackData(\\n        bytes calldata settleData,\\n        bytes calldata wrapperData,\\n        bytes calldata remainingWrapperData\\n    ) internal pure returns (bytes memory) {\\n        return abi.encodeCall(CowEvcBaseWrapper.evcInternalSettle, (settleData, wrapperData, remainingWrapperData));\\n    }\\n\\n    function _invokeEvc(\\n        bytes memory evcInternalSettleCallback,\\n        ParamsLocation param,\\n        bytes memory signature,\\n        address owner,\\n        address account,\\n        uint256 deadline\\n    ) internal {\\n        // Subaccounts in the EVC can be any account that shares the highest 19 bits as the owner.\\n        // Here we verify that the subaccount address has been specified is, in fact, a subaccount of the owner.\\n        // Otherwise its concievably possible that a transfer could happen between an owner with an unauthorized subaccount.\\n        require(bytes19(bytes20(owner)) == bytes19(bytes20(account)), SubaccountMustBeControlledByOwner(account, owner));\\n\\n        // There are 2 ways that this contract can validate user operations: 1) the user pre-approves a hash with an on-chain call and grants this contract ability to operate on the user's behalf, or 2) they issue a signature which can be used to call EVC.permit()\\n        // The choice of the flow is based on whether `signature` has length zero. If so, then we use the hash approval flow (1).\\n        // Otherwise, the signature is assumed to be one for EVC.permit (2).\\n        // The permit signature is verified against the permit generated by `_encodePermitData`; the parameters are validated because they are unequivocally encoded in the signed permit.\\n        if (signature.length == 0) {\\n            _consumePreApprovedHash(owner, _getApprovalHash(param));\\n            // The deadline is checked by `EVC.permit()`, so we only check it here if we are using a pre-approved hash (aka, no signature) which would bypass that call\\n            require(deadline >= block.timestamp, OperationDeadlineExceeded(deadline, block.timestamp));\\n        }\\n\\n        // Build the EVC batch items for swapping collateral\\n        IEVC.BatchItem[] memory items = new IEVC.BatchItem[](MAX_BATCH_OPERATIONS);\\n\\n        uint256 itemIndex = 0;\\n\\n        {\\n            // add any EVC actions that have to be performed before\\n            IEVC.BatchItem[] memory partialItems;\\n            bool needsPermission;\\n            bool permissionRequested = false;\\n\\n            (partialItems, needsPermission) = _encodeBatchItemsBefore(param);\\n            permissionRequested = permissionRequested || needsPermission;\\n            itemIndex = _addEvcBatchItems(\\n                items, partialItems, itemIndex, owner, deadline, needsPermission ? signature : new bytes(0), param\\n            );\\n\\n            // add the EVC callback to this (which calls settlement)\\n            expectedEvcInternalSettleCallHash = keccak256(evcInternalSettleCallback);\\n            items[itemIndex++] = IEVC.BatchItem({\\n                onBehalfOfAccount: address(this),\\n                targetContract: address(this),\\n                value: 0,\\n                data: evcInternalSettleCallback\\n            });\\n\\n            // add the EVC actions that have to be performed after\\n            (partialItems, needsPermission) = _encodeBatchItemsAfter(param);\\n            permissionRequested = permissionRequested || needsPermission;\\n            itemIndex = _addEvcBatchItems(\\n                items, partialItems, itemIndex, owner, deadline, needsPermission ? signature : new bytes(0), param\\n            );\\n\\n            require(permissionRequested, UnusedPermitSignature());\\n        }\\n\\n        // shorten the length of the generated array to its actual length\\n        // We assume as an a invariant that the code above will not generate a `itemIndex` greater than `MAX_BATCH_OPERATIONS` at this point\\n        // because we always add an item to the items array when we increment `itemIndex`, and if the itemIndex goes out of bounds,\\n        // solidity will revert\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(items, itemIndex)\\n        }\\n\\n        // 3. Account status check (automatically done by EVC at end of batch)\\n        // For more info, see: https://evc.wtf/docs/concepts/internals/account-status-checks\\n        // No explicit item needed - EVC handles this\\n\\n        // Execute all items in a single batch\\n        EVC.batch(items);\\n\\n        // The pre approved hash flow needs the user to set this contract as an operator for both the owner address itself and the subaccount.\\n        // The EVC treats owner and subaccount operator authorizations separately, so we need to relinquish them separately\\n        if (signature.length == 0) {\\n            // This function returns both account and subaccount operator authorizations as a bitmask.\\n            // So we can do one call to find out what accounts are authorized, and then remove them as needed.\\n            uint256 mask = EVC.getOperator(bytes19(bytes20(owner)), address(this));\\n\\n            // check subaccount control\\n            // despite the lint, the shift is correct. This is the same way\\n            // the calculation is done in the EthereumVaultConnector contract.\\n            // https://github.com/euler-xyz/ethereum-vault-connector/blob/v1.0.1/src/EthereumVaultConnector.sol#L387\\n            /// forge-lint: disable-next-line(incorrect-shift)\\n            if ((mask & (1 << (uint160(owner) ^ uint160(account)))) > 0) {\\n                EVC.setAccountOperator(account, address(this), false);\\n            }\\n\\n            // check owner account control. If the owner is the subaccount, there is no need to set the operator again.\\n            if (owner != account && mask & 1 > 0) {\\n                EVC.setAccountOperator(owner, address(this), false);\\n            }\\n        }\\n    }\\n\\n    /// @dev Helper function to add IEVC.BatchItem to the EVC.batch call with any authorization that may be required.\\n    /// Depending on whether a signature is provided, this function will either copy `addItems` into `fullItems` at the given position,\\n    /// or `addItems` will be condensed into a single `EVC.permit` call and then added to the batch as a single item.\\n    /// @param fullItems The items which will ultimately be executed by EVC.batch\\n    /// @param addItems The items which need to be added to fullItems with appropriate authorization wrapping as needed\\n    /// @param itemIndex The index in `fullItems` starting from which `addItems` should be written\\n    /// @param owner The owner who is granting permission to execute the operations. Needed to construct the `EVC.permit`\\n    /// @param deadline The time at which the permit signature would expire. needed to construct the `EVC.permit`\\n    /// @param signature The signature used to validate the EVC.permit. If this is set to `new bytes(0)`, no permit will be used, and the items will be copied directly instead.\\n    /// @param param The input parameters for this trade. Needed to construct the `EVC.permit`, as the params data hash is appended to the end of the batch to ensure the signed `EVC.permit` can't be used with parameters that the user didn't sign.\\n    /// @return The index immediately after the last item written to `fullItems`\\n    function _addEvcBatchItems(\\n        IEVC.BatchItem[] memory fullItems,\\n        IEVC.BatchItem[] memory addItems,\\n        uint256 itemIndex,\\n        address owner,\\n        uint256 deadline,\\n        bytes memory signature,\\n        ParamsLocation param\\n    ) internal view returns (uint256) {\\n        // There are two ways this contract can be executed: either the user approves this contract as\\n        // an operator and supplies a pre-approved hash for the operation to take, or they submit a permit hash\\n        // for this specific instance. If its the permit hash route, here we call `permit` instead of `batch` raw so that the EVC can authorize it.\\n        // If there is an issue with the signature, the EVC will revert the batch call, which will bubble up through this contract to revert the entire wrappedSettle call.\\n        if (signature.length > 0) {\\n            fullItems[itemIndex++] = IEVC.BatchItem({\\n                onBehalfOfAccount: address(0),\\n                targetContract: address(EVC),\\n                value: 0,\\n                data: abi.encodeCall(\\n                    IEVC.permit,\\n                    (\\n                        owner,\\n                        address(this),\\n                        uint256(NONCE_NAMESPACE),\\n                        EVC.getNonce(bytes19(bytes20(owner)), NONCE_NAMESPACE),\\n                        deadline,\\n                        0, // value field (no ETH transferred to the EVC)\\n                        _encodePermitData(addItems, param),\\n                        signature\\n                    )\\n                )\\n            });\\n        } else {\\n            // copy the operations to execute. this contract can operate on behalf of the user directly\\n            for (uint256 i; i < addItems.length; i++) {\\n                fullItems[itemIndex + i] = addItems[i];\\n            }\\n\\n            itemIndex += addItems.length;\\n        }\\n\\n        return itemIndex;\\n    }\\n\\n    function _evcInternalSettle(\\n        bytes calldata settleData,\\n        bytes calldata wrapperData,\\n        bytes calldata remainingWrapperData\\n    ) internal virtual;\\n}\\n\"},\"src/CowEvcCollateralSwapWrapper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity ^0.8;\\n\\nimport {IEVC} from \\\"evc/EthereumVaultConnector.sol\\\";\\n\\nimport {CowWrapper, ICowSettlement} from \\\"./CowWrapper.sol\\\";\\nimport {IERC20} from \\\"euler-vault-kit/src/EVault/IEVault.sol\\\";\\nimport {CowEvcBaseWrapper} from \\\"./CowEvcBaseWrapper.sol\\\";\\n\\n/// @title CowEvcCollateralSwapWrapper\\n/// @notice A specialized wrapper for swapping collateral between vaults with EVC\\n/// @dev This wrapper enables atomic collateral swaps by:\\n///      1. Enabling new collateral vault\\n///      2. Transfering collateral from EVC subaccount to main account (if using subaccount)\\n///      3. Executing the settlement contract to swap collateral (new collateral is deposited directly into user's account)\\ncontract CowEvcCollateralSwapWrapper is CowEvcBaseWrapper {\\n    /// @dev The EIP-712 domain name used for computing the domain separator.\\n    bytes32 constant DOMAIN_NAME = keccak256(\\\"CowEvcCollateralSwapWrapper\\\");\\n\\n    /// @dev The EIP-712 domain version used for computing the domain separator.\\n    bytes32 constant DOMAIN_VERSION = keccak256(\\\"1\\\");\\n\\n    /// @dev A descriptive label for this contract, as required by CowWrapper\\n    string public override name = \\\"Euler EVC - Collateral Swap\\\";\\n\\n    /// @dev Emitted when collateral is swapped via this wrapper\\n    event CowEvcCollateralSwapped(\\n        address indexed owner,\\n        address account,\\n        address indexed fromVault,\\n        address indexed toVault,\\n        uint256 fromAmount,\\n        uint256 toAmount\\n    );\\n\\n    constructor(address _evc, ICowSettlement _settlement)\\n        CowEvcBaseWrapper(_evc, _settlement, DOMAIN_NAME, DOMAIN_VERSION)\\n    {\\n        PARAMS_SIZE =\\n        abi.encode(\\n            CollateralSwapParams({\\n                owner: address(0),\\n                account: address(0),\\n                deadline: 0,\\n                fromVault: address(0),\\n                toVault: address(0),\\n                fromAmount: 0,\\n                toAmount: 0\\n            })\\n        )\\n        .length;\\n\\n        MAX_BATCH_OPERATIONS = 3;\\n\\n        PARAMS_TYPE_HASH = keccak256(\\n            \\\"CollateralSwapParams(address owner,address account,uint256 deadline,address fromVault,address toVault,uint256 swapAmount)\\\"\\n        );\\n    }\\n\\n    /// @notice The information necessary to swap collateral between vaults\\n    /// @dev This structure is used, combined with domain separator, to indicate a pre-approved hash.\\n    /// NOTE: If you need to create an order with identical properties to another, ensure that the hash of this structure is unique for this user.\\n    /// when in doubt, the `deadline` can be incremented to create a new unique order params object\\n    struct CollateralSwapParams {\\n        /// @dev The ethereum address that has permission to operate upon the account. In the case that the funds are in a subaccount (i.e. account != owner), collateral will\\n        /// be atomically transferred into this address prior to the CoW settlement.\\n        /// The CoW order should be signed or pre-approved from this address.\\n        address owner;\\n\\n        /// @dev The subaccount from which the old collateral originates, and where the new collateral will be sent. Learn more about Euler subaccounts https://evc.wtf/docs/concepts/internals/sub-accounts\\n        /// The CoW order `receiver` should be set to this value.\\n        address account;\\n\\n        /// @dev A date by which this operation must be completed\\n        uint256 deadline;\\n\\n        /// @dev The source collateral vault (what we're swapping from). Same as `sellToken` in the CoW order\\n        address fromVault;\\n\\n        /// @dev The destination collateral vault (what we're swapping to). Same as `buyToken` in the CoW order\\n        address toVault;\\n\\n        /// @dev The amount of fromVault traded in. Same as `sellAmount` in the CoW order\\n        uint256 fromAmount;\\n\\n        /// @dev The amount of toVault traded out. Same as `buyAmount` in the CoW order\\n        uint256 toAmount;\\n    }\\n\\n    function _parseCollateralSwapParams(bytes calldata wrapperData)\\n        internal\\n        pure\\n        returns (CollateralSwapParams memory params, bytes memory signature)\\n    {\\n        (params, signature) = abi.decode(wrapperData, (CollateralSwapParams, bytes));\\n    }\\n\\n    /// @notice Helper function to compute the hash that would be approved\\n    /// @param params The CollateralSwapParams to hash\\n    /// @return The hash of the signed calldata for these params\\n    function getApprovalHash(CollateralSwapParams memory params) external view returns (bytes32) {\\n        return _getApprovalHash(memoryLocation(params));\\n    }\\n\\n    /// @inheritdoc CowWrapper\\n    function validateWrapperData(bytes calldata wrapperData) external pure override {\\n        // Validate by attempting to parse the wrapper data\\n        // Will revert if the data is malformed\\n        _parseCollateralSwapParams(wrapperData);\\n    }\\n\\n    /// @notice Called by an offchain process to determine what data should be signed in a call to `wrappedSettle`.\\n    /// @param params The parameters object provided as input to the wrapper\\n    /// @return The `EVC` call that would be submitted to `EVC.permit`. This would need to be signed as documented https://evc.wtf/docs/concepts/internals/permit.\\n    function encodePermitData(CollateralSwapParams memory params) external view returns (bytes memory) {\\n        (IEVC.BatchItem[] memory items,) = _encodeBatchItemsBefore(memoryLocation(params));\\n        return _encodePermitData(items, memoryLocation(params));\\n    }\\n\\n    /// @inheritdoc CowEvcBaseWrapper\\n    function _encodeBatchItemsBefore(ParamsLocation paramsLocation)\\n        internal\\n        view\\n        override\\n        returns (IEVC.BatchItem[] memory items, bool needsPermission)\\n    {\\n        CollateralSwapParams memory params = paramsFromMemory(paramsLocation);\\n\\n        items = new IEVC.BatchItem[](params.owner == params.account ? 1 : 2);\\n        if (params.owner != params.account) {\\n            // For the permissioned operation, transfer collateral from subaccount to owner\\n            // (this transfer should be safe for general use because its operating against Euler vault contracts)\\n            items[0] = IEVC.BatchItem({\\n                onBehalfOfAccount: address(params.account),\\n                targetContract: params.fromVault,\\n                value: 0,\\n                data: abi.encodeCall(IERC20.transfer, (params.owner, params.fromAmount))\\n            });\\n        }\\n\\n        // enable the new collateral for account\\n        items[items.length - 1] = IEVC.BatchItem({\\n            onBehalfOfAccount: address(0),\\n            targetContract: address(EVC),\\n            value: 0,\\n            data: abi.encodeCall(EVC.enableCollateral, (params.account, params.toVault))\\n        });\\n\\n        needsPermission = true;\\n    }\\n\\n    /// @inheritdoc CowWrapper\\n    function _wrap(bytes calldata settleData, bytes calldata wrapperData, bytes calldata remainingWrapperData)\\n        internal\\n        override\\n    {\\n        // Decode wrapper data into CollateralSwapParams\\n        (CollateralSwapParams memory params, bytes memory signature) = _parseCollateralSwapParams(wrapperData);\\n\\n        _invokeEvc(\\n            _makeInternalSettleCallbackData(settleData, wrapperData, remainingWrapperData),\\n            memoryLocation(params),\\n            signature,\\n            params.owner,\\n            params.account,\\n            params.deadline\\n        );\\n\\n        // Emit event - funds are now in the account from the settlement\\n        emit CowEvcCollateralSwapped(\\n            params.owner, params.account, params.fromVault, params.toVault, params.fromAmount, params.toAmount\\n        );\\n    }\\n\\n    /// @inheritdoc CowEvcBaseWrapper\\n    function _evcInternalSettle(bytes calldata settleData, bytes calldata, bytes calldata remainingWrapperData)\\n        internal\\n        override\\n    {\\n        // Use CowWrapper's _next to call the settlement contract\\n        // wrapperData is empty since we've already processed it in _wrap\\n        _next(settleData, remainingWrapperData);\\n    }\\n\\n    function memoryLocation(CollateralSwapParams memory params) internal pure returns (ParamsLocation location) {\\n        assembly (\\\"memory-safe\\\") {\\n            location := params\\n        }\\n    }\\n\\n    function paramsFromMemory(ParamsLocation location) internal pure returns (CollateralSwapParams memory params) {\\n        assembly {\\n            params := location\\n        }\\n    }\\n}\\n\"},\"src/CowWrapper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity ^0.8;\\n\\n/**\\n * Title: CoW Wrapper all-in-one integration file\\n * Author: CoW DAO\\n * This file is completely self-contained (ie no dependencies) and can be portably copied to whatever projects it is needed.\\n * It contains:\\n * * CowWrapper -- an abstract base contract which should be inherited by all wrappers\\n * * ICowWrapper -- the required interface for all wrappers\\n * * ICowSettlement -- A minimized interface and base structures for CoW Protocol settlement contract. From https://github.com/cowprotocol/contracts/blob/main/src/contracts/GPv2Settlement.sol\\n * * ICowAuthentication -- The authentication interface used by ICowSettlement. From https://github.com/cowprotocol/contracts/blob/main/src/contracts/interfaces/GPv2Authentication.sol\\n */\\n\\n/// @title CoW Protocol Authentication Interface\\n/// @author CoW DAO developers\\ninterface ICowAuthentication {\\n    /// @dev determines whether the provided address is an authenticated solver.\\n    /// @param prospectiveSolver the address of prospective solver.\\n    /// @return true when prospectiveSolver is an authenticated solver, otherwise false.\\n    function isSolver(address prospectiveSolver) external view returns (bool);\\n}\\n\\n/// @title CoW Protocol Settlement Interface\\n/// @notice Minimal interface for CoW Protocol's settlement contract\\n/// @dev Used for type-safe calls to the settlement contract's settle function\\ninterface ICowSettlement {\\n    /// @notice Trade data structure matching GPv2Settlement\\n    struct Trade {\\n        uint256 sellTokenIndex;\\n        uint256 buyTokenIndex;\\n        address receiver;\\n        uint256 sellAmount;\\n        uint256 buyAmount;\\n        uint32 validTo;\\n        bytes32 appData;\\n        uint256 feeAmount;\\n        uint256 flags;\\n        uint256 executedAmount;\\n        bytes signature;\\n    }\\n\\n    /// @notice Interaction data structure for pre/intra/post-settlement actions which are supplied by the solver to complete the user request\\n    struct Interaction {\\n        address target;\\n        uint256 value;\\n        bytes callData;\\n    }\\n\\n    /// @notice Returns the authentication contract used by the settlement contract.\\n    function authenticator() external view returns (ICowAuthentication);\\n\\n    /// @notice Returns the address of the vaultRelayer, the target for approvals for funds entering the settlement contract.\\n    function vaultRelayer() external view returns (address);\\n\\n    /// @notice Returns the domain separator for EIP-712 signing\\n    function domainSeparator() external view returns (bytes32);\\n\\n    /// @notice Allows for approval of orders by submitting an authorized hash on-chain prior to order execution.\\n    function setPreSignature(bytes calldata orderUid, bool signed) external;\\n\\n    /// @notice Settles a batch of trades atomically\\n    /// @param tokens Array of token addresses involved in the settlement\\n    /// @param clearingPrices Array of clearing prices for each token\\n    /// @param trades Array of trades to execute\\n    /// @param interactions Array of three interaction arrays (pre, intra, post-settlement)\\n    function settle(\\n        address[] calldata tokens,\\n        uint256[] calldata clearingPrices,\\n        Trade[] calldata trades,\\n        Interaction[][3] calldata interactions\\n    ) external;\\n}\\n\\n/// @title CoW Protocol Wrapper Interface\\n/// @notice Interface for wrapper contracts that add custom logic around CoW settlements\\n/// @dev Wrappers can be chained together to compose multiple settlement operations\\ninterface ICowWrapper {\\n    /// @notice A human readable label for this wrapper. Used for display in explorer/analysis UIs\\n    function name() external view returns (string memory);\\n\\n    /// @notice The settlement contract used by this wrapper\\n    /// @return The CowSettlement contract address\\n    function SETTLEMENT() external view returns (ICowSettlement);\\n\\n    /// @notice Initiates a wrapped settlement call\\n    /// @dev This is the entry point for wrapped settlements. The wrapper will execute custom logic\\n    ///      before calling the next wrapper or settlement contract in the chain.\\n    /// @dev SECURITY: `settleData` is NOT guaranteed to remain unchanged through the wrapper chain.\\n    ///      Intermediate wrappers could modify it before passing it along. Do not rely on\\n    ///      `settleData` validation for security-critical checks.\\n    /// @param settleData ABI-encoded call to ICowSettlement.settle() containing trade data\\n    /// @param chainedWrapperData Encoded wrapper chain with the following format:\\n    ///        Structure: [uint16 len1][bytes data1][address wrapper2][uint16 len2][bytes data2][address wrapper3]...\\n    ///\\n    ///        Each wrapper in the chain consists of:\\n    ///        - 2 bytes: uint16 length of wrapper-specific data\\n    ///        - `length` bytes: wrapper-specific data for this wrapper\\n    ///        - 20 bytes: address of next wrapper (omitted for the final wrapper)\\n    ///\\n    ///        The final wrapper in the chain omits the next wrapper address and calls SETTLEMENT directly.\\n    ///\\n    ///        Example: [0x0005][0xAABBCCDDEE][0x1234...ABCD][0x0003][0x112233]\\n    ///                 len   data         next wrapper  len   data (final, no next address)\\n    ///\\n    function wrappedSettle(bytes calldata settleData, bytes calldata chainedWrapperData) external;\\n\\n    /// @notice Confirms validity of wrapper-specific data\\n    /// @dev Used by CowWrapperHelpers to validate wrapper data before execution. Reverts if the wrapper data is not valid for some reason.\\n    /// @param wrapperData The wrapper-specific data to parse\\n    function validateWrapperData(bytes calldata wrapperData) external view;\\n}\\n\\n/// @title CoW Protocol Wrapper Base Contract\\n/// @notice Abstract base contract for creating wrapper contracts around CoW Protocol settlements\\n/// @dev A wrapper enables custom pre/post-settlement and context-setting logic and can be chained with other wrappers.\\n///      Wrappers must:\\n///      - Be approved by the ICowAuthentication contract\\n///      - Verify the caller is an authenticated solver\\n///      - Eventually call settle() on the approved ICowSettlement contract\\n///      - Implement _wrap() for custom logic\\nabstract contract CowWrapper is ICowWrapper {\\n    /// @notice Thrown when the caller is not an authenticated solver\\n    /// @param unauthorized The address that attempted to call wrappedSettle\\n    error NotASolver(address unauthorized);\\n\\n    /// @notice Thrown when settle data doesn't contain the correct function selector\\n    /// @param invalidSettleData The invalid settle data that was provided\\n    error InvalidSettleData(bytes invalidSettleData);\\n\\n    /// @notice The settlement contract\\n    ICowSettlement public immutable SETTLEMENT;\\n\\n    /// @notice The authentication contract used to verify solvers\\n    /// @dev This is derived from `SETTLEMENT.authenticator()`.\\n    ICowAuthentication public immutable AUTHENTICATOR;\\n\\n    /// @notice Constructs a new CowWrapper\\n    /// @param settlement_ The ICowSettlement contract to use at the end of the wrapper chain. Also used for wrapper authentication.\\n    constructor(ICowSettlement settlement_) {\\n        SETTLEMENT = settlement_;\\n        AUTHENTICATOR = settlement_.authenticator();\\n    }\\n\\n    /// @inheritdoc ICowWrapper\\n    function wrappedSettle(bytes calldata settleData, bytes calldata chainedWrapperData) external {\\n        // Revert if not a valid solver\\n        require(AUTHENTICATOR.isSolver(msg.sender), NotASolver(msg.sender));\\n\\n        // Find out how long the next wrapper data is supposed to be\\n        // We use 2 bytes to decode the length of the wrapper data because it allows for up to 64KB of data for each wrapper.\\n        // This should be plenty of length for all identified use-cases of wrappers in the forseeable future.\\n        uint256 nextWrapperDataLen = uint256(uint16(bytes2(chainedWrapperData[0:2])));\\n\\n        // Delegate to the wrapper's custom logic\\n        uint256 remainingWrapperDataStart = 2 + nextWrapperDataLen;\\n        _wrap(\\n            settleData, chainedWrapperData[2:remainingWrapperDataStart], chainedWrapperData[remainingWrapperDataStart:]\\n        );\\n    }\\n\\n    /// @inheritdoc ICowWrapper\\n    function validateWrapperData(bytes calldata wrapperData) external view virtual;\\n\\n    /// @notice Internal function containing the wrapper's custom logic\\n    /// @dev Must be implemented by concrete wrapper contracts. Should execute custom logic\\n    ///      then eventually call _next() to continue the wrapped settlement chain.\\n    /// @param settleData ABI-encoded call to ICowSettlement.settle()\\n    /// @param wrapperData The wrapper data which should be consumed by this wrapper\\n    /// @param remainingWrapperData The reminder bytes resulting from consuming the current's wrapper data from the original `chainedWrapperData` in the `wrappedSettle` call. This should be passed unaltered to `_next` that will call the settlement function if this remainder is empty, or delegate the settlement to the next wrapper\\n    function _wrap(bytes calldata settleData, bytes calldata wrapperData, bytes calldata remainingWrapperData)\\n        internal\\n        virtual;\\n\\n    /// @notice Continues the wrapped settlement chain by calling the next wrapper or settlement contract\\n    /// @dev Extracts the next target address from wrapperData and either:\\n    ///      - Calls ICowSettlement.settle() directly if no more wrappers remain, or\\n    ///      - Calls the next CowWrapper.wrappedSettle() to continue the chain\\n    /// @param settleData ABI-encoded call to ICowSettlement.settle()\\n    /// @param remainingWrapperData Remaining wrapper data starting with the next target address (20 bytes)\\n    function _next(bytes calldata settleData, bytes calldata remainingWrapperData) internal {\\n        if (remainingWrapperData.length == 0) {\\n            // No more wrapper data - we're calling the final settlement contract\\n            // Verify the settle data has the correct function selector\\n            require(bytes4(settleData[:4]) == ICowSettlement.settle.selector, InvalidSettleData(settleData));\\n\\n            // Call the settlement contract directly with the settle data\\n            (bool success, bytes memory returnData) = address(SETTLEMENT).call(settleData);\\n\\n            if (!success) {\\n                // Bubble up the revert reason from the settlement contract\\n                assembly (\\\"memory-safe\\\") {\\n                    revert(add(returnData, 0x20), mload(returnData))\\n                }\\n            }\\n        } else {\\n            // Extract the next wrapper address from the first 20 bytes of wrapperData\\n            address nextWrapper = address(bytes20(remainingWrapperData[:20]));\\n\\n            // Skip past the address we just read\\n            remainingWrapperData = remainingWrapperData[20:];\\n\\n            // More wrapper data remains - call the next wrapper in the chain\\n            CowWrapper(nextWrapper).wrappedSettle(settleData, remainingWrapperData);\\n        }\\n    }\\n}\\n\"},\"src/PreApprovedHashes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity ^0.8;\\n\\n/// @title PreApprovedHashes\\n/// @notice Abstract contract for managing pre-approved operation hashes\\n/// @dev Allows users to pre-approve specific operations without requiring signatures each time\\nabstract contract PreApprovedHashes {\\n    /// @dev Marker value indicating a hash is pre-approved\\n    uint256 internal constant PRE_APPROVED = uint256(keccak256(\\\"PreApprovedHashes.PreApproved\\\"));\\n    uint256 internal constant CONSUMED = uint256(keccak256(\\\"PreApprovedHashes.Consumed\\\"));\\n\\n    /// @notice Storage indicating whether or not a signed calldata hash has been approved by an owner\\n    /// @dev Maps owner -> hash(orderParameters) -> approval status\\n    mapping(address => mapping(bytes32 => uint256)) public preApprovedHashes;\\n\\n    /// @notice Event emitted when an owner pre-approves or revokes a hash\\n    event PreApprovedHash(address indexed owner, bytes32 indexed hash, bool approved);\\n\\n    /// @notice Event emitted when a pre-approved hash is used and is no longer valid because its consumed\\n    event PreApprovedHashConsumed(address indexed owner, bytes32 indexed hash);\\n\\n    /// @notice Revert reason given when a hash has already been consumed, and therefore cannot be used\\n    /// @dev If the hash had simply never been approved in the first place, the error will be HashNotApproved\\n    error AlreadyConsumed(address owner, bytes32 hash);\\n\\n    /// @notice Revert reason given when a pre approved hash is being consumed, but it hasnt actually been approved.\\n    /// @dev If the hash has been approved in the past, but it was consumed, the error will be AlreadyConsumed\\n    error HashNotApproved(address owner, bytes32 hash);\\n\\n    /// @notice Pre-approve a hash of signed calldata for future execution\\n    /// @dev Once a hash is pre-approved, it can only be consumed once. This prevents replay attacks.\\n    /// @param hash The keccak256 hash of the order parameters\\n    /// @param approved True to approve the hash, false to revoke approval\\n    function setPreApprovedHash(bytes32 hash, bool approved) external {\\n        require(preApprovedHashes[msg.sender][hash] != CONSUMED, AlreadyConsumed(msg.sender, hash));\\n\\n        if (approved) {\\n            preApprovedHashes[msg.sender][hash] = PRE_APPROVED;\\n        } else {\\n            preApprovedHashes[msg.sender][hash] = CONSUMED;\\n        }\\n        emit PreApprovedHash(msg.sender, hash, approved);\\n    }\\n\\n    /// @notice Check if a hash is pre-approved for an owner\\n    /// @param owner The owner address\\n    /// @param hash The hash to check\\n    /// @return True if the hash is pre-approved, false otherwise\\n    function isHashPreApproved(address owner, bytes32 hash) external view returns (bool) {\\n        return preApprovedHashes[owner][hash] == PRE_APPROVED;\\n    }\\n\\n    /// @notice Check if a hash is pre-approved for an owner. If it is, changes it to be consumed.\\n    /// @param owner The owner address\\n    /// @param hash The hash to check\\n    function _consumePreApprovedHash(address owner, bytes32 hash) internal {\\n        if (preApprovedHashes[owner][hash] == PRE_APPROVED) {\\n            preApprovedHashes[owner][hash] = CONSUMED;\\n            emit PreApprovedHashConsumed(owner, hash);\\n        } else if (preApprovedHashes[owner][hash] == CONSUMED) {\\n            revert AlreadyConsumed(owner, hash);\\n        } else {\\n            revert HashNotApproved(owner, hash);\\n        }\\n    }\\n}\\n\"}},\"settings\":{\"remappings\":[\"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\"cow/=lib/cow/src/contracts/\",\"ds-test/=lib/evc/lib/forge-std/lib/ds-test/src/\",\"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\"ethereum-vault-connector/=lib/euler-vault-kit/lib/ethereum-vault-connector/src/\",\"euler-vault-kit/=lib/euler-vault-kit/\",\"evc/=lib/euler-vault-kit/lib/ethereum-vault-connector/src/\",\"forge-gas-snapshot/=lib/euler-vault-kit/lib/permit2/lib/forge-gas-snapshot/src/\",\"forge-std/=lib/forge-std/src/\",\"halmos-cheatcodes/=lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/\",\"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\"openzeppelin/=lib/euler-vault-kit/lib/ethereum-vault-connector/lib/openzeppelin-contracts/contracts/\",\"permit2/=lib/euler-vault-kit/lib/permit2/\",\"solmate/=lib/euler-vault-kit/lib/permit2/lib/solmate/\"],\"optimizer\":{\"enabled\":true,\"runs\":200},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"compilationTarget\":{\"src/CowEvcCollateralSwapWrapper.sol\":\"CowEvcCollateralSwapWrapper\"},\"evmVersion\":\"prague\",\"libraries\":{},\"viaIR\":true,\"outputSelection\":{\"*\":{\"*\":[\"*\"]}}}}"
      }
    },
    "CowEvcOpenPositionWrapper": {
      "contractName": "CowEvcOpenPositionWrapper",
      "sourceName": "src/CowEvcOpenPositionWrapper.sol",
      "abi": [
        {
          "type": "constructor",
          "inputs": [
            {
              "name": "_evc",
              "type": "address",
              "internalType": "address"
            },
            {
              "name": "_settlement",
              "type": "address",
              "internalType": "contract ICowSettlement"
            }
          ],
          "stateMutability": "nonpayable"
        },
        {
          "type": "function",
          "name": "AUTHENTICATOR",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address",
              "internalType": "contract ICowAuthentication"
            }
          ],
          "stateMutability": "view"
        },
        {
          "type": "function",
          "name": "DOMAIN_SEPARATOR",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bytes32",
              "internalType": "bytes32"
            }
          ],
          "stateMutability": "view"
        },
        {
          "type": "function",
          "name": "DOMAIN_TYPE_HASH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bytes32",
              "internalType": "bytes32"
            }
          ],
          "stateMutability": "view"
        },
        {
          "type": "function",
          "name": "EVC",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address",
              "internalType": "contract IEVC"
            }
          ],
          "stateMutability": "view"
        },
        {
          "type": "function",
          "name": "NONCE_NAMESPACE",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256",
              "internalType": "uint256"
            }
          ],
          "stateMutability": "view"
        },
        {
          "type": "function",
          "name": "PARAMS_TYPE_HASH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bytes32",
              "internalType": "bytes32"
            }
          ],
          "stateMutability": "view"
        },
        {
          "type": "function",
          "name": "SETTLEMENT",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address",
              "internalType": "contract ICowSettlement"
            }
          ],
          "stateMutability": "view"
        },
        {
          "type": "function",
          "name": "encodePermitData",
          "inputs": [
            {
              "name": "params",
              "type": "tuple",
              "internalType": "struct CowEvcOpenPositionWrapper.OpenPositionParams",
              "components": [
                {
                  "name": "owner",
                  "type": "address",
                  "internalType": "address"
                },
                {
                  "name": "account",
                  "type": "address",
                  "internalType": "address"
                },
                {
                  "name": "deadline",
                  "type": "uint256",
                  "internalType": "uint256"
                },
                {
                  "name": "collateralVault",
                  "type": "address",
                  "internalType": "address"
                },
                {
                  "name": "borrowVault",
                  "type": "address",
                  "internalType": "address"
                },
                {
                  "name": "collateralAmount",
                  "type": "uint256",
                  "internalType": "uint256"
                },
                {
                  "name": "borrowAmount",
                  "type": "uint256",
                  "internalType": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bytes",
              "internalType": "bytes"
            }
          ],
          "stateMutability": "view"
        },
        {
          "type": "function",
          "name": "evcInternalSettle",
          "inputs": [
            {
              "name": "settleData",
              "type": "bytes",
              "internalType": "bytes"
            },
            {
              "name": "wrapperData",
              "type": "bytes",
              "internalType": "bytes"
            },
            {
              "name": "remainingWrapperData",
              "type": "bytes",
              "internalType": "bytes"
            }
          ],
          "outputs": [],
          "stateMutability": "nonpayable"
        },
        {
          "type": "function",
          "name": "getApprovalHash",
          "inputs": [
            {
              "name": "params",
              "type": "tuple",
              "internalType": "struct CowEvcOpenPositionWrapper.OpenPositionParams",
              "components": [
                {
                  "name": "owner",
                  "type": "address",
                  "internalType": "address"
                },
                {
                  "name": "account",
                  "type": "address",
                  "internalType": "address"
                },
                {
                  "name": "deadline",
                  "type": "uint256",
                  "internalType": "uint256"
                },
                {
                  "name": "collateralVault",
                  "type": "address",
                  "internalType": "address"
                },
                {
                  "name": "borrowVault",
                  "type": "address",
                  "internalType": "address"
                },
                {
                  "name": "collateralAmount",
                  "type": "uint256",
                  "internalType": "uint256"
                },
                {
                  "name": "borrowAmount",
                  "type": "uint256",
                  "internalType": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bytes32",
              "internalType": "bytes32"
            }
          ],
          "stateMutability": "view"
        },
        {
          "type": "function",
          "name": "isHashPreApproved",
          "inputs": [
            {
              "name": "owner",
              "type": "address",
              "internalType": "address"
            },
            {
              "name": "hash",
              "type": "bytes32",
              "internalType": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool",
              "internalType": "bool"
            }
          ],
          "stateMutability": "view"
        },
        {
          "type": "function",
          "name": "name",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string",
              "internalType": "string"
            }
          ],
          "stateMutability": "view"
        },
        {
          "type": "function",
          "name": "preApprovedHashes",
          "inputs": [
            {
              "name": "",
              "type": "address",
              "internalType": "address"
            },
            {
              "name": "",
              "type": "bytes32",
              "internalType": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256",
              "internalType": "uint256"
            }
          ],
          "stateMutability": "view"
        },
        {
          "type": "function",
          "name": "setPreApprovedHash",
          "inputs": [
            {
              "name": "hash",
              "type": "bytes32",
              "internalType": "bytes32"
            },
            {
              "name": "approved",
              "type": "bool",
              "internalType": "bool"
            }
          ],
          "outputs": [],
          "stateMutability": "nonpayable"
        },
        {
          "type": "function",
          "name": "validateWrapperData",
          "inputs": [
            {
              "name": "wrapperData",
              "type": "bytes",
              "internalType": "bytes"
            }
          ],
          "outputs": [],
          "stateMutability": "pure"
        },
        {
          "type": "function",
          "name": "wrappedSettle",
          "inputs": [
            {
              "name": "settleData",
              "type": "bytes",
              "internalType": "bytes"
            },
            {
              "name": "chainedWrapperData",
              "type": "bytes",
              "internalType": "bytes"
            }
          ],
          "outputs": [],
          "stateMutability": "nonpayable"
        },
        {
          "type": "event",
          "name": "CowEvcPositionOpened",
          "inputs": [
            {
              "name": "owner",
              "type": "address",
              "indexed": true,
              "internalType": "address"
            },
            {
              "name": "account",
              "type": "address",
              "indexed": false,
              "internalType": "address"
            },
            {
              "name": "collateralVault",
              "type": "address",
              "indexed": true,
              "internalType": "address"
            },
            {
              "name": "borrowVault",
              "type": "address",
              "indexed": true,
              "internalType": "address"
            },
            {
              "name": "collateralAmount",
              "type": "uint256",
              "indexed": false,
              "internalType": "uint256"
            },
            {
              "name": "borrowAmount",
              "type": "uint256",
              "indexed": false,
              "internalType": "uint256"
            }
          ],
          "anonymous": false
        },
        {
          "type": "event",
          "name": "PreApprovedHash",
          "inputs": [
            {
              "name": "owner",
              "type": "address",
              "indexed": true,
              "internalType": "address"
            },
            {
              "name": "hash",
              "type": "bytes32",
              "indexed": true,
              "internalType": "bytes32"
            },
            {
              "name": "approved",
              "type": "bool",
              "indexed": false,
              "internalType": "bool"
            }
          ],
          "anonymous": false
        },
        {
          "type": "event",
          "name": "PreApprovedHashConsumed",
          "inputs": [
            {
              "name": "owner",
              "type": "address",
              "indexed": true,
              "internalType": "address"
            },
            {
              "name": "hash",
              "type": "bytes32",
              "indexed": true,
              "internalType": "bytes32"
            }
          ],
          "anonymous": false
        },
        {
          "type": "error",
          "name": "AlreadyConsumed",
          "inputs": [
            {
              "name": "owner",
              "type": "address",
              "internalType": "address"
            },
            {
              "name": "hash",
              "type": "bytes32",
              "internalType": "bytes32"
            }
          ]
        },
        {
          "type": "error",
          "name": "HashNotApproved",
          "inputs": [
            {
              "name": "owner",
              "type": "address",
              "internalType": "address"
            },
            {
              "name": "hash",
              "type": "bytes32",
              "internalType": "bytes32"
            }
          ]
        },
        {
          "type": "error",
          "name": "InvalidCallback",
          "inputs": []
        },
        {
          "type": "error",
          "name": "InvalidSettleData",
          "inputs": [
            {
              "name": "invalidSettleData",
              "type": "bytes",
              "internalType": "bytes"
            }
          ]
        },
        {
          "type": "error",
          "name": "NotASolver",
          "inputs": [
            {
              "name": "unauthorized",
              "type": "address",
              "internalType": "address"
            }
          ]
        },
        {
          "type": "error",
          "name": "OperationDeadlineExceeded",
          "inputs": [
            {
              "name": "validToTimestamp",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "currentTimestamp",
              "type": "uint256",
              "internalType": "uint256"
            }
          ]
        },
        {
          "type": "error",
          "name": "SubaccountMustBeControlledByOwner",
          "inputs": [
            {
              "name": "subaccount",
              "type": "address",
              "internalType": "address"
            },
            {
              "name": "owner",
              "type": "address",
              "internalType": "address"
            }
          ]
        },
        {
          "type": "error",
          "name": "Unauthorized",
          "inputs": [
            {
              "name": "msgSender",
              "type": "address",
              "internalType": "address"
            }
          ]
        },
        {
          "type": "error",
          "name": "UnusedPermitSignature",
          "inputs": []
        }
      ],
      "bytecode": "0x61018080604052346103dc5760408161214b803803809161002082856103f3565b8339810103126103dc5780516001600160a01b038116918282036103dc57602001516001600160a01b038116908181036103dc57608052604051632335c76b60e01b815290602090829060049082905afa9081156103e8575f916103a2575b5060a0523b1561035d5760c052306101005260405160208101907f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f82527fec7ef00b3e76dbb62dcda47945feb4e818a3ffcdba84189437295ec817f2cda460408201527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc660608201524660808201523060a082015260a0815261012360c0826103f3565b51902060e052600154600181811c91168015610353575b602082101461033f57601f811161030a575b507f45756c657220455643202d204f70656e20506f736974696f6e0000000000003260015560405160e081016001600160401b038111828210176102f6576040525f815260208101905f825260408101905f8252606081015f815260808201905f825260c060a08401935f855201935f8552604051955f602088015260018060a01b03905116604087015251606086015260018060a01b03905116608085015260018060a01b0390511660a08401525160c08301525160e082015260e08152610217610100826103f3565b51610120526005610160527f37458bde9202dec258a12cf2bc8b4ac302a61cf842bbe3a2bb921d968507d3bf61014052604051611d34908161041782396080518181816102570152610acc015260a05181818161095801526109f3015260c0518181816101bd015281816108da01528181610fa6015281816116ac01528181611aab0152611c3f015260e0518181816105570152610e020152610100518181816104e401528181611a7b0152611c0f01526101205181610dce01526101405181818161083c0152610dab015261016051818181610f4301526115fe0152f35b634e487b7160e01b5f52604160045260245ffd5b601981111561014c5760015f52601f60205f20910160051c5f5b81811061033257505061014c565b5f83820155600101610324565b634e487b7160e01b5f52602260045260245ffd5b90607f169061013a565b60405162461bcd60e51b815260206004820152601660248201527f455643206164647265737320697320696e76616c6964000000000000000000006044820152606490fd5b90506020813d6020116103e0575b816103bd602093836103f3565b810103126103dc57516001600160a01b03811681036103dc575f61007f565b5f80fd5b3d91506103b0565b6040513d5f823e3d90fd5b601f909101601f19168101906001600160401b038211908210176102f65760405256fe60806040526004361015610011575f80fd5b5f3560e01c8063036b54641461011457806306fdde031461010f5780630c8116701461010a5780631f4975b8146101055780633644e515146101005780634fedcdbf146100fb5780635b0e5556146100f65780636f2b25e0146100f1578063756fe481146100ec5780637e829b31146100e7578063a5a763b1146100e2578063a70354a1146100dd578063c0993eea146100d8578063c6186181146100d3578063d20e71e7146100ce5763ef0fe245146100c9575f80fd5b610ab7565b610987565b610943565b610909565b6108c5565b61085f565b610825565b6107e1565b61079e565b610661565b61062b565b610540565b610507565b6104cd565b6103da565b61014a565b9181601f84011215610146578235916001600160401b038311610146576020838186019501011161014657565b5f80fd5b34610146576060366003190112610146576004356001600160401b0381116101465761017a903690600401610119565b906024356001600160401b0381116101465761019a903690600401610119565b50506044356001600160401b038111610146576101bb903690600401610119565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03163303610330575f5c6101f73636610b16565b6020815191012003610321575f805d80610299575050818161024382826102205f978897610bf3565b6313d79a0b60e01b916001600160e01b03199161023c9161144e565b1614611484565b610252604051809381936114b8565b0390827f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165af16102896114c5565b901561029157005b602081519101fd5b80806102ba6102b46102ae6102c09587610bc8565b906113c7565b60601c90565b93610bd6565b9390916001600160a01b031690813b15610146575f80946102f76040519788968795869463d20e71e760e01b865260048601611427565b03925af1801561031c57610308575b005b806103165f61030693610381565b80610343565b610b95565b63f7a632f560e01b5f5260045ffd5b63472511eb60e11b5f523360045260245ffd5b5f91031261014657565b634e487b7160e01b5f52604160045260245ffd5b60e081019081106001600160401b0382111761037c57604052565b61034d565b90601f801991011681019081106001600160401b0382111761037c57604052565b805180835260209291819084018484015e5f828201840152601f01601f1916010190565b9060206103d79281815201906103a2565b90565b34610146575f366003190112610146576040515f6001548060011c90600181169081156104c3575b6020831082146104af5782855260208501919081156104965750600114610444575b6104408461043481860382610381565b604051918291826103c6565b0390f35b60015f9081529250907fb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf65b8184106104825750500161043482610424565b80548484015260209093019260010161046f565b60ff191682525090151560051b01905061043482610424565b634e487b7160e01b5f52602260045260245ffd5b91607f1691610402565b34610146575f3660031901126101465760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b34610146576020366003190112610146576004356001600160401b0381116101465761053a610306913690600401610119565b90610ce4565b34610146575f3660031901126101465760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b60405190610589608083610381565b565b600435906001600160a01b038216820361014657565b35906001600160a01b038216820361014657565b60e090600319011261014657604051906105ce82610361565b816004356001600160a01b03811681036101465781526105ee60246105a1565b6020820152604435604082015261060560646105a1565b606082015261061460846105a1565b608082015260a43560a082015260c060c435910152565b346101465760e036600319011261014657602061064f61064a366105b5565b610da0565b604051908152f35b8015150361014657565b346101465760403660031901126101465760043560243561068181610657565b335f525f60205260405f20825f526020527fc7a17c84cfc6bd62e248dc40d0d98f59040bcfbba3ed5cfe5a87aac90152ca7460405f20541461078757801561074057335f90815260208190526040902061070e906106e99084905b905f5260205260405f2090565b7ffdeb67b02819f1ab9c0e57355ac925e9fe35883f75ef41b364cd780799c5998a9055565b604051901515815233907fc96db6e691f7453f4a948b101f35561af4e2acf852cd1b95698ba775717a816a90602090a3005b335f9081526020819052604090206107829061075d9084906106dc565b7fc7a17c84cfc6bd62e248dc40d0d98f59040bcfbba3ed5cfe5a87aac90152ca749055565b61070e565b5063ae9c304b60e01b5f523360045260245260445ffd5b346101465760e0366003190112610146576104406107cd6107be366105b5565b6107c781610f31565b5061126f565b6040519182916020835260208301906103a2565b34610146576040366003190112610146576107fa61058b565b6001600160a01b03165f90815260208181526040808320602435845282529182902054915191825290f35b34610146575f3660031901126101465760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b346101465760403660031901126101465761087861058b565b6024359060018060a01b03165f525f60205260405f20905f5260205260207ffdeb67b02819f1ab9c0e57355ac925e9fe35883f75ef41b364cd780799c5998a60405f205414604051908152f35b34610146575f366003190112610146576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b34610146575f3660031901126101465760206040517f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f8152f35b34610146575f366003190112610146576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b34610146576040366003190112610146576004356001600160401b038111610146576109b7903690600401610119565b6024356001600160401b038111610146576109d6903690600401610119565b6040516302cc250d60e01b815233600482015293916020856024817f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165afa94851561031c5761030695610a3b915f91610a88575b503390610ba0565b610a8082610a6d610a68610a61610a5b610a558588610c01565b90610c44565b60f01c90565b61ffff1690565b610c8e565b610a78818386610c0f565b959094610c2c565b9490936112bc565b610aaa915060203d602011610ab0575b610aa28183610381565b810190610b80565b5f610a33565b503d610a98565b34610146575f366003190112610146576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b6001600160401b03811161037c57601f01601f191660200190565b919091610b2281610afb565b610b2f6040519182610381565b809382825282116101465781815f9384602080950137010152565b929192610b5682610afb565b91610b646040519384610381565b829481845281830111610146578281602093845f960137010152565b9081602091031261014657516103d781610657565b6040513d5f823e3d90fd5b15610ba85750565b6363546f7f60e01b5f9081526001600160a01b0391909116600452602490fd5b906014116101465790601490565b909291928360141161014657831161014657601401916013190190565b906004116101465790600490565b906002116101465790600290565b909291928360021161014657831161014657600201916001190190565b90939293848311610146578411610146578101920390565b356001600160f01b0319811692919060028210610c5f575050565b6001600160f01b031960029290920360031b82901b16169150565b634e487b7160e01b5f52601160045260245ffd5b6002019081600211610c9c57565b610c7a565b91908201809211610c9c57565b60405190610cbb82610361565b5f60c0838281528260208201528260408201528260608201528260808201528260a08201520152565b90610ced610cae565b50810181810361010081126101465760e0136101465760405191610d1083610361565b610d19816105a1565b8352610d27602082016105a1565b602084015260408101356040840152610d42606082016105a1565b6060840152610d53608082016105a1565b608084015260a081013560a084015260c081013560c084015260e0810135906001600160401b03821161014657019080601f8301121561014657816020610d9c93359101610b4a565b9091565b604290601f190180517f000000000000000000000000000000000000000000000000000000000000000082527f0000000000000000000000000000000000000000000000000000000000000000602001822091526040519061190160f01b82527f0000000000000000000000000000000000000000000000000000000000000000600283015260228201522090565b5f19810191908211610c9c57565b6001600160401b03811161037c5760051b60200190565b90610e5e82610e3d565b610e6b6040519182610381565b8281528092610e7c601f1991610e3d565b015f5b818110610e8b57505050565b6040519060808201918083106001600160401b0384111761037c576020926040525f81525f838201525f604082015260608082015282828601015201610e7f565b805115610ed95760200190565b634e487b7160e01b5f52603260045260245ffd5b805160011015610ed95760400190565b805160021015610ed95760600190565b805160031015610ed95760800190565b8051821015610ed95760209160051b010190565b610f3a906114f4565b90610f6c610f677f0000000000000000000000000000000000000000000000000000000000000000610e2f565b610e54565b60208381018051606086018051604051636a27f72d60e11b958101959095526001600160a01b0392831660248601528216604485015293957f00000000000000000000000000000000000000000000000000000000000000009091169390926111b99261117e9261117092610fee81606481015b03601f198101835282610381565b610ff661057a565b6001600160a01b0389168152905f60208301525f6040830152606082015261101d8a610ecc565b5261102789610ecc565b5081516080870180516040516330da145b60e21b60208201526001600160a01b0393841660248201529216604483015297906110668160648101610fe0565b61108061107161057a565b6001600160a01b039093168352565b5f60208301525f6040830152606082015261109a8a610eed565b526110a489610eed565b5085516110c3906001600160a01b03165b91516001600160a01b031690565b9061114460a08801519161111a6110e0865160018060a01b031690565b604051636e553f6560e01b602082015260248101959095526001600160a01b0316604485015283606481015b03601f198101855284610381565b61113461112561057a565b6001600160a01b039095168552565b6001600160a01b03166020840152565b5f6040830152606082015261115889610efd565b5261116288610efd565b50516001600160a01b031690565b93516001600160a01b031690565b60c08301519251604051630967fa2960e31b602082015260248101949094526001600160a01b031660448401529261111a836064810161110c565b5f604083015260608201526111cd83610f0d565b526111d782610f0d565b50600190565b602081016020825282518091526040820191602060408360051b8301019401925f915b83831061120f57505050505090565b9091929394602080611260600193603f19868203018752608060608b51878060a01b038151168452878060a01b038682015116868501526040810151604085015201519181606082015201906103a2565b97019301930191939290611200565b906020806103d79261129c6040519161064a8361110c8682019963305ab9e960e21b8b52602483016111dd565b6040519586925180918585015e8201908382015203018084520182610381565b919390610fe06113259261135095976113136112d88a8a610ce4565b99909a611301604051998a9862dad51960e21b60208b0152606060248b015260848a0191611407565b87810360231901604489015291611407565b84810360231901606486015291611407565b83516001600160a01b0316602085018051909491906001600160a01b03169186604081015194611599565b8151611364906001600160a01b03166110b5565b606083810151608085015160a086015160c090960151604080516001600160a01b039687168152602081019890985287015283169490831693909216917fce61442bb7edc056d7608dd78c8f3e9f8bdb65a5459af2f1224d7a160d0f1d7b9190a4565b356bffffffffffffffffffffffff198116929190601482106113e7575050565b6bffffffffffffffffffffffff1960149290920360031b82901b16169150565b908060209392818452848401375f828201840152601f01601f1916010190565b9290611440906103d79593604086526040860191611407565b926020818503910152611407565b356001600160e01b0319811692919060048210611469575050565b6001600160e01b031960049290920360031b82901b16169150565b91909115611490575050565b6114b46040519283926360de6df360e11b8452602060048501526024840191611407565b0390fd5b908092918237015f815290565b3d156114ef573d906114d682610afb565b916114e46040519384610381565b82523d5f602084013e565b606090565b6114fc610cae565b5090565b15611509575050565b632bf6252360e21b5f9081526001600160a01b039182166004529116602452604490fd5b15611536575050565b6302232baf60e51b5f5260045260245260445ffd5b6040519061155a602083610381565b5f808352366020840137565b5f198114610c9c5760010190565b1561157b57565b638533e92760e01b5f5260045ffd5b90816020910312610146575190565b91909394929460018060a01b038616916cffffffffffffffffffffffffff198760601b169486888261168160018060a01b038716986115ee84898d6cffffffffffffffffffffffffff198260601b1614611500565b8651156118ae575b6116406116227f0000000000000000000000000000000000000000000000000000000000000000610e54565b9c8d9561162e82610f31565b9990918a156118a0578b925b89611a47565b90805160208201205f5d61165261057a565b308152903060208301525f6040830152606082015261167a8261167481611566565b96610f1d565b528b610f1d565b508315611898575b916116a2916116a8938c61169b61154b565b928d611bdd565b91611574565b86527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031695863b15610146575f6116fb916040518093819263305ab9e960e21b8352600483016111dd565b0381838b5af1801561031c57611884575b50511561171c575b505050505050565b60405163b03c130d60e01b81526001600160681b0319949094166004850152306024850152602084604481885afa93841561031c575f94611853575b5060016001600160a01b03838518161b84166117f9575b50141590816117ec575b50611788575b80808080611714565b803b1561014657604051634fae231560e11b81526001600160a01b039290921660048301523060248301525f60448301819052908290606490829084905af1801561031c576117d8575b8061177f565b806103165f6117e693610381565b5f6117d2565b600191501615155f611779565b843b1561014657604051634fae231560e11b81526001600160a01b039190911660048201523060248201525f604482018190528160648183895af1801561031c571561176f57806103165f61184d93610381565b5f61176f565b61187691945060203d60201161187d575b61186e8183610381565b81019061158a565b925f611758565b503d611864565b806103165f61189293610381565b5f61170c565b5f9350611689565b6118a861154b565b9261163a565b6118c06118ba86610da0565b856118d3565b6118ce42844281101561152d565b6115f6565b60018060a01b03811690815f525f60205260405f20835f526020527ffdeb67b02819f1ab9c0e57355ac925e9fe35883f75ef41b364cd780799c5998a60405f2054145f146119615761075d836106dc61193b9360018060a01b03165f525f60205260405f2090565b7fb7c8974e057303dd6a257526d2baec5ecd92237f586b8e622451647cb37cee6f5f80a3565b6001600160a01b0381165f9081526020819052604090208390815f526020527fc7a17c84cfc6bd62e248dc40d0d98f59040bcfbba3ed5cfe5a87aac90152ca7460405f2054145f146119cd5763ae9c304b60e01b5f526001600160a01b0390911660045260245260445ffd5b635ae2147960e01b5f526001600160a01b0390911660045260245260445ffd5b95926103d7979592611a39959260018060a01b0316885260018060a01b031660208801526040870152606086015260808501525f60a085015261010060c08501526101008401906103a2565b9160e08184039101526103a2565b91929493905f93825115155f14611b885760405163096b649b60e11b81526001600160681b0319606083901b1660048201527f0000000000000000000000000000000000000000000000000000000000000000602482018190526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016989094906020836044818d5afa90811561031c576114fc99611b1c96610fe0955f94611b61575b5090611afd9161126f565b91604051978896635bedd1cd60e01b60208901523090602489016119ed565b611b36611b2761057a565b6001600160a01b039096168652565b5f60208601525f60408601526060850152611b5082611566565b93611b5b8383610f1d565b52610f1d565b611afd92919450611b809060203d60201161187d5761186e8183610381565b939091611af2565b50935050939250505f5b8151811015611bcf5780611bc8611bab60019385610f1d565b51611bb6835f610ca1565b90611bc18289610f1d565b5286610f1d565b5001611b92565b506103d7919250515f610ca1565b8451929593949193909215611cb85760405163096b649b60e11b81526001600160681b0319606088901b1660048201527f0000000000000000000000000000000000000000000000000000000000000000602482018190526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169790939091906020826044818c5afa801561031c576114fc98611b1c95610fe0945f93611c93575b50611afd90606061126f565b611afd919350611cb19060203d60201161187d5761186e8183610381565b9290611c87565b505093925090505f5b606051811015611cee5780611ce7611cdc6001936060610f1d565b51611bb68386610ca1565b5001611cc1565b506103d791925060605190610ca156fea2646970667358221220d9d413387e1ae755000c288cb86915e685a4ae790f24aa0090cec8566bb1aab564736f6c63430008210033",
      "deployedBytecode": "0x60806040526004361015610011575f80fd5b5f3560e01c8063036b54641461011457806306fdde031461010f5780630c8116701461010a5780631f4975b8146101055780633644e515146101005780634fedcdbf146100fb5780635b0e5556146100f65780636f2b25e0146100f1578063756fe481146100ec5780637e829b31146100e7578063a5a763b1146100e2578063a70354a1146100dd578063c0993eea146100d8578063c6186181146100d3578063d20e71e7146100ce5763ef0fe245146100c9575f80fd5b610ab7565b610987565b610943565b610909565b6108c5565b61085f565b610825565b6107e1565b61079e565b610661565b61062b565b610540565b610507565b6104cd565b6103da565b61014a565b9181601f84011215610146578235916001600160401b038311610146576020838186019501011161014657565b5f80fd5b34610146576060366003190112610146576004356001600160401b0381116101465761017a903690600401610119565b906024356001600160401b0381116101465761019a903690600401610119565b50506044356001600160401b038111610146576101bb903690600401610119565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03163303610330575f5c6101f73636610b16565b6020815191012003610321575f805d80610299575050818161024382826102205f978897610bf3565b6313d79a0b60e01b916001600160e01b03199161023c9161144e565b1614611484565b610252604051809381936114b8565b0390827f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165af16102896114c5565b901561029157005b602081519101fd5b80806102ba6102b46102ae6102c09587610bc8565b906113c7565b60601c90565b93610bd6565b9390916001600160a01b031690813b15610146575f80946102f76040519788968795869463d20e71e760e01b865260048601611427565b03925af1801561031c57610308575b005b806103165f61030693610381565b80610343565b610b95565b63f7a632f560e01b5f5260045ffd5b63472511eb60e11b5f523360045260245ffd5b5f91031261014657565b634e487b7160e01b5f52604160045260245ffd5b60e081019081106001600160401b0382111761037c57604052565b61034d565b90601f801991011681019081106001600160401b0382111761037c57604052565b805180835260209291819084018484015e5f828201840152601f01601f1916010190565b9060206103d79281815201906103a2565b90565b34610146575f366003190112610146576040515f6001548060011c90600181169081156104c3575b6020831082146104af5782855260208501919081156104965750600114610444575b6104408461043481860382610381565b604051918291826103c6565b0390f35b60015f9081529250907fb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf65b8184106104825750500161043482610424565b80548484015260209093019260010161046f565b60ff191682525090151560051b01905061043482610424565b634e487b7160e01b5f52602260045260245ffd5b91607f1691610402565b34610146575f3660031901126101465760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b34610146576020366003190112610146576004356001600160401b0381116101465761053a610306913690600401610119565b90610ce4565b34610146575f3660031901126101465760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b60405190610589608083610381565b565b600435906001600160a01b038216820361014657565b35906001600160a01b038216820361014657565b60e090600319011261014657604051906105ce82610361565b816004356001600160a01b03811681036101465781526105ee60246105a1565b6020820152604435604082015261060560646105a1565b606082015261061460846105a1565b608082015260a43560a082015260c060c435910152565b346101465760e036600319011261014657602061064f61064a366105b5565b610da0565b604051908152f35b8015150361014657565b346101465760403660031901126101465760043560243561068181610657565b335f525f60205260405f20825f526020527fc7a17c84cfc6bd62e248dc40d0d98f59040bcfbba3ed5cfe5a87aac90152ca7460405f20541461078757801561074057335f90815260208190526040902061070e906106e99084905b905f5260205260405f2090565b7ffdeb67b02819f1ab9c0e57355ac925e9fe35883f75ef41b364cd780799c5998a9055565b604051901515815233907fc96db6e691f7453f4a948b101f35561af4e2acf852cd1b95698ba775717a816a90602090a3005b335f9081526020819052604090206107829061075d9084906106dc565b7fc7a17c84cfc6bd62e248dc40d0d98f59040bcfbba3ed5cfe5a87aac90152ca749055565b61070e565b5063ae9c304b60e01b5f523360045260245260445ffd5b346101465760e0366003190112610146576104406107cd6107be366105b5565b6107c781610f31565b5061126f565b6040519182916020835260208301906103a2565b34610146576040366003190112610146576107fa61058b565b6001600160a01b03165f90815260208181526040808320602435845282529182902054915191825290f35b34610146575f3660031901126101465760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b346101465760403660031901126101465761087861058b565b6024359060018060a01b03165f525f60205260405f20905f5260205260207ffdeb67b02819f1ab9c0e57355ac925e9fe35883f75ef41b364cd780799c5998a60405f205414604051908152f35b34610146575f366003190112610146576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b34610146575f3660031901126101465760206040517f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f8152f35b34610146575f366003190112610146576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b34610146576040366003190112610146576004356001600160401b038111610146576109b7903690600401610119565b6024356001600160401b038111610146576109d6903690600401610119565b6040516302cc250d60e01b815233600482015293916020856024817f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165afa94851561031c5761030695610a3b915f91610a88575b503390610ba0565b610a8082610a6d610a68610a61610a5b610a558588610c01565b90610c44565b60f01c90565b61ffff1690565b610c8e565b610a78818386610c0f565b959094610c2c565b9490936112bc565b610aaa915060203d602011610ab0575b610aa28183610381565b810190610b80565b5f610a33565b503d610a98565b34610146575f366003190112610146576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b6001600160401b03811161037c57601f01601f191660200190565b919091610b2281610afb565b610b2f6040519182610381565b809382825282116101465781815f9384602080950137010152565b929192610b5682610afb565b91610b646040519384610381565b829481845281830111610146578281602093845f960137010152565b9081602091031261014657516103d781610657565b6040513d5f823e3d90fd5b15610ba85750565b6363546f7f60e01b5f9081526001600160a01b0391909116600452602490fd5b906014116101465790601490565b909291928360141161014657831161014657601401916013190190565b906004116101465790600490565b906002116101465790600290565b909291928360021161014657831161014657600201916001190190565b90939293848311610146578411610146578101920390565b356001600160f01b0319811692919060028210610c5f575050565b6001600160f01b031960029290920360031b82901b16169150565b634e487b7160e01b5f52601160045260245ffd5b6002019081600211610c9c57565b610c7a565b91908201809211610c9c57565b60405190610cbb82610361565b5f60c0838281528260208201528260408201528260608201528260808201528260a08201520152565b90610ced610cae565b50810181810361010081126101465760e0136101465760405191610d1083610361565b610d19816105a1565b8352610d27602082016105a1565b602084015260408101356040840152610d42606082016105a1565b6060840152610d53608082016105a1565b608084015260a081013560a084015260c081013560c084015260e0810135906001600160401b03821161014657019080601f8301121561014657816020610d9c93359101610b4a565b9091565b604290601f190180517f000000000000000000000000000000000000000000000000000000000000000082527f0000000000000000000000000000000000000000000000000000000000000000602001822091526040519061190160f01b82527f0000000000000000000000000000000000000000000000000000000000000000600283015260228201522090565b5f19810191908211610c9c57565b6001600160401b03811161037c5760051b60200190565b90610e5e82610e3d565b610e6b6040519182610381565b8281528092610e7c601f1991610e3d565b015f5b818110610e8b57505050565b6040519060808201918083106001600160401b0384111761037c576020926040525f81525f838201525f604082015260608082015282828601015201610e7f565b805115610ed95760200190565b634e487b7160e01b5f52603260045260245ffd5b805160011015610ed95760400190565b805160021015610ed95760600190565b805160031015610ed95760800190565b8051821015610ed95760209160051b010190565b610f3a906114f4565b90610f6c610f677f0000000000000000000000000000000000000000000000000000000000000000610e2f565b610e54565b60208381018051606086018051604051636a27f72d60e11b958101959095526001600160a01b0392831660248601528216604485015293957f00000000000000000000000000000000000000000000000000000000000000009091169390926111b99261117e9261117092610fee81606481015b03601f198101835282610381565b610ff661057a565b6001600160a01b0389168152905f60208301525f6040830152606082015261101d8a610ecc565b5261102789610ecc565b5081516080870180516040516330da145b60e21b60208201526001600160a01b0393841660248201529216604483015297906110668160648101610fe0565b61108061107161057a565b6001600160a01b039093168352565b5f60208301525f6040830152606082015261109a8a610eed565b526110a489610eed565b5085516110c3906001600160a01b03165b91516001600160a01b031690565b9061114460a08801519161111a6110e0865160018060a01b031690565b604051636e553f6560e01b602082015260248101959095526001600160a01b0316604485015283606481015b03601f198101855284610381565b61113461112561057a565b6001600160a01b039095168552565b6001600160a01b03166020840152565b5f6040830152606082015261115889610efd565b5261116288610efd565b50516001600160a01b031690565b93516001600160a01b031690565b60c08301519251604051630967fa2960e31b602082015260248101949094526001600160a01b031660448401529261111a836064810161110c565b5f604083015260608201526111cd83610f0d565b526111d782610f0d565b50600190565b602081016020825282518091526040820191602060408360051b8301019401925f915b83831061120f57505050505090565b9091929394602080611260600193603f19868203018752608060608b51878060a01b038151168452878060a01b038682015116868501526040810151604085015201519181606082015201906103a2565b97019301930191939290611200565b906020806103d79261129c6040519161064a8361110c8682019963305ab9e960e21b8b52602483016111dd565b6040519586925180918585015e8201908382015203018084520182610381565b919390610fe06113259261135095976113136112d88a8a610ce4565b99909a611301604051998a9862dad51960e21b60208b0152606060248b015260848a0191611407565b87810360231901604489015291611407565b84810360231901606486015291611407565b83516001600160a01b0316602085018051909491906001600160a01b03169186604081015194611599565b8151611364906001600160a01b03166110b5565b606083810151608085015160a086015160c090960151604080516001600160a01b039687168152602081019890985287015283169490831693909216917fce61442bb7edc056d7608dd78c8f3e9f8bdb65a5459af2f1224d7a160d0f1d7b9190a4565b356bffffffffffffffffffffffff198116929190601482106113e7575050565b6bffffffffffffffffffffffff1960149290920360031b82901b16169150565b908060209392818452848401375f828201840152601f01601f1916010190565b9290611440906103d79593604086526040860191611407565b926020818503910152611407565b356001600160e01b0319811692919060048210611469575050565b6001600160e01b031960049290920360031b82901b16169150565b91909115611490575050565b6114b46040519283926360de6df360e11b8452602060048501526024840191611407565b0390fd5b908092918237015f815290565b3d156114ef573d906114d682610afb565b916114e46040519384610381565b82523d5f602084013e565b606090565b6114fc610cae565b5090565b15611509575050565b632bf6252360e21b5f9081526001600160a01b039182166004529116602452604490fd5b15611536575050565b6302232baf60e51b5f5260045260245260445ffd5b6040519061155a602083610381565b5f808352366020840137565b5f198114610c9c5760010190565b1561157b57565b638533e92760e01b5f5260045ffd5b90816020910312610146575190565b91909394929460018060a01b038616916cffffffffffffffffffffffffff198760601b169486888261168160018060a01b038716986115ee84898d6cffffffffffffffffffffffffff198260601b1614611500565b8651156118ae575b6116406116227f0000000000000000000000000000000000000000000000000000000000000000610e54565b9c8d9561162e82610f31565b9990918a156118a0578b925b89611a47565b90805160208201205f5d61165261057a565b308152903060208301525f6040830152606082015261167a8261167481611566565b96610f1d565b528b610f1d565b508315611898575b916116a2916116a8938c61169b61154b565b928d611bdd565b91611574565b86527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031695863b15610146575f6116fb916040518093819263305ab9e960e21b8352600483016111dd565b0381838b5af1801561031c57611884575b50511561171c575b505050505050565b60405163b03c130d60e01b81526001600160681b0319949094166004850152306024850152602084604481885afa93841561031c575f94611853575b5060016001600160a01b03838518161b84166117f9575b50141590816117ec575b50611788575b80808080611714565b803b1561014657604051634fae231560e11b81526001600160a01b039290921660048301523060248301525f60448301819052908290606490829084905af1801561031c576117d8575b8061177f565b806103165f6117e693610381565b5f6117d2565b600191501615155f611779565b843b1561014657604051634fae231560e11b81526001600160a01b039190911660048201523060248201525f604482018190528160648183895af1801561031c571561176f57806103165f61184d93610381565b5f61176f565b61187691945060203d60201161187d575b61186e8183610381565b81019061158a565b925f611758565b503d611864565b806103165f61189293610381565b5f61170c565b5f9350611689565b6118a861154b565b9261163a565b6118c06118ba86610da0565b856118d3565b6118ce42844281101561152d565b6115f6565b60018060a01b03811690815f525f60205260405f20835f526020527ffdeb67b02819f1ab9c0e57355ac925e9fe35883f75ef41b364cd780799c5998a60405f2054145f146119615761075d836106dc61193b9360018060a01b03165f525f60205260405f2090565b7fb7c8974e057303dd6a257526d2baec5ecd92237f586b8e622451647cb37cee6f5f80a3565b6001600160a01b0381165f9081526020819052604090208390815f526020527fc7a17c84cfc6bd62e248dc40d0d98f59040bcfbba3ed5cfe5a87aac90152ca7460405f2054145f146119cd5763ae9c304b60e01b5f526001600160a01b0390911660045260245260445ffd5b635ae2147960e01b5f526001600160a01b0390911660045260245260445ffd5b95926103d7979592611a39959260018060a01b0316885260018060a01b031660208801526040870152606086015260808501525f60a085015261010060c08501526101008401906103a2565b9160e08184039101526103a2565b91929493905f93825115155f14611b885760405163096b649b60e11b81526001600160681b0319606083901b1660048201527f0000000000000000000000000000000000000000000000000000000000000000602482018190526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016989094906020836044818d5afa90811561031c576114fc99611b1c96610fe0955f94611b61575b5090611afd9161126f565b91604051978896635bedd1cd60e01b60208901523090602489016119ed565b611b36611b2761057a565b6001600160a01b039096168652565b5f60208601525f60408601526060850152611b5082611566565b93611b5b8383610f1d565b52610f1d565b611afd92919450611b809060203d60201161187d5761186e8183610381565b939091611af2565b50935050939250505f5b8151811015611bcf5780611bc8611bab60019385610f1d565b51611bb6835f610ca1565b90611bc18289610f1d565b5286610f1d565b5001611b92565b506103d7919250515f610ca1565b8451929593949193909215611cb85760405163096b649b60e11b81526001600160681b0319606088901b1660048201527f0000000000000000000000000000000000000000000000000000000000000000602482018190526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169790939091906020826044818c5afa801561031c576114fc98611b1c95610fe0945f93611c93575b50611afd90606061126f565b611afd919350611cb19060203d60201161187d5761186e8183610381565b9290611c87565b505093925090505f5b606051811015611cee5780611ce7611cdc6001936060610f1d565b51611bb68386610ca1565b5001611cc1565b506103d791925060605190610ca156fea2646970667358221220d9d413387e1ae755000c288cb86915e685a4ae790f24aa0090cec8566bb1aab564736f6c63430008210033",
      "linkReferences": {},
      "source": {
        "solcVersion": "0.8.33+commit.64118f21",
        "input": "{\"language\":\"Solidity\",\"sources\":{\"lib/euler-vault-kit/lib/ethereum-vault-connector/src/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport {IEVC} from \\\"./interfaces/IEthereumVaultConnector.sol\\\";\\n\\n/// @title Errors\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice This contract implements the error messages for the Ethereum Vault Connector.\\ncontract Errors {\\n    /// @notice Error for when caller is not authorized to perform an operation.\\n    error EVC_NotAuthorized();\\n    /// @notice Error for when no account has been authenticated to act on behalf of.\\n    error EVC_OnBehalfOfAccountNotAuthenticated();\\n    /// @notice Error for when an operator's to be set is no different from the current one.\\n    error EVC_InvalidOperatorStatus();\\n    /// @notice Error for when a nonce is invalid or already used.\\n    error EVC_InvalidNonce();\\n    /// @notice Error for when an address parameter passed is invalid.\\n    error EVC_InvalidAddress();\\n    /// @notice Error for when a timestamp parameter passed is expired.\\n    error EVC_InvalidTimestamp();\\n    /// @notice Error for when a value parameter passed is invalid or exceeds current balance.\\n    error EVC_InvalidValue();\\n    /// @notice Error for when data parameter passed is empty.\\n    error EVC_InvalidData();\\n    /// @notice Error for when an action is prohibited due to the lockdown mode.\\n    error EVC_LockdownMode();\\n    /// @notice Error for when permit execution is prohibited due to the permit disabled mode.\\n    error EVC_PermitDisabledMode();\\n    /// @notice Error for when checks are in progress and reentrancy is not allowed.\\n    error EVC_ChecksReentrancy();\\n    /// @notice Error for when control collateral is in progress and reentrancy is not allowed.\\n    error EVC_ControlCollateralReentrancy();\\n    /// @notice Error for when there is a different number of controllers enabled than expected.\\n    error EVC_ControllerViolation();\\n    /// @notice Error for when a simulation batch is nested within another simulation batch.\\n    error EVC_SimulationBatchNested();\\n    /// @notice Auxiliary error to pass simulation batch results.\\n    error EVC_RevertedBatchResult(\\n        IEVC.BatchItemResult[] batchItemsResult,\\n        IEVC.StatusCheckResult[] accountsStatusResult,\\n        IEVC.StatusCheckResult[] vaultsStatusResult\\n    );\\n    /// @notice Panic error for when simulation does not behave as expected. Should never be observed.\\n    error EVC_BatchPanic();\\n    /// @notice Error for when an empty or undefined error is thrown.\\n    error EVC_EmptyError();\\n}\\n\"},\"lib/euler-vault-kit/lib/ethereum-vault-connector/src/EthereumVaultConnector.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport {Set, SetStorage} from \\\"./Set.sol\\\";\\nimport {Events} from \\\"./Events.sol\\\";\\nimport {Errors} from \\\"./Errors.sol\\\";\\nimport {ExecutionContext, EC} from \\\"./ExecutionContext.sol\\\";\\nimport {TransientStorage} from \\\"./TransientStorage.sol\\\";\\nimport {IEVC} from \\\"./interfaces/IEthereumVaultConnector.sol\\\";\\nimport {IVault} from \\\"./interfaces/IVault.sol\\\";\\nimport {IERC1271} from \\\"./interfaces/IERC1271.sol\\\";\\n\\n/// @title EthereumVaultConnector\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice This contract implements the Ethereum Vault Connector.\\ncontract EthereumVaultConnector is Events, Errors, TransientStorage, IEVC {\\n    using ExecutionContext for EC;\\n    using Set for SetStorage;\\n\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n    //                                       CONSTANTS                                           //\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Name of the Ethereum Vault Connector.\\n    string public constant name = \\\"Ethereum Vault Connector\\\";\\n\\n    uint160 internal constant ACCOUNT_ID_OFFSET = 8;\\n    bytes32 internal constant HASHED_NAME = keccak256(bytes(name));\\n\\n    bytes32 internal constant TYPE_HASH =\\n        keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\");\\n\\n    bytes32 internal constant PERMIT_TYPEHASH = keccak256(\\n        \\\"Permit(address signer,address sender,uint256 nonceNamespace,uint256 nonce,uint256 deadline,uint256 value,bytes data)\\\"\\n    );\\n\\n    uint256 internal immutable CACHED_CHAIN_ID;\\n    bytes32 internal immutable CACHED_DOMAIN_SEPARATOR;\\n\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n    //                                        STORAGE                                            //\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    // EVC implements controller isolation, meaning that unless in transient state, only one controller per account can\\n    // be enabled. However, this can lead to a suboptimal user experience. In the event a user wants to have multiple\\n    // controllers enabled, a separate wallet must be created and funded. Although there is nothing wrong with having\\n    // many accounts within the same wallet, this can be a bad experience. In order to improve on this, EVC supports\\n    // the concept of an owner that owns 256 accounts within EVC.\\n\\n    // Every Ethereum address has 256 accounts in the EVC (including the primary account - called the owner).\\n    // Each account has an account ID from 0-255, where 0 is the owner account's ID. In order to compute the account\\n    // addresses, the account ID is treated as a uint256 and XORed (exclusive ORed) with the Ethereum address.\\n    // In order to record the owner of a group of 256 accounts, the EVC uses a definition of an address prefix.\\n    // An address prefix is a part of an address having the first 19 bytes common with any of the 256 account\\n    // addresses belonging to the same group.\\n    // account/152 -> prefix/152\\n    // To get an address prefix for the account, it's enough to take the account address and right shift it by 8 bits.\\n\\n    // Yes, this reduces the security of addresses by 8 bits, but creating multiple addresses in the wallet also reduces\\n    // security: if somebody is trying to brute-force one of user's N>1 private keys, they have N times as many chances\\n    // of succeeding per guess. It has to be admitted that the EVC model is weaker because finding a private key for\\n    // an owner gives access to all accounts, but there is still a very comfortable security margin.\\n\\n    // Internal data structure that stores the addressPrefix owner and mode flags\\n    struct OwnerStorage {\\n        // The addressPrefix owner\\n        address owner;\\n        // Flag indicating if the addressPrefix is in lockdown mode\\n        bool isLockdownMode;\\n        // Flag indicating if the permit function is disabled for the addressPrefix\\n        bool isPermitDisabledMode;\\n    }\\n\\n    mapping(bytes19 addressPrefix => OwnerStorage) internal ownerLookup;\\n\\n    mapping(bytes19 addressPrefix => mapping(address operator => uint256 operatorBitField)) internal operatorLookup;\\n\\n    mapping(bytes19 addressPrefix => mapping(uint256 nonceNamespace => uint256 nonce)) internal nonceLookup;\\n\\n    mapping(address account => SetStorage) internal accountCollaterals;\\n\\n    mapping(address account => SetStorage) internal accountControllers;\\n\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n    //                                CONSTRUCTOR, FALLBACKS                                     //\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    constructor() {\\n        CACHED_CHAIN_ID = block.chainid;\\n        CACHED_DOMAIN_SEPARATOR = calculateDomainSeparator();\\n    }\\n\\n    /// @notice Fallback function to receive Ether.\\n    receive() external payable {\\n        // only allows to receive value when checks are deferred\\n        if (!executionContext.areChecksDeferred()) {\\n            revert EVC_NotAuthorized();\\n        }\\n    }\\n\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n    //                                       MODIFIERS                                           //\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice A modifier that allows only the address recorded as an owner of the address prefix to call the function.\\n    /// @dev The owner of an address prefix is an address that matches the address that has previously been recorded (or\\n    /// will be) as an owner in the ownerLookup.\\n    /// @param addressPrefix The address prefix for which it is checked whether the caller is the owner.\\n    modifier onlyOwner(bytes19 addressPrefix) {\\n        authenticateCaller({addressPrefix: addressPrefix, allowOperator: false, checkLockdownMode: false});\\n\\n        _;\\n    }\\n\\n    /// @notice A modifier that allows only the owner or an operator of the account to call the function.\\n    /// @dev The owner of an address prefix is an address that matches the address that has previously been recorded (or\\n    /// will be) as an owner in the ownerLookup. An operator of an account is an address that has been authorized by the\\n    /// owner of an account to perform operations on behalf of the owner.\\n    /// @param account The address of the account for which it is checked whether the caller is the owner or an\\n    /// operator.\\n    modifier onlyOwnerOrOperator(address account) {\\n        authenticateCaller({account: account, allowOperator: true, checkLockdownMode: true});\\n\\n        _;\\n    }\\n\\n    /// @notice A modifier checks whether msg.sender is the only controller for the account.\\n    /// @dev The controller cannot use permit function in conjunction with this modifier.\\n    modifier onlyController(address account) {\\n        {\\n            uint256 numOfControllers = accountControllers[account].numElements;\\n            address controller = accountControllers[account].firstElement;\\n\\n            if (numOfControllers != 1) {\\n                revert EVC_ControllerViolation();\\n            }\\n\\n            if (controller != msg.sender) {\\n                revert EVC_NotAuthorized();\\n            }\\n        }\\n\\n        _;\\n    }\\n\\n    /// @notice A modifier that verifies whether account or vault status checks are re-entered.\\n    modifier nonReentrantChecks() {\\n        if (executionContext.areChecksInProgress()) {\\n            revert EVC_ChecksReentrancy();\\n        }\\n\\n        _;\\n    }\\n\\n    /// @notice A modifier that verifies whether account or vault status checks are re-entered as well as checks for\\n    /// controlCollateral re-entrancy.\\n    modifier nonReentrantChecksAndControlCollateral() {\\n        {\\n            EC context = executionContext;\\n\\n            if (context.areChecksInProgress()) {\\n                revert EVC_ChecksReentrancy();\\n            }\\n\\n            if (context.isControlCollateralInProgress()) {\\n                revert EVC_ControlCollateralReentrancy();\\n            }\\n        }\\n\\n        _;\\n    }\\n\\n    /// @notice A modifier that verifies whether account or vault status checks are re-entered and sets the lock.\\n    /// @dev This modifier also clears the current account on behalf of which the operation is performed as it shouldn't\\n    /// be relied upon when the checks are in progress.\\n    modifier nonReentrantChecksAcquireLock() {\\n        EC contextCache = executionContext;\\n\\n        if (contextCache.areChecksInProgress()) {\\n            revert EVC_ChecksReentrancy();\\n        }\\n\\n        executionContext = contextCache.setChecksInProgress().setOnBehalfOfAccount(address(0));\\n\\n        _;\\n\\n        executionContext = contextCache;\\n    }\\n\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n    //                                   PUBLIC FUNCTIONS                                        //\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    // Execution internals\\n\\n    /// @inheritdoc IEVC\\n    function getRawExecutionContext() external view returns (uint256 context) {\\n        context = EC.unwrap(executionContext);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function getCurrentOnBehalfOfAccount(address controllerToCheck)\\n        external\\n        view\\n        returns (address onBehalfOfAccount, bool controllerEnabled)\\n    {\\n        onBehalfOfAccount = executionContext.getOnBehalfOfAccount();\\n\\n        // for safety, revert if no account has been authenticated\\n        if (onBehalfOfAccount == address(0)) {\\n            revert EVC_OnBehalfOfAccountNotAuthenticated();\\n        }\\n\\n        controllerEnabled =\\n            controllerToCheck == address(0) ? false : accountControllers[onBehalfOfAccount].contains(controllerToCheck);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function areChecksDeferred() external view returns (bool) {\\n        return executionContext.areChecksDeferred();\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function areChecksInProgress() external view returns (bool) {\\n        return executionContext.areChecksInProgress();\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function isControlCollateralInProgress() external view returns (bool) {\\n        return executionContext.isControlCollateralInProgress();\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function isOperatorAuthenticated() external view returns (bool) {\\n        return executionContext.isOperatorAuthenticated();\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function isSimulationInProgress() external view returns (bool) {\\n        return executionContext.isSimulationInProgress();\\n    }\\n\\n    // Owners and operators\\n\\n    /// @inheritdoc IEVC\\n    function haveCommonOwner(address account, address otherAccount) external pure returns (bool) {\\n        return haveCommonOwnerInternal(account, otherAccount);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function getAddressPrefix(address account) external pure returns (bytes19) {\\n        return getAddressPrefixInternal(account);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function getAccountOwner(address account) external view returns (address) {\\n        bytes19 addressPrefix = getAddressPrefixInternal(account);\\n        return ownerLookup[addressPrefix].owner;\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function isLockdownMode(bytes19 addressPrefix) external view returns (bool) {\\n        return ownerLookup[addressPrefix].isLockdownMode;\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function isPermitDisabledMode(bytes19 addressPrefix) external view returns (bool) {\\n        return ownerLookup[addressPrefix].isPermitDisabledMode;\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function getNonce(bytes19 addressPrefix, uint256 nonceNamespace) external view returns (uint256) {\\n        return nonceLookup[addressPrefix][nonceNamespace];\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function getOperator(bytes19 addressPrefix, address operator) external view returns (uint256) {\\n        return operatorLookup[addressPrefix][operator];\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function isAccountOperatorAuthorized(address account, address operator) external view returns (bool) {\\n        return isAccountOperatorAuthorizedInternal(account, operator);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function setLockdownMode(bytes19 addressPrefix, bool enabled) public payable virtual onlyOwner(addressPrefix) {\\n        if (ownerLookup[addressPrefix].isLockdownMode != enabled) {\\n            // to increase user security, it is prohibited to disable this mode within the self-call of the permit\\n            // function or within a checks-deferrable call. to disable this mode, the setLockdownMode function must be\\n            // called directly\\n            if (!enabled && (executionContext.areChecksDeferred() || inPermitSelfCall())) {\\n                revert EVC_NotAuthorized();\\n            }\\n\\n            ownerLookup[addressPrefix].isLockdownMode = enabled;\\n            emit LockdownModeStatus(addressPrefix, enabled);\\n        }\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function setPermitDisabledMode(\\n        bytes19 addressPrefix,\\n        bool enabled\\n    ) public payable virtual onlyOwner(addressPrefix) {\\n        if (ownerLookup[addressPrefix].isPermitDisabledMode != enabled) {\\n            // to increase user security, it is prohibited to disable this mode within the self-call of the permit\\n            // function (verified in the permit function) or within a checks-deferrable call. to disable this mode the\\n            // setPermitDisabledMode function must be called directly\\n            if (!enabled && executionContext.areChecksDeferred()) {\\n                revert EVC_NotAuthorized();\\n            }\\n\\n            ownerLookup[addressPrefix].isPermitDisabledMode = enabled;\\n            emit PermitDisabledModeStatus(addressPrefix, enabled);\\n        }\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function setNonce(\\n        bytes19 addressPrefix,\\n        uint256 nonceNamespace,\\n        uint256 nonce\\n    ) public payable virtual onlyOwner(addressPrefix) {\\n        uint256 currentNonce = nonceLookup[addressPrefix][nonceNamespace];\\n\\n        if (currentNonce >= nonce) {\\n            revert EVC_InvalidNonce();\\n        }\\n\\n        nonceLookup[addressPrefix][nonceNamespace] = nonce;\\n\\n        emit NonceStatus(addressPrefix, nonceNamespace, currentNonce, nonce);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    /// @dev Uses authenticateCaller() function instead of onlyOwner() modifier to authenticate and get the caller\\n    /// address at once.\\n    function setOperator(bytes19 addressPrefix, address operator, uint256 operatorBitField) public payable virtual {\\n        address msgSender =\\n            authenticateCaller({addressPrefix: addressPrefix, allowOperator: false, checkLockdownMode: false});\\n\\n        // the operator can neither be the EVC nor can be one of 256 accounts of the owner\\n        if (operator == address(this) || haveCommonOwnerInternal(msgSender, operator)) {\\n            revert EVC_InvalidAddress();\\n        }\\n\\n        if (operatorLookup[addressPrefix][operator] == operatorBitField) {\\n            revert EVC_InvalidOperatorStatus();\\n        } else {\\n            operatorLookup[addressPrefix][operator] = operatorBitField;\\n\\n            emit OperatorStatus(addressPrefix, operator, operatorBitField);\\n        }\\n    }\\n\\n    /// @inheritdoc IEVC\\n    /// @dev Uses authenticateCaller() function instead of onlyOwnerOrOperator() modifier to authenticate and get the\\n    /// caller address at once.\\n    function setAccountOperator(address account, address operator, bool authorized) public payable virtual {\\n        address msgSender = authenticateCaller({account: account, allowOperator: true, checkLockdownMode: false});\\n        bytes19 addressPrefix = getAddressPrefixInternal(account);\\n\\n        // if the account and the caller have a common owner, the caller must be the owner. if the account and the\\n        // caller don't have a common owner, the caller must be an operator and the owner address is taken from the\\n        // storage. the caller authentication above guarantees that the account owner is already registered hence\\n        // non-zero\\n        address owner = haveCommonOwnerInternal(account, msgSender) ? msgSender : ownerLookup[addressPrefix].owner;\\n\\n        // if it's an operator calling, it can only act for itself and must not be able to change other operators status\\n        if (owner != msgSender && operator != msgSender) {\\n            revert EVC_NotAuthorized();\\n        }\\n\\n        // the operator can neither be the EVC nor can be one of 256 accounts of the owner\\n        if (operator == address(this) || haveCommonOwnerInternal(owner, operator)) {\\n            revert EVC_InvalidAddress();\\n        }\\n\\n        // The bitMask defines which accounts the operator is authorized for. The bitMask is created from the account\\n        // number which is a number up to 2^8 in binary, or 256. 1 << (uint160(owner) ^ uint160(account)) transforms\\n        // that number in an 256-position binary array like 0...010...0, marking the account positionally in a uint256.\\n        uint256 bitMask = 1 << (uint160(owner) ^ uint160(account));\\n\\n        // The operatorBitField is a 256-position binary array, where each 1 signals by position the account that the\\n        // operator is authorized for.\\n        uint256 oldOperatorBitField = operatorLookup[addressPrefix][operator];\\n        uint256 newOperatorBitField = authorized ? oldOperatorBitField | bitMask : oldOperatorBitField & ~bitMask;\\n\\n        if (oldOperatorBitField == newOperatorBitField) {\\n            revert EVC_InvalidOperatorStatus();\\n        } else {\\n            operatorLookup[addressPrefix][operator] = newOperatorBitField;\\n\\n            emit OperatorStatus(addressPrefix, operator, newOperatorBitField);\\n        }\\n    }\\n\\n    // Collaterals management\\n\\n    /// @inheritdoc IEVC\\n    function getCollaterals(address account) external view returns (address[] memory) {\\n        return accountCollaterals[account].get();\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function isCollateralEnabled(address account, address vault) external view returns (bool) {\\n        return accountCollaterals[account].contains(vault);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function enableCollateral(\\n        address account,\\n        address vault\\n    ) public payable virtual nonReentrantChecksAndControlCollateral onlyOwnerOrOperator(account) {\\n        if (vault == address(this)) revert EVC_InvalidAddress();\\n\\n        if (accountCollaterals[account].insert(vault)) {\\n            emit CollateralStatus(account, vault, true);\\n        }\\n        requireAccountStatusCheck(account);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function disableCollateral(\\n        address account,\\n        address vault\\n    ) public payable virtual nonReentrantChecksAndControlCollateral onlyOwnerOrOperator(account) {\\n        if (accountCollaterals[account].remove(vault)) {\\n            emit CollateralStatus(account, vault, false);\\n        }\\n        requireAccountStatusCheck(account);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function reorderCollaterals(\\n        address account,\\n        uint8 index1,\\n        uint8 index2\\n    ) public payable virtual nonReentrantChecksAndControlCollateral onlyOwnerOrOperator(account) {\\n        accountCollaterals[account].reorder(index1, index2);\\n        requireAccountStatusCheck(account);\\n    }\\n\\n    // Controllers management\\n\\n    /// @inheritdoc IEVC\\n    function getControllers(address account) external view returns (address[] memory) {\\n        return accountControllers[account].get();\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function isControllerEnabled(address account, address vault) external view returns (bool) {\\n        return accountControllers[account].contains(vault);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function enableController(\\n        address account,\\n        address vault\\n    ) public payable virtual nonReentrantChecksAndControlCollateral onlyOwnerOrOperator(account) {\\n        if (vault == address(this)) revert EVC_InvalidAddress();\\n\\n        if (accountControllers[account].insert(vault)) {\\n            emit ControllerStatus(account, vault, true);\\n        }\\n        requireAccountStatusCheck(account);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function disableController(address account) public payable virtual nonReentrantChecksAndControlCollateral {\\n        if (accountControllers[account].remove(msg.sender)) {\\n            emit ControllerStatus(account, msg.sender, false);\\n        }\\n        requireAccountStatusCheck(account);\\n    }\\n\\n    // Permit\\n\\n    /// @inheritdoc IEVC\\n    function permit(\\n        address signer,\\n        address sender,\\n        uint256 nonceNamespace,\\n        uint256 nonce,\\n        uint256 deadline,\\n        uint256 value,\\n        bytes calldata data,\\n        bytes calldata signature\\n    ) public payable virtual nonReentrantChecksAndControlCollateral {\\n        // cannot be called within the self-call of the permit function; can occur for nested calls.\\n        // the permit function can be called only by the specified sender, unless address zero is specified in which\\n        // case anyone can call it\\n        if (inPermitSelfCall() || (sender != address(0) && sender != msg.sender)) {\\n            revert EVC_NotAuthorized();\\n        }\\n\\n        if (signer == address(0) || !isSignerValid(signer)) {\\n            revert EVC_InvalidAddress();\\n        }\\n\\n        bytes19 addressPrefix = getAddressPrefixInternal(signer);\\n\\n        if (ownerLookup[addressPrefix].isPermitDisabledMode) {\\n            revert EVC_PermitDisabledMode();\\n        }\\n\\n        {\\n            uint256 currentNonce = nonceLookup[addressPrefix][nonceNamespace];\\n\\n            if (currentNonce == type(uint256).max || currentNonce != nonce) {\\n                revert EVC_InvalidNonce();\\n            }\\n        }\\n\\n        if (deadline < block.timestamp) {\\n            revert EVC_InvalidTimestamp();\\n        }\\n\\n        if (data.length == 0) {\\n            revert EVC_InvalidData();\\n        }\\n\\n        bytes32 permitHash = getPermitHash(signer, sender, nonceNamespace, nonce, deadline, value, data);\\n\\n        if (\\n            signer != recoverECDSASigner(permitHash, signature)\\n                && !isValidERC1271Signature(signer, permitHash, signature)\\n        ) {\\n            revert EVC_NotAuthorized();\\n        }\\n\\n        unchecked {\\n            nonceLookup[addressPrefix][nonceNamespace] = nonce + 1;\\n        }\\n\\n        emit NonceUsed(addressPrefix, nonceNamespace, nonce);\\n\\n        // EVC address becomes the msg.sender for the duration this self-call, no authentication is required here.\\n        // the signer will be later on authenticated as per data, depending on the functions that will be called\\n        (bool success, bytes memory result) = callWithContextInternal(address(this), signer, value, data);\\n\\n        if (!success) revertBytes(result);\\n    }\\n\\n    // Calls forwarding\\n\\n    /// @inheritdoc IEVC\\n    function call(\\n        address targetContract,\\n        address onBehalfOfAccount,\\n        uint256 value,\\n        bytes calldata data\\n    ) public payable virtual nonReentrantChecksAndControlCollateral returns (bytes memory result) {\\n        EC contextCache = executionContext;\\n        executionContext = contextCache.setChecksDeferred();\\n\\n        bool success;\\n        (success, result) = callWithAuthenticationInternal(targetContract, onBehalfOfAccount, value, data);\\n\\n        if (!success) revertBytes(result);\\n\\n        restoreExecutionContext(contextCache);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function controlCollateral(\\n        address targetCollateral,\\n        address onBehalfOfAccount,\\n        uint256 value,\\n        bytes calldata data\\n    )\\n        public\\n        payable\\n        virtual\\n        nonReentrantChecksAndControlCollateral\\n        onlyController(onBehalfOfAccount)\\n        returns (bytes memory result)\\n    {\\n        if (!accountCollaterals[onBehalfOfAccount].contains(targetCollateral)) {\\n            revert EVC_NotAuthorized();\\n        }\\n\\n        EC contextCache = executionContext;\\n        executionContext = contextCache.setChecksDeferred().setControlCollateralInProgress();\\n\\n        bool success;\\n        (success, result) = callWithContextInternal(targetCollateral, onBehalfOfAccount, value, data);\\n\\n        if (!success) revertBytes(result);\\n\\n        restoreExecutionContext(contextCache);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function batch(BatchItem[] calldata items) public payable virtual nonReentrantChecksAndControlCollateral {\\n        EC contextCache = executionContext;\\n        executionContext = contextCache.setChecksDeferred();\\n\\n        uint256 length = items.length;\\n        for (uint256 i; i < length; ++i) {\\n            BatchItem calldata item = items[i];\\n            (bool success, bytes memory result) =\\n                callWithAuthenticationInternal(item.targetContract, item.onBehalfOfAccount, item.value, item.data);\\n\\n            if (!success) revertBytes(result);\\n        }\\n\\n        restoreExecutionContext(contextCache);\\n    }\\n\\n    // Simulations\\n\\n    /// @inheritdoc IEVC\\n    function batchRevert(BatchItem[] calldata items) public payable virtual nonReentrantChecksAndControlCollateral {\\n        BatchItemResult[] memory batchItemsResult;\\n        StatusCheckResult[] memory accountsStatusCheckResult;\\n        StatusCheckResult[] memory vaultsStatusCheckResult;\\n\\n        EC contextCache = executionContext;\\n\\n        if (contextCache.areChecksDeferred()) {\\n            revert EVC_SimulationBatchNested();\\n        }\\n\\n        executionContext = contextCache.setChecksDeferred().setSimulationInProgress();\\n\\n        uint256 length = items.length;\\n        batchItemsResult = new BatchItemResult[](length);\\n\\n        for (uint256 i; i < length; ++i) {\\n            BatchItem calldata item = items[i];\\n            (batchItemsResult[i].success, batchItemsResult[i].result) =\\n                callWithAuthenticationInternal(item.targetContract, item.onBehalfOfAccount, item.value, item.data);\\n        }\\n\\n        executionContext = contextCache.setChecksInProgress().setOnBehalfOfAccount(address(0));\\n\\n        accountsStatusCheckResult = checkStatusAllWithResult(SetType.Account);\\n        vaultsStatusCheckResult = checkStatusAllWithResult(SetType.Vault);\\n\\n        executionContext = contextCache;\\n\\n        revert EVC_RevertedBatchResult(batchItemsResult, accountsStatusCheckResult, vaultsStatusCheckResult);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function batchSimulation(BatchItem[] calldata items)\\n        external\\n        payable\\n        virtual\\n        returns (\\n            BatchItemResult[] memory batchItemsResult,\\n            StatusCheckResult[] memory accountsStatusCheckResult,\\n            StatusCheckResult[] memory vaultsStatusCheckResult\\n        )\\n    {\\n        (bool success, bytes memory result) = address(this).delegatecall(abi.encodeCall(this.batchRevert, items));\\n\\n        if (success) {\\n            revert EVC_BatchPanic();\\n        } else if (result.length < 4 || bytes4(result) != EVC_RevertedBatchResult.selector) {\\n            revertBytes(result);\\n        }\\n\\n        assembly {\\n            let length := mload(result)\\n            // skip 4-byte EVC_RevertedBatchResult selector\\n            result := add(result, 4)\\n            // write new array length = original length - 4-byte selector\\n            // cannot underflow as we require result.length >= 4 above\\n            mstore(result, sub(length, 4))\\n        }\\n\\n        (batchItemsResult, accountsStatusCheckResult, vaultsStatusCheckResult) =\\n            abi.decode(result, (BatchItemResult[], StatusCheckResult[], StatusCheckResult[]));\\n    }\\n\\n    // Account Status Check\\n\\n    /// @inheritdoc IEVC\\n    function getLastAccountStatusCheckTimestamp(address account) external view nonReentrantChecks returns (uint256) {\\n        return accountControllers[account].getMetadata();\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function isAccountStatusCheckDeferred(address account) external view nonReentrantChecks returns (bool) {\\n        return accountStatusChecks.contains(account);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function requireAccountStatusCheck(address account) public payable virtual {\\n        if (executionContext.areChecksDeferred()) {\\n            accountStatusChecks.insert(account);\\n        } else {\\n            requireAccountStatusCheckInternalNonReentrantChecks(account);\\n        }\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function forgiveAccountStatusCheck(address account)\\n        public\\n        payable\\n        virtual\\n        nonReentrantChecksAcquireLock\\n        onlyController(account)\\n    {\\n        accountStatusChecks.remove(account);\\n    }\\n\\n    // Vault Status Check\\n\\n    /// @inheritdoc IEVC\\n    function isVaultStatusCheckDeferred(address vault) external view nonReentrantChecks returns (bool) {\\n        return vaultStatusChecks.contains(vault);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function requireVaultStatusCheck() public payable virtual {\\n        if (executionContext.areChecksDeferred()) {\\n            vaultStatusChecks.insert(msg.sender);\\n        } else {\\n            requireVaultStatusCheckInternalNonReentrantChecks(msg.sender);\\n        }\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function forgiveVaultStatusCheck() public payable virtual nonReentrantChecksAcquireLock {\\n        vaultStatusChecks.remove(msg.sender);\\n    }\\n\\n    /// @inheritdoc IEVC\\n    function requireAccountAndVaultStatusCheck(address account) public payable virtual {\\n        if (executionContext.areChecksDeferred()) {\\n            accountStatusChecks.insert(account);\\n            vaultStatusChecks.insert(msg.sender);\\n        } else {\\n            requireAccountStatusCheckInternalNonReentrantChecks(account);\\n            requireVaultStatusCheckInternalNonReentrantChecks(msg.sender);\\n        }\\n    }\\n\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n    //                                  INTERNAL FUNCTIONS                                       //\\n    ///////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Authenticates the caller of a function.\\n    /// @dev This function checks if the caller is the owner or an authorized operator of the account, and if the\\n    /// account is not in lockdown mode.\\n    /// @param account The account address to authenticate the caller against.\\n    /// @param allowOperator A boolean indicating if operators are allowed to authenticate as the caller.\\n    /// @param checkLockdownMode A boolean indicating if the function should check for lockdown mode on the account.\\n    /// @return The address of the authenticated caller.\\n    function authenticateCaller(\\n        address account,\\n        bool allowOperator,\\n        bool checkLockdownMode\\n    ) internal virtual returns (address) {\\n        bytes19 addressPrefix = getAddressPrefixInternal(account);\\n        address owner = ownerLookup[addressPrefix].owner;\\n        bool lockdownMode = ownerLookup[addressPrefix].isLockdownMode;\\n        address msgSender = _msgSender();\\n        bool authenticated = false;\\n\\n        // check if the caller is the owner of the account\\n        if (haveCommonOwnerInternal(account, msgSender)) {\\n            // if the owner is not registered, register it\\n            if (owner == address(0)) {\\n                ownerLookup[addressPrefix].owner = owner = msgSender;\\n                emit OwnerRegistered(addressPrefix, msgSender);\\n                authenticated = true;\\n            } else if (owner == msgSender) {\\n                authenticated = true;\\n            }\\n        }\\n\\n        // if the caller is not the owner, check if it is an operator if operators are allowed\\n        if (!authenticated && allowOperator && isAccountOperatorAuthorizedInternal(account, msgSender)) {\\n            authenticated = true;\\n        }\\n\\n        // if the authenticated account is non-owner, prevent its account from being a smart contract\\n        if (authenticated && owner != account && account.code.length != 0) {\\n            authenticated = false;\\n        }\\n\\n        // must revert if neither the owner nor the operator were authenticated\\n        if (!authenticated) {\\n            revert EVC_NotAuthorized();\\n        }\\n\\n        // revert if the account is in lockdown mode unless the lockdown mode is not being checked\\n        if (checkLockdownMode && lockdownMode) {\\n            revert EVC_LockdownMode();\\n        }\\n\\n        return msgSender;\\n    }\\n\\n    /// @notice Authenticates the caller of a function.\\n    /// @dev This function either passes the address prefix owner address, if the address prefix owner is already\\n    /// registered, or converts the bytes19 address prefix into an account address which will belong to the owner when\\n    /// it's finally registered.\\n    /// @param addressPrefix The bytes19 address prefix to authenticate the caller against.\\n    /// @param allowOperator A boolean indicating if operators are allowed to authenticate as the caller.\\n    /// @param checkLockdownMode A boolean indicating if the function should check for lockdown mode on the account.\\n    /// @return The address of the authenticated caller.\\n    function authenticateCaller(\\n        bytes19 addressPrefix,\\n        bool allowOperator,\\n        bool checkLockdownMode\\n    ) internal virtual returns (address) {\\n        address owner = ownerLookup[addressPrefix].owner;\\n\\n        return authenticateCaller({\\n            account: owner == address(0) ? address(uint160(uint152(addressPrefix)) << ACCOUNT_ID_OFFSET) : owner,\\n            allowOperator: allowOperator,\\n            checkLockdownMode: checkLockdownMode\\n        });\\n    }\\n\\n    /// @notice Internal function to make a call to a target contract with a specific context.\\n    /// @dev This function sets the execution context for the duration of the call.\\n    /// @param targetContract The contract address to call.\\n    /// @param onBehalfOfAccount The account address on behalf of which the call is made.\\n    /// @param value The amount of value to send with the call.\\n    /// @param data The calldata to send with the call.\\n    function callWithContextInternal(\\n        address targetContract,\\n        address onBehalfOfAccount,\\n        uint256 value,\\n        bytes calldata data\\n    ) internal virtual returns (bool success, bytes memory result) {\\n        if (value == type(uint256).max) {\\n            value = address(this).balance;\\n        } else if (value > address(this).balance) {\\n            revert EVC_InvalidValue();\\n        }\\n\\n        EC contextCache = executionContext;\\n        address msgSender = _msgSender();\\n\\n        // set the onBehalfOfAccount in the execution context for the duration of the external call.\\n        // considering that the operatorAuthenticated is only meant to be observable by external\\n        // contracts, it is sufficient to set it here rather than in the authentication function.\\n        // apart from the usual scenario (when an owner operates on behalf of its account),\\n        // the operatorAuthenticated should be cleared when about to execute the permit self-call, when\\n        // target contract is equal to the msg.sender in call() and batch(), or when the controlCollateral is in\\n        // progress (in which case the operatorAuthenticated is not relevant)\\n        if (\\n            haveCommonOwnerInternal(onBehalfOfAccount, msgSender) || targetContract == msg.sender\\n                || targetContract == address(this) || contextCache.isControlCollateralInProgress()\\n        ) {\\n            executionContext = contextCache.setOnBehalfOfAccount(onBehalfOfAccount).clearOperatorAuthenticated();\\n        } else {\\n            executionContext = contextCache.setOnBehalfOfAccount(onBehalfOfAccount).setOperatorAuthenticated();\\n        }\\n\\n        emit CallWithContext(\\n            msgSender, getAddressPrefixInternal(onBehalfOfAccount), onBehalfOfAccount, targetContract, bytes4(data)\\n        );\\n\\n        (success, result) = targetContract.call{value: value}(data);\\n\\n        executionContext = contextCache;\\n    }\\n\\n    /// @notice Internal function to call a target contract with necessary authentication.\\n    /// @dev This function decides whether to use delegatecall or a regular call based on the target contract.\\n    /// If the target contract is this contract, it uses delegatecall to preserve msg.sender for authentication.\\n    /// Otherwise, it authenticates the caller if needed and proceeds with a regular call.\\n    /// @param targetContract The contract address to call.\\n    /// @param onBehalfOfAccount The account address on behalf of which the call is made.\\n    /// @param value The amount of value to send with the call.\\n    /// @param data The calldata to send with the call.\\n    /// @return success A boolean indicating if the call was successful.\\n    /// @return result The bytes returned from the call.\\n    function callWithAuthenticationInternal(\\n        address targetContract,\\n        address onBehalfOfAccount,\\n        uint256 value,\\n        bytes calldata data\\n    ) internal virtual returns (bool success, bytes memory result) {\\n        if (targetContract == address(this)) {\\n            if (onBehalfOfAccount != address(0)) {\\n                revert EVC_InvalidAddress();\\n            }\\n\\n            if (value != 0) {\\n                revert EVC_InvalidValue();\\n            }\\n\\n            // delegatecall is used here to preserve msg.sender in order to be able to perform authentication\\n            (success, result) = address(this).delegatecall(data);\\n        } else {\\n            // when the target contract is equal to the msg.sender, both in call() and batch(), authentication is not\\n            // required\\n            if (targetContract != msg.sender) {\\n                authenticateCaller({account: onBehalfOfAccount, allowOperator: true, checkLockdownMode: true});\\n            }\\n\\n            (success, result) = callWithContextInternal(targetContract, onBehalfOfAccount, value, data);\\n        }\\n    }\\n\\n    /// @notice Restores the execution context from a cached state.\\n    /// @dev This function restores the execution context to a previously cached state, performing necessary status\\n    /// checks if they are no longer deferred. If checks are no longer deferred, it sets the execution context to\\n    /// indicate checks are in progress and clears the 'on behalf of' account. It then performs status checks for both\\n    /// accounts and vaults before restoring the execution context to the cached state.\\n    /// @param contextCache The cached execution context to restore from.\\n    function restoreExecutionContext(EC contextCache) internal virtual {\\n        if (!contextCache.areChecksDeferred()) {\\n            executionContext = contextCache.setChecksInProgress().setOnBehalfOfAccount(address(0));\\n\\n            checkStatusAll(SetType.Account);\\n            checkStatusAll(SetType.Vault);\\n        }\\n\\n        executionContext = contextCache;\\n    }\\n\\n    /// @notice Checks the status of an account internally.\\n    /// @dev This function first checks the number of controllers for the account. If there are no controllers enabled,\\n    /// it returns true immediately, indicating the account status is valid without further checks. If there is more\\n    /// than one controller, it reverts with an EVC_ControllerViolation error. For a single controller, it proceeds to\\n    /// call the controller to check the account status.\\n    /// @param account The account address to check the status for.\\n    /// @return isValid A boolean indicating if the account status is valid.\\n    /// @return result The bytes returned from the controller call, indicating the account status.\\n    function checkAccountStatusInternal(address account) internal virtual returns (bool isValid, bytes memory result) {\\n        SetStorage storage accountControllersStorage = accountControllers[account];\\n        uint256 numOfControllers = accountControllersStorage.numElements;\\n        address controller = accountControllersStorage.firstElement;\\n        uint8 stamp = accountControllersStorage.stamp;\\n\\n        if (numOfControllers == 0) return (true, \\\"\\\");\\n        else if (numOfControllers > 1) return (false, abi.encodeWithSelector(EVC_ControllerViolation.selector));\\n\\n        bool success;\\n        (success, result) = controller.staticcall(\\n            abi.encodeCall(IVault.checkAccountStatus, (account, accountCollaterals[account].get()))\\n        );\\n\\n        isValid = success && result.length == 32\\n            && abi.decode(result, (bytes32)) == bytes32(IVault.checkAccountStatus.selector);\\n\\n        if (isValid) {\\n            accountControllersStorage.numElements = uint8(numOfControllers);\\n            accountControllersStorage.firstElement = controller;\\n            accountControllersStorage.metadata = uint80(block.timestamp);\\n            accountControllersStorage.stamp = stamp;\\n        }\\n\\n        emit AccountStatusCheck(account, controller);\\n    }\\n\\n    function requireAccountStatusCheckInternal(address account) internal virtual {\\n        (bool isValid, bytes memory result) = checkAccountStatusInternal(account);\\n\\n        if (!isValid) {\\n            revertBytes(result);\\n        }\\n    }\\n\\n    function requireAccountStatusCheckInternalNonReentrantChecks(address account)\\n        internal\\n        virtual\\n        nonReentrantChecksAcquireLock\\n    {\\n        requireAccountStatusCheckInternal(account);\\n    }\\n\\n    /// @notice Checks the status of a vault internally.\\n    /// @dev This function makes an external call to the vault to check its status.\\n    /// @param vault The address of the vault to check the status for.\\n    /// @return isValid A boolean indicating if the vault status is valid.\\n    /// @return result The bytes returned from the vault call, indicating the vault status.\\n    function checkVaultStatusInternal(address vault) internal virtual returns (bool isValid, bytes memory result) {\\n        bool success;\\n        (success, result) = vault.call(abi.encodeCall(IVault.checkVaultStatus, ()));\\n\\n        isValid =\\n            success && result.length == 32 && abi.decode(result, (bytes32)) == bytes32(IVault.checkVaultStatus.selector);\\n\\n        emit VaultStatusCheck(vault);\\n    }\\n\\n    function requireVaultStatusCheckInternal(address vault) internal virtual {\\n        (bool isValid, bytes memory result) = checkVaultStatusInternal(vault);\\n\\n        if (!isValid) {\\n            revertBytes(result);\\n        }\\n    }\\n\\n    function requireVaultStatusCheckInternalNonReentrantChecks(address vault)\\n        internal\\n        virtual\\n        nonReentrantChecksAcquireLock\\n    {\\n        requireVaultStatusCheckInternal(vault);\\n    }\\n\\n    /// @notice Checks the status of all entities in a set, either accounts or vaults, and clears the checks.\\n    /// @dev Iterates over either accountStatusChecks or vaultStatusChecks based on the setType and performs status\\n    /// checks.\\n    /// Clears the checks while performing them.\\n    /// @param setType The type of set to perform the status checks on, either accounts or vaults.\\n    function checkStatusAll(SetType setType) internal virtual {\\n        setType == SetType.Account\\n            ? accountStatusChecks.forEachAndClear(requireAccountStatusCheckInternal)\\n            : vaultStatusChecks.forEachAndClear(requireVaultStatusCheckInternal);\\n    }\\n\\n    function checkStatusAllWithResult(SetType setType)\\n        internal\\n        virtual\\n        returns (StatusCheckResult[] memory checksResult)\\n    {\\n        bytes[] memory callbackResult = setType == SetType.Account\\n            ? accountStatusChecks.forEachAndClearWithResult(checkAccountStatusInternal)\\n            : vaultStatusChecks.forEachAndClearWithResult(checkVaultStatusInternal);\\n\\n        uint256 length = callbackResult.length;\\n        checksResult = new StatusCheckResult[](length);\\n\\n        for (uint256 i; i < length; ++i) {\\n            (address checkedAddress, bool isValid, bytes memory result) =\\n                abi.decode(callbackResult[i], (address, bool, bytes));\\n            checksResult[i] = StatusCheckResult({checkedAddress: checkedAddress, isValid: isValid, result: result});\\n        }\\n    }\\n\\n    // Permit-related functions\\n\\n    /// @notice Determines if the signer address is valid.\\n    /// @dev It's important to revisit this logic when deploying on chains other than the Ethereum mainnet. If new\\n    /// precompiles had been added to the Ethereum mainnet, the current implementation of the function would not be\\n    /// future-proof and would need to be updated.\\n    /// @param signer The address of the signer to validate.\\n    /// @return bool Returns true if the signer is valid, false otherwise.\\n    function isSignerValid(address signer) internal pure virtual returns (bool) {\\n        // not valid if the signer address falls into any of the precompiles/predeploys\\n        // addresses space (depends on the chain ID).\\n        return !haveCommonOwnerInternal(signer, address(0));\\n    }\\n\\n    /// @notice Computes the permit hash for a given set of parameters.\\n    /// @dev This function generates a permit hash using EIP712 typed data signing.\\n    /// @param signer The address of the signer.\\n    /// @param nonceNamespace The namespace of the nonce.\\n    /// @param nonce The nonce value, ensuring permits are used once.\\n    /// @param deadline The time until when the permit is valid.\\n    /// @param value The value associated with the permit.\\n    /// @param data Calldata associated with the permit.\\n    /// @return permitHash The computed permit hash.\\n    function getPermitHash(\\n        address signer,\\n        address sender,\\n        uint256 nonceNamespace,\\n        uint256 nonce,\\n        uint256 deadline,\\n        uint256 value,\\n        bytes calldata data\\n    ) internal view returns (bytes32 permitHash) {\\n        bytes32 domainSeparator =\\n            block.chainid == CACHED_CHAIN_ID ? CACHED_DOMAIN_SEPARATOR : calculateDomainSeparator();\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(PERMIT_TYPEHASH, signer, sender, nonceNamespace, nonce, deadline, value, keccak256(data))\\n        );\\n\\n        // This code overwrites the two most significant bytes of the free memory pointer,\\n        // and restores them to 0 after\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, \\\"\\\\x19\\\\x01\\\")\\n            mstore(0x02, domainSeparator)\\n            mstore(0x22, structHash)\\n            permitHash := keccak256(0x00, 0x42)\\n            mstore(0x22, 0)\\n        }\\n    }\\n\\n    /// @notice Recovers the signer address from a hash and a signature.\\n    /// Based on:\\n    /// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol\\n    /// Note that the function returns zero address if the signature is invalid hence the result always has to be\\n    /// checked against address zero.\\n    /// @param hash The hash of the signed data.\\n    /// @param signature The signature to recover the signer from.\\n    /// @return signer The address of the signer, or the zero address if signature recovery fails.\\n    function recoverECDSASigner(bytes32 hash, bytes memory signature) internal pure returns (address signer) {\\n        if (signature.length != 65) return address(0);\\n\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // ecrecover takes the signature parameters, and the only way to get them\\n        // currently is to use assembly.\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return address(0);\\n        }\\n\\n        // return the signer address (note that it might be zero address)\\n        signer = ecrecover(hash, v, r, s);\\n    }\\n\\n    /// @notice Checks if a given signature is valid according to ERC-1271 standard.\\n    /// @dev This function is based on the implementation found in OpenZeppelin's SignatureChecker.\\n    /// See:\\n    /// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/SignatureChecker.sol\\n    /// It performs a static call to the signer's address with the signature data and checks if the returned value\\n    /// matches the expected valid signature selector.\\n    /// @param signer The address of the signer to validate the signature against.\\n    /// @param hash The hash of the data that was signed.\\n    /// @param signature The signature to validate.\\n    /// @return isValid True if the signature is valid according to ERC-1271, false otherwise.\\n    function isValidERC1271Signature(\\n        address signer,\\n        bytes32 hash,\\n        bytes memory signature\\n    ) internal view returns (bool isValid) {\\n        if (signer.code.length == 0) return false;\\n\\n        (bool success, bytes memory result) =\\n            signer.staticcall(abi.encodeCall(IERC1271.isValidSignature, (hash, signature)));\\n\\n        isValid = success && result.length == 32\\n            && abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector);\\n    }\\n\\n    /// @notice Calculates the EIP-712 domain separator for the contract.\\n    /// @return The calculated EIP-712 domain separator as a bytes32 value.\\n    function calculateDomainSeparator() internal view returns (bytes32) {\\n        return keccak256(abi.encode(TYPE_HASH, HASHED_NAME, block.chainid, address(this)));\\n    }\\n\\n    // Auxiliary functions\\n\\n    /// @notice Returns the message sender's address.\\n    /// @dev In the context of a permit self-call, it returns the account on behalf of which the call is made.\\n    /// Otherwise, it returns `msg.sender`.\\n    /// @return The address of the message sender or the account on behalf of which the call is made.\\n    function _msgSender() internal view virtual returns (address) {\\n        return inPermitSelfCall() ? executionContext.getOnBehalfOfAccount() : msg.sender;\\n    }\\n\\n    /// @notice Checks if the contract is in the context of a permit self-call.\\n    /// @dev EVC can only be `msg.sender` during the self-call in the permit function.\\n    /// @return True if the current call is a self-call within the permit function, false otherwise.\\n    function inPermitSelfCall() internal view returns (bool) {\\n        return address(this) == msg.sender;\\n    }\\n\\n    /// @notice Determines if two accounts have a common owner by comparing their address prefixes.\\n    /// @param account The first account address to compare.\\n    /// @param otherAccount The second account address to compare.\\n    /// @return result True if the accounts have a common owner, false otherwise.\\n    function haveCommonOwnerInternal(address account, address otherAccount) internal pure returns (bool result) {\\n        assembly {\\n            result := lt(xor(account, otherAccount), 0x100)\\n        }\\n    }\\n\\n    /// @notice Computes the address prefix for a given account address.\\n    /// @dev The address prefix is derived by right-shifting the account address by 8 bits which effectively reduces the\\n    /// address size to 19 bytes.\\n    /// @param account The account address to compute the prefix for.\\n    /// @return The computed address prefix as a bytes19 value.\\n    function getAddressPrefixInternal(address account) internal pure returns (bytes19) {\\n        return bytes19(uint152(uint160(account) >> ACCOUNT_ID_OFFSET));\\n    }\\n\\n    /// @notice Checks if an operator is authorized for a specific account.\\n    /// @dev Determines operator authorization by checking if the operator's bit is set in the operator's bit field for\\n    /// the account's address prefix. If the owner is not registered (address(0)), it implies the operator cannot be\\n    /// authorized, hence returns false. The bitMask is calculated by shifting 1 left by the XOR of the owner's and\\n    /// account's address, effectively checking the operator's authorization for the specific account.\\n    /// @param account The account address to check the operator authorization for.\\n    /// @param operator The operator address to check authorization status.\\n    /// @return isAuthorized True if the operator is authorized for the account, false otherwise.\\n    function isAccountOperatorAuthorizedInternal(\\n        address account,\\n        address operator\\n    ) internal view returns (bool isAuthorized) {\\n        bytes19 addressPrefix = getAddressPrefixInternal(account);\\n        address owner = ownerLookup[addressPrefix].owner;\\n\\n        // if the owner is not registered yet, it means that the operator couldn't have been authorized\\n        if (owner == address(0)) return false;\\n\\n        // The bitMask defines which accounts the operator is authorized for. The bitMask is created from the account\\n        // number which is a number up to 2^8 in binary, or 256. 1 << (uint160(owner) ^ uint160(account)) transforms\\n        // that number in an 256-position binary array like 0...010...0, marking the account positionally in a uint256.\\n        uint256 bitMask = 1 << (uint160(owner) ^ uint160(account));\\n\\n        return operatorLookup[addressPrefix][operator] & bitMask != 0;\\n    }\\n\\n    /// @notice Reverts the transaction with a custom error message if provided, otherwise reverts with a generic empty\\n    /// error.\\n    /// @param errMsg The custom error message to revert the transaction with.\\n    function revertBytes(bytes memory errMsg) internal pure {\\n        if (errMsg.length != 0) {\\n            assembly {\\n                revert(add(32, errMsg), mload(errMsg))\\n            }\\n        }\\n        revert EVC_EmptyError();\\n    }\\n}\\n\"},\"lib/euler-vault-kit/lib/ethereum-vault-connector/src/Events.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\n/// @title Events\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice This contract implements the events for the Ethereum Vault Connector.\\ncontract Events {\\n    /// @notice Emitted when an owner is registered for an address prefix.\\n    /// @param addressPrefix The address prefix for which the owner is registered.\\n    /// @param owner The address of the owner registered.\\n    event OwnerRegistered(bytes19 indexed addressPrefix, address indexed owner);\\n\\n    /// @notice Emitted when the lockdown mode status is changed for an address prefix.\\n    /// @param addressPrefix The address prefix for which the lockdown mode status is changed.\\n    /// @param enabled True if the lockdown mode is enabled, false otherwise.\\n    event LockdownModeStatus(bytes19 indexed addressPrefix, bool enabled);\\n\\n    /// @notice Emitted when the permit disabled mode status is changed for an address prefix.\\n    /// @param addressPrefix The address prefix for which the permit disabled mode status is changed.\\n    /// @param enabled True if the permit disabled mode is enabled, false otherwise.\\n    event PermitDisabledModeStatus(bytes19 indexed addressPrefix, bool enabled);\\n\\n    /// @notice Emitted when the nonce status is updated for a given address prefix and nonce namespace.\\n    /// @param addressPrefix The prefix of the address for which the nonce status is updated.\\n    /// @param nonceNamespace The namespace of the nonce being updated.\\n    /// @param oldNonce The previous nonce value before the update.\\n    /// @param newNonce The new nonce value after the update.\\n    event NonceStatus(\\n        bytes19 indexed addressPrefix, uint256 indexed nonceNamespace, uint256 oldNonce, uint256 newNonce\\n    );\\n\\n    /// @notice Emitted when a nonce is used for an address prefix and nonce namespace as part of permit execution.\\n    /// @param addressPrefix The address prefix for which the nonce is used.\\n    /// @param nonceNamespace The namespace of the nonce used.\\n    /// @param nonce The nonce that was used.\\n    event NonceUsed(bytes19 indexed addressPrefix, uint256 indexed nonceNamespace, uint256 nonce);\\n\\n    /// @notice Emitted when the operator status is changed for an address prefix.\\n    /// @param addressPrefix The address prefix for which the operator status is changed.\\n    /// @param operator The address of the operator.\\n    /// @param accountOperatorAuthorized The new authorization bitfield of the operator.\\n    event OperatorStatus(bytes19 indexed addressPrefix, address indexed operator, uint256 accountOperatorAuthorized);\\n\\n    /// @notice Emitted when the collateral status is changed for an account.\\n    /// @param account The account for which the collateral status is changed.\\n    /// @param collateral The address of the collateral.\\n    /// @param enabled True if the collateral is enabled, false otherwise.\\n    event CollateralStatus(address indexed account, address indexed collateral, bool enabled);\\n\\n    /// @notice Emitted when the controller status is changed for an account.\\n    /// @param account The account for which the controller status is changed.\\n    /// @param controller The address of the controller.\\n    /// @param enabled True if the controller is enabled, false otherwise.\\n    event ControllerStatus(address indexed account, address indexed controller, bool enabled);\\n\\n    /// @notice Emitted when an external call is made through the EVC.\\n    /// @param caller The address of the caller.\\n    /// @param onBehalfOfAddressPrefix The address prefix of the account on behalf of which the call is made.\\n    /// @param onBehalfOfAccount The account on behalf of which the call is made.\\n    /// @param targetContract The target contract of the call.\\n    /// @param selector The selector of the function called on the target contract.\\n    event CallWithContext(\\n        address indexed caller,\\n        bytes19 indexed onBehalfOfAddressPrefix,\\n        address onBehalfOfAccount,\\n        address indexed targetContract,\\n        bytes4 selector\\n    );\\n\\n    /// @notice Emitted when an account status check is performed.\\n    /// @param account The account for which the status check is performed.\\n    /// @param controller The controller performing the status check.\\n    event AccountStatusCheck(address indexed account, address indexed controller);\\n\\n    /// @notice Emitted when a vault status check is performed.\\n    /// @param vault The vault for which the status check is performed.\\n    event VaultStatusCheck(address indexed vault);\\n}\\n\"},\"lib/euler-vault-kit/lib/ethereum-vault-connector/src/ExecutionContext.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\ntype EC is uint256;\\n\\n/// @title ExecutionContext\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice This library provides functions for managing the execution context in the Ethereum Vault Connector.\\n/// @dev The execution context is a bit field that stores the following information:\\n/// @dev - on behalf of account - an account on behalf of which the currently executed operation is being performed\\n/// @dev - checks deferred flag - used to indicate whether checks are deferred\\n/// @dev - checks in progress flag - used to indicate that the account/vault status checks are in progress. This flag is\\n/// used to prevent re-entrancy.\\n/// @dev - control collateral in progress flag - used to indicate that the control collateral is in progress. This flag\\n/// is used to prevent re-entrancy.\\n/// @dev - operator authenticated flag - used to indicate that the currently executed operation is being performed by\\n/// the account operator\\n/// @dev - simulation flag - used to indicate that the currently executed batch call is a simulation\\n/// @dev - stamp - dummy value for optimization purposes\\nlibrary ExecutionContext {\\n    uint256 internal constant ON_BEHALF_OF_ACCOUNT_MASK =\\n        0x000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n    uint256 internal constant CHECKS_DEFERRED_MASK = 0x0000000000000000000000FF0000000000000000000000000000000000000000;\\n    uint256 internal constant CHECKS_IN_PROGRESS_MASK =\\n        0x00000000000000000000FF000000000000000000000000000000000000000000;\\n    uint256 internal constant CONTROL_COLLATERAL_IN_PROGRESS_LOCK_MASK =\\n        0x000000000000000000FF00000000000000000000000000000000000000000000;\\n    uint256 internal constant OPERATOR_AUTHENTICATED_MASK =\\n        0x0000000000000000FF0000000000000000000000000000000000000000000000;\\n    uint256 internal constant SIMULATION_MASK = 0x00000000000000FF000000000000000000000000000000000000000000000000;\\n    uint256 internal constant STAMP_OFFSET = 200;\\n\\n    // None of the functions below modifies the state. All the functions operate on the copy\\n    // of the execution context and return its modified value as a result. In order to update\\n    // one should use the result of the function call as a new execution context value.\\n\\n    function getOnBehalfOfAccount(EC self) internal pure returns (address result) {\\n        result = address(uint160(EC.unwrap(self) & ON_BEHALF_OF_ACCOUNT_MASK));\\n    }\\n\\n    function setOnBehalfOfAccount(EC self, address account) internal pure returns (EC result) {\\n        result = EC.wrap((EC.unwrap(self) & ~ON_BEHALF_OF_ACCOUNT_MASK) | uint160(account));\\n    }\\n\\n    function areChecksDeferred(EC self) internal pure returns (bool result) {\\n        result = EC.unwrap(self) & CHECKS_DEFERRED_MASK != 0;\\n    }\\n\\n    function setChecksDeferred(EC self) internal pure returns (EC result) {\\n        result = EC.wrap(EC.unwrap(self) | CHECKS_DEFERRED_MASK);\\n    }\\n\\n    function areChecksInProgress(EC self) internal pure returns (bool result) {\\n        result = EC.unwrap(self) & CHECKS_IN_PROGRESS_MASK != 0;\\n    }\\n\\n    function setChecksInProgress(EC self) internal pure returns (EC result) {\\n        result = EC.wrap(EC.unwrap(self) | CHECKS_IN_PROGRESS_MASK);\\n    }\\n\\n    function isControlCollateralInProgress(EC self) internal pure returns (bool result) {\\n        result = EC.unwrap(self) & CONTROL_COLLATERAL_IN_PROGRESS_LOCK_MASK != 0;\\n    }\\n\\n    function setControlCollateralInProgress(EC self) internal pure returns (EC result) {\\n        result = EC.wrap(EC.unwrap(self) | CONTROL_COLLATERAL_IN_PROGRESS_LOCK_MASK);\\n    }\\n\\n    function isOperatorAuthenticated(EC self) internal pure returns (bool result) {\\n        result = EC.unwrap(self) & OPERATOR_AUTHENTICATED_MASK != 0;\\n    }\\n\\n    function setOperatorAuthenticated(EC self) internal pure returns (EC result) {\\n        result = EC.wrap(EC.unwrap(self) | OPERATOR_AUTHENTICATED_MASK);\\n    }\\n\\n    function clearOperatorAuthenticated(EC self) internal pure returns (EC result) {\\n        result = EC.wrap(EC.unwrap(self) & ~OPERATOR_AUTHENTICATED_MASK);\\n    }\\n\\n    function isSimulationInProgress(EC self) internal pure returns (bool result) {\\n        result = EC.unwrap(self) & SIMULATION_MASK != 0;\\n    }\\n\\n    function setSimulationInProgress(EC self) internal pure returns (EC result) {\\n        result = EC.wrap(EC.unwrap(self) | SIMULATION_MASK);\\n    }\\n}\\n\"},\"lib/euler-vault-kit/lib/ethereum-vault-connector/src/Set.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\n/// @dev Represents the maximum number of elements that can be stored in the set.\\n/// Must not exceed 255 due to the uint8 data type limit.\\nuint8 constant SET_MAX_ELEMENTS = 10;\\n\\n/// @title ElementStorage\\n/// @notice This struct is used to store the value and stamp of an element.\\n/// @dev The stamp field is used to keep the storage slot non-zero when the element is removed.\\n/// @dev It allows for cheaper SSTORE when an element is inserted.\\nstruct ElementStorage {\\n    /// @notice The value of the element.\\n    address value;\\n    /// @notice The stamp of the element.\\n    uint96 stamp;\\n}\\n\\n/// @title SetStorage\\n/// @notice This struct is used to store the set data.\\n/// @dev To optimize the gas consumption, firstElement is stored in the same storage slot as the numElements\\n/// @dev so that for sets with one element, only one storage slot has to be read/written. To keep the elements\\n/// @dev array indexing consistent and because the first element is stored outside of the array, the elements[0]\\n/// @dev is not utilized. The stamp field is used to keep the storage slot non-zero when the element is removed.\\n/// @dev It allows for cheaper SSTORE when an element is inserted.\\nstruct SetStorage {\\n    /// @notice The number of elements in the set.\\n    uint8 numElements;\\n    /// @notice The first element in the set.\\n    address firstElement;\\n    /// @notice The metadata of the set.\\n    uint80 metadata;\\n    /// @notice The stamp of the set.\\n    uint8 stamp;\\n    /// @notice The array of elements in the set. Stores the elements starting from index 1.\\n    ElementStorage[SET_MAX_ELEMENTS] elements;\\n}\\n\\n/// @title Set\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice This library provides functions for managing sets of addresses.\\n/// @dev The maximum number of elements in the set is defined by the constant SET_MAX_ELEMENTS.\\nlibrary Set {\\n    error TooManyElements();\\n    error InvalidIndex();\\n\\n    uint8 internal constant EMPTY_ELEMENT_OFFSET = 1; // must be 1\\n    uint8 internal constant DUMMY_STAMP = 1;\\n\\n    /// @notice Initializes the set by setting the stamp field of the SetStorage and the stamp field of elements to\\n    /// DUMMY_STAMP.\\n    /// @dev The stamp field is used to keep the storage slot non-zero when the element is removed. It allows for\\n    /// cheaper SSTORE when an element is inserted.\\n    /// @param setStorage The set storage whose stamp fields will be initialized.\\n    function initialize(SetStorage storage setStorage) internal {\\n        setStorage.stamp = DUMMY_STAMP;\\n\\n        for (uint256 i = EMPTY_ELEMENT_OFFSET; i < SET_MAX_ELEMENTS; ++i) {\\n            setStorage.elements[i].stamp = DUMMY_STAMP;\\n        }\\n    }\\n\\n    /// @notice Inserts an element and returns information whether the element was inserted or not.\\n    /// @dev Reverts if the set is full but the element is not in the set storage.\\n    /// @param setStorage The set storage to which the element will be inserted.\\n    /// @param element The element to be inserted.\\n    /// @return A boolean value that indicates whether the element was inserted or not. If the element was already in\\n    /// the set storage, it returns false.\\n    function insert(SetStorage storage setStorage, address element) internal returns (bool) {\\n        address firstElement = setStorage.firstElement;\\n        uint256 numElements = setStorage.numElements;\\n        uint80 metadata = setStorage.metadata;\\n\\n        if (numElements == 0) {\\n            // gas optimization:\\n            // on the first element insertion, set the stamp to non-zero value to keep the storage slot non-zero when\\n            // the element is removed. when a new element is inserted after the removal, it should be cheaper\\n            setStorage.numElements = 1;\\n            setStorage.firstElement = element;\\n            setStorage.metadata = metadata;\\n            setStorage.stamp = DUMMY_STAMP;\\n            return true;\\n        }\\n\\n        if (firstElement == element) return false;\\n\\n        for (uint256 i = EMPTY_ELEMENT_OFFSET; i < numElements; ++i) {\\n            if (setStorage.elements[i].value == element) return false;\\n        }\\n\\n        if (numElements == SET_MAX_ELEMENTS) revert TooManyElements();\\n\\n        setStorage.elements[numElements].value = element;\\n\\n        unchecked {\\n            setStorage.numElements = uint8(numElements + 1);\\n        }\\n\\n        return true;\\n    }\\n\\n    /// @notice Removes an element and returns information whether the element was removed or not.\\n    /// @dev This operation may affect the order of elements in the array of elements obtained using get() function. This\\n    /// function does not modify the metadata of the set, even if it becomes empty as a result of invoking this\\n    /// function.\\n    /// @param setStorage The set storage from which the element will be removed.\\n    /// @param element The element to be removed.\\n    /// @return A boolean value that indicates whether the element was removed or not. If the element was not in the set\\n    /// storage, it returns false.\\n    function remove(SetStorage storage setStorage, address element) internal returns (bool) {\\n        address firstElement = setStorage.firstElement;\\n        uint256 numElements = setStorage.numElements;\\n        uint80 metadata = setStorage.metadata;\\n\\n        if (numElements == 0) return false;\\n\\n        uint256 searchIndex;\\n        if (firstElement != element) {\\n            for (searchIndex = EMPTY_ELEMENT_OFFSET; searchIndex < numElements; ++searchIndex) {\\n                if (setStorage.elements[searchIndex].value == element) break;\\n            }\\n\\n            if (searchIndex == numElements) return false;\\n        }\\n\\n        // write full slot at once to avoid SLOAD and bit masking\\n        if (numElements == 1) {\\n            setStorage.numElements = 0;\\n            setStorage.firstElement = address(0);\\n            setStorage.metadata = metadata;\\n            setStorage.stamp = DUMMY_STAMP;\\n            return true;\\n        }\\n\\n        uint256 lastIndex;\\n        unchecked {\\n            lastIndex = numElements - 1;\\n        }\\n\\n        // set numElements for every execution path to avoid SSTORE and bit masking when the element removed is\\n        // firstElement\\n        ElementStorage storage lastElement = setStorage.elements[lastIndex];\\n        if (searchIndex != lastIndex) {\\n            if (searchIndex == 0) {\\n                setStorage.firstElement = lastElement.value;\\n                setStorage.numElements = uint8(lastIndex);\\n                setStorage.metadata = metadata;\\n                setStorage.stamp = DUMMY_STAMP;\\n            } else {\\n                setStorage.elements[searchIndex].value = lastElement.value;\\n\\n                setStorage.firstElement = firstElement;\\n                setStorage.numElements = uint8(lastIndex);\\n                setStorage.metadata = metadata;\\n                setStorage.stamp = DUMMY_STAMP;\\n            }\\n        } else {\\n            setStorage.firstElement = firstElement;\\n            setStorage.numElements = uint8(lastIndex);\\n            setStorage.metadata = metadata;\\n            setStorage.stamp = DUMMY_STAMP;\\n        }\\n\\n        lastElement.value = address(0);\\n\\n        return true;\\n    }\\n\\n    /// @notice Swaps the position of two elements so that they appear switched in the array of elements obtained using\\n    /// get() function.\\n    /// @dev The first index must not be greater than or equal to the second index. Indices must not be out of bounds.\\n    /// The function will revert if the indices are invalid.\\n    /// @param setStorage The set storage for which the elements will be swapped.\\n    /// @param index1 The index of the first element to be swapped.\\n    /// @param index2 The index of the second element to be swapped.\\n    function reorder(SetStorage storage setStorage, uint8 index1, uint8 index2) internal {\\n        address firstElement = setStorage.firstElement;\\n        uint256 numElements = setStorage.numElements;\\n\\n        if (index1 >= index2 || index2 >= numElements) {\\n            revert InvalidIndex();\\n        }\\n\\n        if (index1 == 0) {\\n            (setStorage.firstElement, setStorage.elements[index2].value) =\\n                (setStorage.elements[index2].value, firstElement);\\n        } else {\\n            (setStorage.elements[index1].value, setStorage.elements[index2].value) =\\n                (setStorage.elements[index2].value, setStorage.elements[index1].value);\\n        }\\n    }\\n\\n    /// @notice Sets the metadata for the set storage.\\n    /// @param setStorage The storage structure where metadata will be set.\\n    /// @param metadata The metadata value to set.\\n    function setMetadata(SetStorage storage setStorage, uint80 metadata) internal {\\n        setStorage.metadata = metadata;\\n    }\\n\\n    /// @notice Returns an array of elements contained in the storage.\\n    /// @dev The order of the elements in the array may be affected by performing operations on the set.\\n    /// @param setStorage The set storage to be processed.\\n    /// @return An array that contains the same elements as the set storage.\\n    function get(SetStorage storage setStorage) internal view returns (address[] memory) {\\n        address firstElement = setStorage.firstElement;\\n        uint256 numElements = setStorage.numElements;\\n        address[] memory output = new address[](numElements);\\n\\n        if (numElements == 0) return output;\\n\\n        output[0] = firstElement;\\n\\n        for (uint256 i = EMPTY_ELEMENT_OFFSET; i < numElements; ++i) {\\n            output[i] = setStorage.elements[i].value;\\n        }\\n\\n        return output;\\n    }\\n\\n    /// @notice Retrieves the metadata from the set storage.\\n    /// @param setStorage The storage structure from which metadata is retrieved.\\n    /// @return The metadata value.\\n    function getMetadata(SetStorage storage setStorage) internal view returns (uint80) {\\n        return setStorage.metadata;\\n    }\\n\\n    /// @notice Checks if the set storage contains a given element and returns a boolean value that indicates the\\n    /// result.\\n    /// @param setStorage The set storage to be searched.\\n    /// @param element The element to be searched for.\\n    /// @return A boolean value that indicates whether the set storage includes the element or not.\\n    function contains(SetStorage storage setStorage, address element) internal view returns (bool) {\\n        address firstElement = setStorage.firstElement;\\n        uint256 numElements = setStorage.numElements;\\n\\n        if (numElements == 0) return false;\\n        if (firstElement == element) return true;\\n\\n        for (uint256 i = EMPTY_ELEMENT_OFFSET; i < numElements; ++i) {\\n            if (setStorage.elements[i].value == element) return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /// @notice Iterates over each element in the set and applies the callback function to it.\\n    /// @dev The set is cleared as a result of this call. Considering that this function does not follow the\\n    /// Checks-Effects-Interactions pattern, the function using it must prevent re-entrancy. This function does not\\n    /// modify the metadata of the set.\\n    /// @param setStorage The set storage to be processed.\\n    /// @param callback The function to be applied to each element.\\n    function forEachAndClear(SetStorage storage setStorage, function(address) callback) internal {\\n        uint256 numElements = setStorage.numElements;\\n        address firstElement = setStorage.firstElement;\\n        uint80 metadata = setStorage.metadata;\\n\\n        if (numElements == 0) return;\\n\\n        setStorage.numElements = 0;\\n        setStorage.firstElement = address(0);\\n        setStorage.metadata = metadata;\\n        setStorage.stamp = DUMMY_STAMP;\\n\\n        callback(firstElement);\\n\\n        for (uint256 i = EMPTY_ELEMENT_OFFSET; i < numElements; ++i) {\\n            address element = setStorage.elements[i].value;\\n            setStorage.elements[i] = ElementStorage({value: address(0), stamp: DUMMY_STAMP});\\n\\n            callback(element);\\n        }\\n    }\\n\\n    /// @notice Iterates over each element in the set and applies the callback function to it, returning the array of\\n    /// callback results.\\n    /// @dev The set is cleared as a result of this call. Considering that this function does not follow the\\n    /// Checks-Effects-Interactions pattern, the function using it must prevent re-entrancy. This function does not\\n    /// modify the metadata of the set.\\n    /// @param setStorage The set storage to be processed.\\n    /// @param callback The function to be applied to each element.\\n    /// @return result An array of encoded bytes that are the addresses passed to the callback function and results of\\n    /// calling it.\\n    function forEachAndClearWithResult(\\n        SetStorage storage setStorage,\\n        function(address) returns (bool, bytes memory) callback\\n    ) internal returns (bytes[] memory) {\\n        uint256 numElements = setStorage.numElements;\\n        address firstElement = setStorage.firstElement;\\n        uint80 metadata = setStorage.metadata;\\n        bytes[] memory results = new bytes[](numElements);\\n\\n        if (numElements == 0) return results;\\n\\n        setStorage.numElements = 0;\\n        setStorage.firstElement = address(0);\\n        setStorage.metadata = metadata;\\n        setStorage.stamp = DUMMY_STAMP;\\n\\n        (bool success, bytes memory result) = callback(firstElement);\\n        results[0] = abi.encode(firstElement, success, result);\\n\\n        for (uint256 i = EMPTY_ELEMENT_OFFSET; i < numElements; ++i) {\\n            address element = setStorage.elements[i].value;\\n            setStorage.elements[i] = ElementStorage({value: address(0), stamp: DUMMY_STAMP});\\n\\n            (success, result) = callback(element);\\n            results[i] = abi.encode(element, success, result);\\n        }\\n\\n        return results;\\n    }\\n}\\n\"},\"lib/euler-vault-kit/lib/ethereum-vault-connector/src/TransientStorage.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport {ExecutionContext, EC} from \\\"./ExecutionContext.sol\\\";\\nimport {Set, SetStorage} from \\\"./Set.sol\\\";\\n\\n/// @title TransientStorage\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice This contract provides transient storage for the Ethereum Vault Connector.\\n/// @dev All the variables in this contract are considered transient meaning that their state does not change between\\n/// invocations.\\nabstract contract TransientStorage {\\n    using ExecutionContext for EC;\\n    using Set for SetStorage;\\n\\n    enum SetType {\\n        Account,\\n        Vault\\n    }\\n\\n    EC internal executionContext;\\n    SetStorage internal accountStatusChecks;\\n    SetStorage internal vaultStatusChecks;\\n\\n    constructor() {\\n        // set the execution context to non-zero value to always keep the storage slot in non-zero state.\\n        // it allows for cheaper SSTOREs when the execution context is in its default state\\n        executionContext = EC.wrap(1 << ExecutionContext.STAMP_OFFSET);\\n\\n        // there are two types of data that are stored using SetStorage type:\\n        // - the data that is transient in nature (accountStatusChecks and vaultStatusChecks)\\n        // - the data that is permanent (accountControllers and accountCollaterals from the EthereumVaultConnector\\n        // contract)\\n\\n        // for the permanent data, there's no need to care that much about optimizations. each account has its two sets.\\n        // usually, an address inserted to either of them won't be removed within the same transaction. the only\\n        // optimization applied (directly in the Set contract) is that on the first element insertion, the stamp is set\\n        // to non-zero value to always keep that storage slot in non-zero state. it allows for cheaper SSTORE when an\\n        // element is inserted again after clearing the set.\\n\\n        // for the transient data, an address insertion should be as cheap as possible. hence on construction, we store\\n        // dummy values for all the storage slots where the elements will be stored later on. it is important\\n        // considering that both accountStatusChecks and vaultStatusChecks are always cleared at the end of the\\n        // transaction. with dummy values set, the transition from zero to non-zero and back to zero will be\\n        // significantly cheaper than it would be otherwise\\n        accountStatusChecks.initialize();\\n        vaultStatusChecks.initialize();\\n    }\\n}\\n\"},\"lib/euler-vault-kit/lib/ethereum-vault-connector/src/interfaces/IERC1271.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\\n\\npragma solidity >=0.8.0;\\n\\n/// @dev Interface of the ERC1271 standard signature validation method for\\n/// contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\ninterface IERC1271 {\\n    /// @dev Should return whether the signature provided is valid for the provided data\\n    /// @param hash Hash of the data to be signed\\n    /// @param signature Signature byte array associated with _data\\n    /// @return magicValue Must return the bytes4 magic value 0x1626ba7e (which is a selector of this function) when\\n    /// the signature is valid.\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\"},\"lib/euler-vault-kit/lib/ethereum-vault-connector/src/interfaces/IEthereumVaultConnector.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.8.0;\\n\\n/// @title IEVC\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice This interface defines the methods for the Ethereum Vault Connector.\\ninterface IEVC {\\n    /// @notice A struct representing a batch item.\\n    /// @dev Each batch item represents a single operation to be performed within a checks deferred context.\\n    struct BatchItem {\\n        /// @notice The target contract to be called.\\n        address targetContract;\\n        /// @notice The account on behalf of which the operation is to be performed. msg.sender must be authorized to\\n        /// act on behalf of this account. Must be address(0) if the target contract is the EVC itself.\\n        address onBehalfOfAccount;\\n        /// @notice The amount of value to be forwarded with the call. If the value is type(uint256).max, the whole\\n        /// balance of the EVC contract will be forwarded. Must be 0 if the target contract is the EVC itself.\\n        uint256 value;\\n        /// @notice The encoded data which is called on the target contract.\\n        bytes data;\\n    }\\n\\n    /// @notice A struct representing the result of a batch item operation.\\n    /// @dev Used only for simulation purposes.\\n    struct BatchItemResult {\\n        /// @notice A boolean indicating whether the operation was successful.\\n        bool success;\\n        /// @notice The result of the operation.\\n        bytes result;\\n    }\\n\\n    /// @notice A struct representing the result of the account or vault status check.\\n    /// @dev Used only for simulation purposes.\\n    struct StatusCheckResult {\\n        /// @notice The address of the account or vault for which the check was performed.\\n        address checkedAddress;\\n        /// @notice A boolean indicating whether the status of the account or vault is valid.\\n        bool isValid;\\n        /// @notice The result of the check.\\n        bytes result;\\n    }\\n\\n    /// @notice Returns current raw execution context.\\n    /// @dev When checks in progress, on behalf of account is always address(0).\\n    /// @return context Current raw execution context.\\n    function getRawExecutionContext() external view returns (uint256 context);\\n\\n    /// @notice Returns an account on behalf of which the operation is being executed at the moment and whether the\\n    /// controllerToCheck is an enabled controller for that account.\\n    /// @dev This function should only be used by external smart contracts if msg.sender is the EVC. Otherwise, the\\n    /// account address returned must not be trusted.\\n    /// @dev When checks in progress, on behalf of account is always address(0). When address is zero, the function\\n    /// reverts to protect the consumer from ever relying on the on behalf of account address which is in its default\\n    /// state.\\n    /// @param controllerToCheck The address of the controller for which it is checked whether it is an enabled\\n    /// controller for the account on behalf of which the operation is being executed at the moment.\\n    /// @return onBehalfOfAccount An account that has been authenticated and on behalf of which the operation is being\\n    /// executed at the moment.\\n    /// @return controllerEnabled A boolean value that indicates whether controllerToCheck is an enabled controller for\\n    /// the account on behalf of which the operation is being executed at the moment. Always false if controllerToCheck\\n    /// is address(0).\\n    function getCurrentOnBehalfOfAccount(address controllerToCheck)\\n        external\\n        view\\n        returns (address onBehalfOfAccount, bool controllerEnabled);\\n\\n    /// @notice Checks if checks are deferred.\\n    /// @return A boolean indicating whether checks are deferred.\\n    function areChecksDeferred() external view returns (bool);\\n\\n    /// @notice Checks if checks are in progress.\\n    /// @return A boolean indicating whether checks are in progress.\\n    function areChecksInProgress() external view returns (bool);\\n\\n    /// @notice Checks if control collateral is in progress.\\n    /// @return A boolean indicating whether control collateral is in progress.\\n    function isControlCollateralInProgress() external view returns (bool);\\n\\n    /// @notice Checks if an operator is authenticated.\\n    /// @return A boolean indicating whether an operator is authenticated.\\n    function isOperatorAuthenticated() external view returns (bool);\\n\\n    /// @notice Checks if a simulation is in progress.\\n    /// @return A boolean indicating whether a simulation is in progress.\\n    function isSimulationInProgress() external view returns (bool);\\n\\n    /// @notice Checks whether the specified account and the other account have the same owner.\\n    /// @dev The function is used to check whether one account is authorized to perform operations on behalf of the\\n    /// other. Accounts are considered to have a common owner if they share the first 19 bytes of their address.\\n    /// @param account The address of the account that is being checked.\\n    /// @param otherAccount The address of the other account that is being checked.\\n    /// @return A boolean flag that indicates whether the accounts have the same owner.\\n    function haveCommonOwner(address account, address otherAccount) external pure returns (bool);\\n\\n    /// @notice Returns the address prefix of the specified account.\\n    /// @dev The address prefix is the first 19 bytes of the account address.\\n    /// @param account The address of the account whose address prefix is being retrieved.\\n    /// @return A bytes19 value that represents the address prefix of the account.\\n    function getAddressPrefix(address account) external pure returns (bytes19);\\n\\n    /// @notice Returns the owner for the specified account.\\n    /// @dev The function returns address(0) if the owner is not registered. Registration of the owner happens on the\\n    /// initial\\n    /// interaction with the EVC that requires authentication of an owner.\\n    /// @param account The address of the account whose owner is being retrieved.\\n    /// @return owner The address of the account owner. An account owner is an EOA/smart contract which address matches\\n    /// the first 19 bytes of the account address.\\n    function getAccountOwner(address account) external view returns (address);\\n\\n    /// @notice Checks if lockdown mode is enabled for a given address prefix.\\n    /// @param addressPrefix The address prefix to check for lockdown mode status.\\n    /// @return A boolean indicating whether lockdown mode is enabled.\\n    function isLockdownMode(bytes19 addressPrefix) external view returns (bool);\\n\\n    /// @notice Checks if permit functionality is disabled for a given address prefix.\\n    /// @param addressPrefix The address prefix to check for permit functionality status.\\n    /// @return A boolean indicating whether permit functionality is disabled.\\n    function isPermitDisabledMode(bytes19 addressPrefix) external view returns (bool);\\n\\n    /// @notice Returns the current nonce for a given address prefix and nonce namespace.\\n    /// @dev Each nonce namespace provides 256 bit nonce that has to be used sequentially. There's no requirement to use\\n    /// all the nonces for a given nonce namespace before moving to the next one which allows to use permit messages in\\n    /// a non-sequential manner.\\n    /// @param addressPrefix The address prefix for which the nonce is being retrieved.\\n    /// @param nonceNamespace The nonce namespace for which the nonce is being retrieved.\\n    /// @return nonce The current nonce for the given address prefix and nonce namespace.\\n    function getNonce(bytes19 addressPrefix, uint256 nonceNamespace) external view returns (uint256 nonce);\\n\\n    /// @notice Returns the bit field for a given address prefix and operator.\\n    /// @dev The bit field is used to store information about authorized operators for a given address prefix. Each bit\\n    /// in the bit field corresponds to one account belonging to the same owner. If the bit is set, the operator is\\n    /// authorized for the account.\\n    /// @param addressPrefix The address prefix for which the bit field is being retrieved.\\n    /// @param operator The address of the operator for which the bit field is being retrieved.\\n    /// @return operatorBitField The bit field for the given address prefix and operator. The bit field defines which\\n    /// accounts the operator is authorized for. It is a 256-position binary array like 0...010...0, marking the account\\n    /// positionally in a uint256. The position in the bit field corresponds to the account ID (0-255), where 0 is the\\n    /// owner account's ID.\\n    function getOperator(bytes19 addressPrefix, address operator) external view returns (uint256 operatorBitField);\\n\\n    /// @notice Returns whether a given operator has been authorized for a given account.\\n    /// @param account The address of the account whose operator is being checked.\\n    /// @param operator The address of the operator that is being checked.\\n    /// @return authorized A boolean value that indicates whether the operator is authorized for the account.\\n    function isAccountOperatorAuthorized(address account, address operator) external view returns (bool authorized);\\n\\n    /// @notice Enables or disables lockdown mode for a given address prefix.\\n    /// @dev This function can only be called by the owner of the address prefix. To disable this mode, the EVC\\n    /// must be called directly. It is not possible to disable this mode by using checks-deferrable call or\\n    /// permit message.\\n    /// @param addressPrefix The address prefix for which the lockdown mode is being set.\\n    /// @param enabled A boolean indicating whether to enable or disable lockdown mode.\\n    function setLockdownMode(bytes19 addressPrefix, bool enabled) external payable;\\n\\n    /// @notice Enables or disables permit functionality for a given address prefix.\\n    /// @dev This function can only be called by the owner of the address prefix. To disable this mode, the EVC\\n    /// must be called directly. It is not possible to disable this mode by using checks-deferrable call or (by\\n    /// definition) permit message. To support permit functionality by default, note that the logic was inverted here. To\\n    /// disable  the permit functionality, one must pass true as the second argument. To enable the permit\\n    /// functionality, one must pass false as the second argument.\\n    /// @param addressPrefix The address prefix for which the permit functionality is being set.\\n    /// @param enabled A boolean indicating whether to enable or disable the disable-permit mode.\\n    function setPermitDisabledMode(bytes19 addressPrefix, bool enabled) external payable;\\n\\n    /// @notice Sets the nonce for a given address prefix and nonce namespace.\\n    /// @dev This function can only be called by the owner of the address prefix. Each nonce namespace provides a 256\\n    /// bit nonce that has to be used sequentially. There's no requirement to use all the nonces for a given nonce\\n    /// namespace before moving to the next one which allows the use of permit messages in a non-sequential manner. To\\n    /// invalidate signed permit messages, set the nonce for a given nonce namespace accordingly. To invalidate all the\\n    /// permit messages for a given nonce namespace, set the nonce to type(uint).max.\\n    /// @param addressPrefix The address prefix for which the nonce is being set.\\n    /// @param nonceNamespace The nonce namespace for which the nonce is being set.\\n    /// @param nonce The new nonce for the given address prefix and nonce namespace.\\n    function setNonce(bytes19 addressPrefix, uint256 nonceNamespace, uint256 nonce) external payable;\\n\\n    /// @notice Sets the bit field for a given address prefix and operator.\\n    /// @dev This function can only be called by the owner of the address prefix. Each bit in the bit field corresponds\\n    /// to one account belonging to the same owner. If the bit is set, the operator is authorized for the account.\\n    /// @param addressPrefix The address prefix for which the bit field is being set.\\n    /// @param operator The address of the operator for which the bit field is being set. Can neither be the EVC address\\n    /// nor an address belonging to the same address prefix.\\n    /// @param operatorBitField The new bit field for the given address prefix and operator. Reverts if the provided\\n    /// value is equal to the currently stored value.\\n    function setOperator(bytes19 addressPrefix, address operator, uint256 operatorBitField) external payable;\\n\\n    /// @notice Authorizes or deauthorizes an operator for the account.\\n    /// @dev Only the owner or authorized operator of the account can call this function. An operator is an address that\\n    /// can perform actions for an account on behalf of the owner. If it's an operator calling this function, it can\\n    /// only deauthorize itself.\\n    /// @param account The address of the account whose operator is being set or unset.\\n    /// @param operator The address of the operator that is being installed or uninstalled. Can neither be the EVC\\n    /// address nor an address belonging to the same owner as the account.\\n    /// @param authorized A boolean value that indicates whether the operator is being authorized or deauthorized.\\n    /// Reverts if the provided value is equal to the currently stored value.\\n    function setAccountOperator(address account, address operator, bool authorized) external payable;\\n\\n    /// @notice Returns an array of collaterals enabled for an account.\\n    /// @dev A collateral is a vault for which an account's balances are under the control of the currently enabled\\n    /// controller vault.\\n    /// @param account The address of the account whose collaterals are being queried.\\n    /// @return An array of addresses that are enabled collaterals for the account.\\n    function getCollaterals(address account) external view returns (address[] memory);\\n\\n    /// @notice Returns whether a collateral is enabled for an account.\\n    /// @dev A collateral is a vault for which account's balances are under the control of the currently enabled\\n    /// controller vault.\\n    /// @param account The address of the account that is being checked.\\n    /// @param vault The address of the collateral that is being checked.\\n    /// @return A boolean value that indicates whether the vault is an enabled collateral for the account or not.\\n    function isCollateralEnabled(address account, address vault) external view returns (bool);\\n\\n    /// @notice Enables a collateral for an account.\\n    /// @dev A collaterals is a vault for which account's balances are under the control of the currently enabled\\n    /// controller vault. Only the owner or an operator of the account can call this function. Unless it's a duplicate,\\n    /// the collateral is added to the end of the array. There can be at most 10 unique collaterals enabled at a time.\\n    /// Account status checks are performed.\\n    /// @param account The account address for which the collateral is being enabled.\\n    /// @param vault The address being enabled as a collateral.\\n    function enableCollateral(address account, address vault) external payable;\\n\\n    /// @notice Disables a collateral for an account.\\n    /// @dev This function does not preserve the order of collaterals in the array obtained using the getCollaterals\\n    /// function; the order may change. A collateral is a vault for which accounts balances are under the control of\\n    /// the currently enabled controller vault. Only the owner or an operator of the account can call this function.\\n    /// Disabling a collateral might change the order of collaterals in the array obtained using getCollaterals\\n    /// function. Account status checks are performed.\\n    /// @param account The account address for which the collateral is being disabled.\\n    /// @param vault The address of a collateral being disabled.\\n    function disableCollateral(address account, address vault) external payable;\\n\\n    /// @notice Swaps the position of two collaterals so that they appear switched in the array of collaterals for a\\n    /// given account obtained by calling getCollaterals function.\\n    /// @dev A collateral is a vault for which accounts balances are under the control of the currently enabled\\n    /// controller vault. Only the owner or an operator of the account can call this function. The order of collaterals\\n    /// can be changed by specifying the indices of the two collaterals to be swapped. Indices are zero-based and must\\n    /// be in the range of 0 to the number of collaterals minus 1. index1 must be lower than index2. Account status\\n    /// checks are performed.\\n    /// @param account The address of the account for which the collaterals are being reordered.\\n    /// @param index1 The index of the first collateral to be swapped.\\n    /// @param index2 The index of the second collateral to be swapped.\\n    function reorderCollaterals(address account, uint8 index1, uint8 index2) external payable;\\n\\n    /// @notice Returns an array of enabled controllers for an account.\\n    /// @dev A controller is a vault that has been chosen for an account to have special control over the account's\\n    /// balances in enabled collaterals vaults. A user can have multiple controllers during a call execution, but at\\n    /// most one can be selected when the account status check is performed.\\n    /// @param account The address of the account whose controllers are being queried.\\n    /// @return An array of addresses that are the enabled controllers for the account.\\n    function getControllers(address account) external view returns (address[] memory);\\n\\n    /// @notice Returns whether a controller is enabled for an account.\\n    /// @dev A controller is a vault that has been chosen for an account to have special control over accounts\\n    /// balances in the enabled collaterals vaults.\\n    /// @param account The address of the account that is being checked.\\n    /// @param vault The address of the controller that is being checked.\\n    /// @return A boolean value that indicates whether the vault is enabled controller for the account or not.\\n    function isControllerEnabled(address account, address vault) external view returns (bool);\\n\\n    /// @notice Enables a controller for an account.\\n    /// @dev A controller is a vault that has been chosen for an account to have special control over accounts\\n    /// balances in the enabled collaterals vaults. Only the owner or an operator of the account can call this function.\\n    /// Unless it's a duplicate, the controller is added to the end of the array. Transiently, there can be at most 10\\n    /// unique controllers enabled at a time, but at most one can be enabled after the outermost checks-deferrable\\n    /// call concludes. Account status checks are performed.\\n    /// @param account The address for which the controller is being enabled.\\n    /// @param vault The address of the controller being enabled.\\n    function enableController(address account, address vault) external payable;\\n\\n    /// @notice Disables a controller for an account.\\n    /// @dev A controller is a vault that has been chosen for an account to have special control over accounts\\n    /// balances in the enabled collaterals vaults. Only the vault itself can call this function. Disabling a controller\\n    /// might change the order of controllers in the array obtained using getControllers function. Account status checks\\n    /// are performed.\\n    /// @param account The address for which the calling controller is being disabled.\\n    function disableController(address account) external payable;\\n\\n    /// @notice Executes signed arbitrary data by self-calling into the EVC.\\n    /// @dev Low-level call function is used to execute the arbitrary data signed by the owner or the operator on the\\n    /// EVC contract. During that call, EVC becomes msg.sender.\\n    /// @param signer The address signing the permit message (ECDSA) or verifying the permit message signature\\n    /// (ERC-1271). It's also the owner or the operator of all the accounts for which authentication will be needed\\n    /// during the execution of the arbitrary data call.\\n    /// @param sender The address of the msg.sender which is expected to execute the data signed by the signer. If\\n    /// address(0) is passed, the msg.sender is ignored.\\n    /// @param nonceNamespace The nonce namespace for which the nonce is being used.\\n    /// @param nonce The nonce for the given account and nonce namespace. A valid nonce value is considered to be the\\n    /// value currently stored and can take any value between 0 and type(uint256).max - 1.\\n    /// @param deadline The timestamp after which the permit is considered expired.\\n    /// @param value The amount of value to be forwarded with the call. If the value is type(uint256).max, the whole\\n    /// balance of the EVC contract will be forwarded.\\n    /// @param data The encoded data which is self-called on the EVC contract.\\n    /// @param signature The signature of the data signed by the signer.\\n    function permit(\\n        address signer,\\n        address sender,\\n        uint256 nonceNamespace,\\n        uint256 nonce,\\n        uint256 deadline,\\n        uint256 value,\\n        bytes calldata data,\\n        bytes calldata signature\\n    ) external payable;\\n\\n    /// @notice Calls into a target contract as per data encoded.\\n    /// @dev This function defers the account and vault status checks (it's a checks-deferrable call). If the outermost\\n    /// call ends, the account and vault status checks are performed.\\n    /// @dev This function can be used to interact with any contract while checks are deferred. If the target contract\\n    /// is msg.sender, msg.sender is called back with the calldata provided and the context set up according to the\\n    /// account provided. If the target contract is not msg.sender, only the owner or the operator of the account\\n    /// provided can call this function.\\n    /// @dev This function can be used to recover the remaining value from the EVC contract.\\n    /// @param targetContract The address of the contract to be called.\\n    /// @param onBehalfOfAccount  If the target contract is msg.sender, the address of the account which will be set\\n    /// in the context. It assumes msg.sender has authenticated the account themselves. If the target contract is\\n    /// not msg.sender, the address of the account for which it is checked whether msg.sender is authorized to act\\n    /// on behalf of.\\n    /// @param value The amount of value to be forwarded with the call. If the value is type(uint256).max, the whole\\n    /// balance of the EVC contract will be forwarded.\\n    /// @param data The encoded data which is called on the target contract.\\n    /// @return result The result of the call.\\n    function call(\\n        address targetContract,\\n        address onBehalfOfAccount,\\n        uint256 value,\\n        bytes calldata data\\n    ) external payable returns (bytes memory result);\\n\\n    /// @notice For a given account, calls into one of the enabled collateral vaults from the currently enabled\\n    /// controller vault as per data encoded.\\n    /// @dev This function defers the account and vault status checks (it's a checks-deferrable call). If the outermost\\n    /// call ends, the account and vault status checks are performed.\\n    /// @dev This function can be used to interact with any contract while checks are deferred as long as the contract\\n    /// is enabled as a collateral of the account and the msg.sender is the only enabled controller of the account.\\n    /// @param targetCollateral The collateral address to be called.\\n    /// @param onBehalfOfAccount The address of the account for which it is checked whether msg.sender is authorized to\\n    /// act on behalf.\\n    /// @param value The amount of value to be forwarded with the call. If the value is type(uint256).max, the whole\\n    /// balance of the EVC contract will be forwarded.\\n    /// @param data The encoded data which is called on the target collateral.\\n    /// @return result The result of the call.\\n    function controlCollateral(\\n        address targetCollateral,\\n        address onBehalfOfAccount,\\n        uint256 value,\\n        bytes calldata data\\n    ) external payable returns (bytes memory result);\\n\\n    /// @notice Executes multiple calls into the target contracts while checks deferred as per batch items provided.\\n    /// @dev This function defers the account and vault status checks (it's a checks-deferrable call). If the outermost\\n    /// call ends, the account and vault status checks are performed.\\n    /// @dev The authentication rules for each batch item are the same as for the call function.\\n    /// @param items An array of batch items to be executed.\\n    function batch(BatchItem[] calldata items) external payable;\\n\\n    /// @notice Executes multiple calls into the target contracts while checks deferred as per batch items provided.\\n    /// @dev This function always reverts as it's only used for simulation purposes. This function cannot be called\\n    /// within a checks-deferrable call.\\n    /// @param items An array of batch items to be executed.\\n    function batchRevert(BatchItem[] calldata items) external payable;\\n\\n    /// @notice Executes multiple calls into the target contracts while checks deferred as per batch items provided.\\n    /// @dev This function does not modify state and should only be used for simulation purposes. This function cannot\\n    /// be called within a checks-deferrable call.\\n    /// @param items An array of batch items to be executed.\\n    /// @return batchItemsResult An array of batch item results for each item.\\n    /// @return accountsStatusCheckResult An array of account status check results for each account.\\n    /// @return vaultsStatusCheckResult An array of vault status check results for each vault.\\n    function batchSimulation(BatchItem[] calldata items)\\n        external\\n        payable\\n        returns (\\n            BatchItemResult[] memory batchItemsResult,\\n            StatusCheckResult[] memory accountsStatusCheckResult,\\n            StatusCheckResult[] memory vaultsStatusCheckResult\\n        );\\n\\n    /// @notice Retrieves the timestamp of the last successful account status check performed for a specific account.\\n    /// @dev This function reverts if the checks are in progress.\\n    /// @dev The account status check is considered to be successful if it calls into the selected controller vault and\\n    /// obtains expected magic value. This timestamp does not change if the account status is considered valid when no\\n    /// controller enabled. When consuming, one might need to ensure that the account status check is not deferred at\\n    /// the moment.\\n    /// @param account The address of the account for which the last status check timestamp is being queried.\\n    /// @return The timestamp of the last status check as a uint256.\\n    function getLastAccountStatusCheckTimestamp(address account) external view returns (uint256);\\n\\n    /// @notice Checks whether the status check is deferred for a given account.\\n    /// @dev This function reverts if the checks are in progress.\\n    /// @param account The address of the account for which it is checked whether the status check is deferred.\\n    /// @return A boolean flag that indicates whether the status check is deferred or not.\\n    function isAccountStatusCheckDeferred(address account) external view returns (bool);\\n\\n    /// @notice Checks the status of an account and reverts if it is not valid.\\n    /// @dev If checks deferred, the account is added to the set of accounts to be checked at the end of the outermost\\n    /// checks-deferrable call. There can be at most 10 unique accounts added to the set at a time. Account status\\n    /// check is performed by calling into the selected controller vault and passing the array of currently enabled\\n    /// collaterals. If controller is not selected, the account is always considered valid.\\n    /// @param account The address of the account to be checked.\\n    function requireAccountStatusCheck(address account) external payable;\\n\\n    /// @notice Forgives previously deferred account status check.\\n    /// @dev Account address is removed from the set of addresses for which status checks are deferred. This function\\n    /// can only be called by the currently enabled controller of a given account. Depending on the vault\\n    /// implementation, may be needed in the liquidation flow.\\n    /// @param account The address of the account for which the status check is forgiven.\\n    function forgiveAccountStatusCheck(address account) external payable;\\n\\n    /// @notice Checks whether the status check is deferred for a given vault.\\n    /// @dev This function reverts if the checks are in progress.\\n    /// @param vault The address of the vault for which it is checked whether the status check is deferred.\\n    /// @return A boolean flag that indicates whether the status check is deferred or not.\\n    function isVaultStatusCheckDeferred(address vault) external view returns (bool);\\n\\n    /// @notice Checks the status of a vault and reverts if it is not valid.\\n    /// @dev If checks deferred, the vault is added to the set of vaults to be checked at the end of the outermost\\n    /// checks-deferrable call. There can be at most 10 unique vaults added to the set at a time. This function can\\n    /// only be called by the vault itself.\\n    function requireVaultStatusCheck() external payable;\\n\\n    /// @notice Forgives previously deferred vault status check.\\n    /// @dev Vault address is removed from the set of addresses for which status checks are deferred. This function can\\n    /// only be called by the vault itself.\\n    function forgiveVaultStatusCheck() external payable;\\n\\n    /// @notice Checks the status of an account and a vault and reverts if it is not valid.\\n    /// @dev If checks deferred, the account and the vault are added to the respective sets of accounts and vaults to be\\n    /// checked at the end of the outermost checks-deferrable call. Account status check is performed by calling into\\n    /// selected controller vault and passing the array of currently enabled collaterals. If controller is not selected,\\n    /// the account is always considered valid. This function can only be called by the vault itself.\\n    /// @param account The address of the account to be checked.\\n    function requireAccountAndVaultStatusCheck(address account) external payable;\\n}\\n\"},\"lib/euler-vault-kit/lib/ethereum-vault-connector/src/interfaces/IVault.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.8.0;\\n\\n/// @title IVault\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice This interface defines the methods for the Vault for the purpose of integration with the Ethereum Vault\\n/// Connector.\\ninterface IVault {\\n    /// @notice Disables a controller (this vault) for the authenticated account.\\n    /// @dev A controller is a vault that has been chosen for an account to have special control over accounts\\n    /// balances in the enabled collaterals vaults. User calls this function in order for the vault to disable itself\\n    /// for the account if the conditions are met (i.e. user has repaid debt in full). If the conditions are not met,\\n    /// the function reverts.\\n    function disableController() external;\\n\\n    /// @notice Checks the status of an account.\\n    /// @dev This function must only deliberately revert if the account status is invalid. If this function reverts due\\n    /// to any other reason, it may render the account unusable with possibly no way to recover funds.\\n    /// @param account The address of the account to be checked.\\n    /// @param collaterals The array of enabled collateral addresses to be considered for the account status check.\\n    /// @return magicValue Must return the bytes4 magic value 0xb168c58f (which is a selector of this function) when\\n    /// account status is valid, or revert otherwise.\\n    function checkAccountStatus(\\n        address account,\\n        address[] calldata collaterals\\n    ) external view returns (bytes4 magicValue);\\n\\n    /// @notice Checks the status of the vault.\\n    /// @dev This function must only deliberately revert if the vault status is invalid. If this function reverts due to\\n    /// any other reason, it may render some accounts unusable with possibly no way to recover funds.\\n    /// @return magicValue Must return the bytes4 magic value 0x4b3d1223 (which is a selector of this function) when\\n    /// account status is valid, or revert otherwise.\\n    function checkVaultStatus() external returns (bytes4 magicValue);\\n}\\n\"},\"lib/euler-vault-kit/src/EVault/IEVault.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.8.0;\\n\\nimport {IVault as IEVCVault} from \\\"ethereum-vault-connector/interfaces/IVault.sol\\\";\\n\\n// Full interface of EVault and all it's modules\\n\\n/// @title IInitialize\\n/// @notice Interface of the initialization module of EVault\\ninterface IInitialize {\\n    /// @notice Initialization of the newly deployed proxy contract\\n    /// @param proxyCreator Account which created the proxy or should be the initial governor\\n    function initialize(address proxyCreator) external;\\n}\\n\\n/// @title IERC20\\n/// @notice Interface of the EVault's Initialize module\\ninterface IERC20 {\\n    /// @notice Vault share token (eToken) name, ie \\\"Euler Vault: DAI\\\"\\n    /// @return The name of the eToken\\n    function name() external view returns (string memory);\\n\\n    /// @notice Vault share token (eToken) symbol, ie \\\"eDAI\\\"\\n    /// @return The symbol of the eToken\\n    function symbol() external view returns (string memory);\\n\\n    /// @notice Decimals, the same as the asset's or 18 if the asset doesn't implement `decimals()`\\n    /// @return The decimals of the eToken\\n    function decimals() external view returns (uint8);\\n\\n    /// @notice Sum of all eToken balances\\n    /// @return The total supply of the eToken\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Balance of a particular account, in eTokens\\n    /// @param account Address to query\\n    /// @return The balance of the account\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /// @notice Retrieve the current allowance\\n    /// @param holder The account holding the eTokens\\n    /// @param spender Trusted address\\n    /// @return The allowance from holder for spender\\n    function allowance(address holder, address spender) external view returns (uint256);\\n\\n    /// @notice Transfer eTokens to another address\\n    /// @param to Recipient account\\n    /// @param amount In shares.\\n    /// @return True if transfer succeeded\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /// @notice Transfer eTokens from one address to another\\n    /// @param from This address must've approved the to address\\n    /// @param to Recipient account\\n    /// @param amount In shares\\n    /// @return True if transfer succeeded\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n\\n    /// @notice Allow spender to access an amount of your eTokens\\n    /// @param spender Trusted address\\n    /// @param amount Use max uint for \\\"infinite\\\" allowance\\n    /// @return True if approval succeeded\\n    function approve(address spender, uint256 amount) external returns (bool);\\n}\\n\\n/// @title IToken\\n/// @notice Interface of the EVault's Token module\\ninterface IToken is IERC20 {\\n    /// @notice Transfer the full eToken balance of an address to another\\n    /// @param from This address must've approved the to address\\n    /// @param to Recipient account\\n    /// @return True if transfer succeeded\\n    function transferFromMax(address from, address to) external returns (bool);\\n}\\n\\n/// @title IERC4626\\n/// @notice Interface of an ERC4626 vault\\ninterface IERC4626 {\\n    /// @notice Vault's underlying asset\\n    /// @return The vault's underlying asset\\n    function asset() external view returns (address);\\n\\n    /// @notice Total amount of managed assets, cash and borrows\\n    /// @return The total amount of assets\\n    function totalAssets() external view returns (uint256);\\n\\n    /// @notice Calculate amount of assets corresponding to the requested shares amount\\n    /// @param shares Amount of shares to convert\\n    /// @return The amount of assets\\n    function convertToAssets(uint256 shares) external view returns (uint256);\\n\\n    /// @notice Calculate amount of shares corresponding to the requested assets amount\\n    /// @param assets Amount of assets to convert\\n    /// @return The amount of shares\\n    function convertToShares(uint256 assets) external view returns (uint256);\\n\\n    /// @notice Fetch the maximum amount of assets a user can deposit\\n    /// @param account Address to query\\n    /// @return The max amount of assets the account can deposit\\n    function maxDeposit(address account) external view returns (uint256);\\n\\n    /// @notice Calculate an amount of shares that would be created by depositing assets\\n    /// @param assets Amount of assets deposited\\n    /// @return Amount of shares received\\n    function previewDeposit(uint256 assets) external view returns (uint256);\\n\\n    /// @notice Fetch the maximum amount of shares a user can mint\\n    /// @param account Address to query\\n    /// @return The max amount of shares the account can mint\\n    function maxMint(address account) external view returns (uint256);\\n\\n    /// @notice Calculate an amount of assets that would be required to mint requested amount of shares\\n    /// @param shares Amount of shares to be minted\\n    /// @return Required amount of assets\\n    function previewMint(uint256 shares) external view returns (uint256);\\n\\n    /// @notice Fetch the maximum amount of assets a user is allowed to withdraw\\n    /// @param owner Account holding the shares\\n    /// @return The maximum amount of assets the owner is allowed to withdraw\\n    function maxWithdraw(address owner) external view returns (uint256);\\n\\n    /// @notice Calculate the amount of shares that will be burned when withdrawing requested amount of assets\\n    /// @param assets Amount of assets withdrawn\\n    /// @return Amount of shares burned\\n    function previewWithdraw(uint256 assets) external view returns (uint256);\\n\\n    /// @notice Fetch the maximum amount of shares a user is allowed to redeem for assets\\n    /// @param owner Account holding the shares\\n    /// @return The maximum amount of shares the owner is allowed to redeem\\n    function maxRedeem(address owner) external view returns (uint256);\\n\\n    /// @notice Calculate the amount of assets that will be transferred when redeeming requested amount of shares\\n    /// @param shares Amount of shares redeemed\\n    /// @return Amount of assets transferred\\n    function previewRedeem(uint256 shares) external view returns (uint256);\\n\\n    /// @notice Transfer requested amount of underlying tokens from sender to the vault pool in return for shares\\n    /// @param amount Amount of assets to deposit (use max uint256 for full underlying token balance)\\n    /// @param receiver An account to receive the shares\\n    /// @return Amount of shares minted\\n    /// @dev Deposit will round down the amount of assets that are converted to shares. To prevent losses consider using\\n    /// mint instead.\\n    function deposit(uint256 amount, address receiver) external returns (uint256);\\n\\n    /// @notice Transfer underlying tokens from sender to the vault pool in return for requested amount of shares\\n    /// @param amount Amount of shares to be minted\\n    /// @param receiver An account to receive the shares\\n    /// @return Amount of assets deposited\\n    function mint(uint256 amount, address receiver) external returns (uint256);\\n\\n    /// @notice Transfer requested amount of underlying tokens from the vault and decrease account's shares balance\\n    /// @param amount Amount of assets to withdraw\\n    /// @param receiver Account to receive the withdrawn assets\\n    /// @param owner Account holding the shares to burn\\n    /// @return Amount of shares burned\\n    function withdraw(uint256 amount, address receiver, address owner) external returns (uint256);\\n\\n    /// @notice Burn requested shares and transfer corresponding underlying tokens from the vault to the receiver\\n    /// @param amount Amount of shares to burn (use max uint256 to burn full owner balance)\\n    /// @param receiver Account to receive the withdrawn assets\\n    /// @param owner Account holding the shares to burn.\\n    /// @return Amount of assets transferred\\n    function redeem(uint256 amount, address receiver, address owner) external returns (uint256);\\n}\\n\\n/// @title IVault\\n/// @notice Interface of the EVault's Vault module\\ninterface IVault is IERC4626 {\\n    /// @notice Balance of the fees accumulator, in shares\\n    /// @return The accumulated fees in shares\\n    function accumulatedFees() external view returns (uint256);\\n\\n    /// @notice Balance of the fees accumulator, in underlying units\\n    /// @return The accumulated fees in asset units\\n    function accumulatedFeesAssets() external view returns (uint256);\\n\\n    /// @notice Address of the original vault creator\\n    /// @return The address of the creator\\n    function creator() external view returns (address);\\n\\n    /// @notice Creates shares for the receiver, from excess asset balances of the vault (not accounted for in `cash`)\\n    /// @param amount Amount of assets to claim (use max uint256 to claim all available assets)\\n    /// @param receiver An account to receive the shares\\n    /// @return Amount of shares minted\\n    /// @dev Could be used as an alternative deposit flow in certain scenarios. E.g. swap directly to the vault, call\\n    /// `skim` to claim deposit.\\n    function skim(uint256 amount, address receiver) external returns (uint256);\\n}\\n\\n/// @title IBorrowing\\n/// @notice Interface of the EVault's Borrowing module\\ninterface IBorrowing {\\n    /// @notice Sum of all outstanding debts, in underlying units (increases as interest is accrued)\\n    /// @return The total borrows in asset units\\n    function totalBorrows() external view returns (uint256);\\n\\n    /// @notice Sum of all outstanding debts, in underlying units scaled up by shifting\\n    /// INTERNAL_DEBT_PRECISION_SHIFT bits\\n    /// @return The total borrows in internal debt precision\\n    function totalBorrowsExact() external view returns (uint256);\\n\\n    /// @notice Balance of vault assets as tracked by deposits/withdrawals and borrows/repays\\n    /// @return The amount of assets the vault tracks as current direct holdings\\n    function cash() external view returns (uint256);\\n\\n    /// @notice Debt owed by a particular account, in underlying units\\n    /// @param account Address to query\\n    /// @return The debt of the account in asset units\\n    function debtOf(address account) external view returns (uint256);\\n\\n    /// @notice Debt owed by a particular account, in underlying units scaled up by shifting\\n    /// INTERNAL_DEBT_PRECISION_SHIFT bits\\n    /// @param account Address to query\\n    /// @return The debt of the account in internal precision\\n    function debtOfExact(address account) external view returns (uint256);\\n\\n    /// @notice Retrieves the current interest rate for an asset\\n    /// @return The interest rate in yield-per-second, scaled by 10**27\\n    function interestRate() external view returns (uint256);\\n\\n    /// @notice Retrieves the current interest rate accumulator for an asset\\n    /// @return An opaque accumulator that increases as interest is accrued\\n    function interestAccumulator() external view returns (uint256);\\n\\n    /// @notice Returns an address of the sidecar DToken\\n    /// @return The address of the DToken\\n    function dToken() external view returns (address);\\n\\n    /// @notice Transfer underlying tokens from the vault to the sender, and increase sender's debt\\n    /// @param amount Amount of assets to borrow (use max uint256 for all available tokens)\\n    /// @param receiver Account receiving the borrowed tokens\\n    /// @return Amount of assets borrowed\\n    function borrow(uint256 amount, address receiver) external returns (uint256);\\n\\n    /// @notice Transfer underlying tokens from the sender to the vault, and decrease receiver's debt\\n    /// @param amount Amount of debt to repay in assets (use max uint256 for full debt)\\n    /// @param receiver Account holding the debt to be repaid\\n    /// @return Amount of assets repaid\\n    function repay(uint256 amount, address receiver) external returns (uint256);\\n\\n    /// @notice Pay off liability with shares (\\\"self-repay\\\")\\n    /// @param amount In asset units (use max uint256 to repay the debt in full or up to the available deposit)\\n    /// @param receiver Account to remove debt from by burning sender's shares\\n    /// @return shares Amount of shares burned\\n    /// @return debt Amount of debt removed in assets\\n    /// @dev Equivalent to withdrawing and repaying, but no assets are needed to be present in the vault\\n    /// @dev Contrary to a regular `repay`, if account is unhealthy, the repay amount must bring the account back to\\n    /// health, or the operation will revert during account status check\\n    function repayWithShares(uint256 amount, address receiver) external returns (uint256 shares, uint256 debt);\\n\\n    /// @notice Take over debt from another account\\n    /// @param amount Amount of debt in asset units (use max uint256 for all the account's debt)\\n    /// @param from Account to pull the debt from\\n    /// @dev Due to internal debt precision accounting, the liability reported on either or both accounts after\\n    /// calling `pullDebt` may not match the `amount` requested precisely\\n    function pullDebt(uint256 amount, address from) external;\\n\\n    /// @notice Request a flash-loan. A onFlashLoan() callback in msg.sender will be invoked, which must repay the loan\\n    /// to the main Euler address prior to returning.\\n    /// @param amount In asset units\\n    /// @param data Passed through to the onFlashLoan() callback, so contracts don't need to store transient data in\\n    /// storage\\n    function flashLoan(uint256 amount, bytes calldata data) external;\\n\\n    /// @notice Updates interest accumulator and totalBorrows, credits reserves, re-targets interest rate, and logs\\n    /// vault status\\n    function touch() external;\\n}\\n\\n/// @title ILiquidation\\n/// @notice Interface of the EVault's Liquidation module\\ninterface ILiquidation {\\n    /// @notice Checks to see if a liquidation would be profitable, without actually doing anything\\n    /// @param liquidator Address that will initiate the liquidation\\n    /// @param violator Address that may be in collateral violation\\n    /// @param collateral Collateral which is to be seized\\n    /// @return maxRepay Max amount of debt that can be repaid, in asset units\\n    /// @return maxYield Yield in collateral corresponding to max allowed amount of debt to be repaid, in collateral\\n    /// balance (shares for vaults)\\n    function checkLiquidation(address liquidator, address violator, address collateral)\\n        external\\n        view\\n        returns (uint256 maxRepay, uint256 maxYield);\\n\\n    /// @notice Attempts to perform a liquidation\\n    /// @param violator Address that may be in collateral violation\\n    /// @param collateral Collateral which is to be seized\\n    /// @param repayAssets The amount of underlying debt to be transferred from violator to sender, in asset units (use\\n    /// max uint256 to repay the maximum possible amount). Meant as slippage check together with `minYieldBalance`\\n    /// @param minYieldBalance The minimum acceptable amount of collateral to be transferred from violator to sender, in\\n    /// collateral balance units (shares for vaults).  Meant as slippage check together with `repayAssets`\\n    /// @dev If `repayAssets` is set to max uint256 it is assumed the caller will perform their own slippage checks to\\n    /// make sure they are not taking on too much debt. This option is mainly meant for smart contract liquidators\\n    function liquidate(address violator, address collateral, uint256 repayAssets, uint256 minYieldBalance) external;\\n}\\n\\n/// @title IRiskManager\\n/// @notice Interface of the EVault's RiskManager module\\ninterface IRiskManager is IEVCVault {\\n    /// @notice Retrieve account's total liquidity\\n    /// @param account Account holding debt in this vault\\n    /// @param liquidation Flag to indicate if the calculation should be performed in liquidation vs account status\\n    /// check mode, where different LTV values might apply.\\n    /// @return collateralValue Total risk adjusted value of all collaterals in unit of account\\n    /// @return liabilityValue Value of debt in unit of account\\n    function accountLiquidity(address account, bool liquidation)\\n        external\\n        view\\n        returns (uint256 collateralValue, uint256 liabilityValue);\\n\\n    /// @notice Retrieve account's liquidity per collateral\\n    /// @param account Account holding debt in this vault\\n    /// @param liquidation Flag to indicate if the calculation should be performed in liquidation vs account status\\n    /// check mode, where different LTV values might apply.\\n    /// @return collaterals Array of collaterals enabled\\n    /// @return collateralValues Array of risk adjusted collateral values corresponding to items in collaterals array.\\n    /// In unit of account\\n    /// @return liabilityValue Value of debt in unit of account\\n    function accountLiquidityFull(address account, bool liquidation)\\n        external\\n        view\\n        returns (address[] memory collaterals, uint256[] memory collateralValues, uint256 liabilityValue);\\n\\n    /// @notice Release control of the account on EVC if no outstanding debt is present\\n    function disableController() external;\\n\\n    /// @notice Checks the status of an account and reverts if account is not healthy\\n    /// @param account The address of the account to be checked\\n    /// @return magicValue Must return the bytes4 magic value 0xb168c58f (which is a selector of this function) when\\n    /// account status is valid, or revert otherwise.\\n    /// @dev Only callable by EVC during status checks\\n    function checkAccountStatus(address account, address[] calldata collaterals) external view returns (bytes4);\\n\\n    /// @notice Checks the status of the vault and reverts if caps are exceeded\\n    /// @return magicValue Must return the bytes4 magic value 0x4b3d1223 (which is a selector of this function) when\\n    /// account status is valid, or revert otherwise.\\n    /// @dev Only callable by EVC during status checks\\n    function checkVaultStatus() external returns (bytes4);\\n}\\n\\n/// @title IBalanceForwarder\\n/// @notice Interface of the EVault's BalanceForwarder module\\ninterface IBalanceForwarder {\\n    /// @notice Retrieve the address of rewards contract, tracking changes in account's balances\\n    /// @return The balance tracker address\\n    function balanceTrackerAddress() external view returns (address);\\n\\n    /// @notice Retrieves boolean indicating if the account opted in to forward balance changes to the rewards contract\\n    /// @param account Address to query\\n    /// @return True if balance forwarder is enabled\\n    function balanceForwarderEnabled(address account) external view returns (bool);\\n\\n    /// @notice Enables balance forwarding for the authenticated account\\n    /// @dev Only the authenticated account can enable balance forwarding for itself\\n    /// @dev Should call the IBalanceTracker hook with the current account's balance\\n    function enableBalanceForwarder() external;\\n\\n    /// @notice Disables balance forwarding for the authenticated account\\n    /// @dev Only the authenticated account can disable balance forwarding for itself\\n    /// @dev Should call the IBalanceTracker hook with the account's balance of 0\\n    function disableBalanceForwarder() external;\\n}\\n\\n/// @title IGovernance\\n/// @notice Interface of the EVault's Governance module\\ninterface IGovernance {\\n    /// @notice Retrieves the address of the governor\\n    /// @return The governor address\\n    function governorAdmin() external view returns (address);\\n\\n    /// @notice Retrieves address of the governance fee receiver\\n    /// @return The fee receiver address\\n    function feeReceiver() external view returns (address);\\n\\n    /// @notice Retrieves the interest fee in effect for the vault\\n    /// @return Amount of interest that is redirected as a fee, as a fraction scaled by 1e4\\n    function interestFee() external view returns (uint16);\\n\\n    /// @notice Looks up an asset's currently configured interest rate model\\n    /// @return Address of the interest rate contract or address zero to indicate 0% interest\\n    function interestRateModel() external view returns (address);\\n\\n    /// @notice Retrieves the ProtocolConfig address\\n    /// @return The protocol config address\\n    function protocolConfigAddress() external view returns (address);\\n\\n    /// @notice Retrieves the protocol fee share\\n    /// @return A percentage share of fees accrued belonging to the protocol, in 1e4 scale\\n    function protocolFeeShare() external view returns (uint256);\\n\\n    /// @notice Retrieves the address which will receive protocol's fees\\n    /// @notice The protocol fee receiver address\\n    function protocolFeeReceiver() external view returns (address);\\n\\n    /// @notice Retrieves supply and borrow caps in AmountCap format\\n    /// @return supplyCap The supply cap in AmountCap format\\n    /// @return borrowCap The borrow cap in AmountCap format\\n    function caps() external view returns (uint16 supplyCap, uint16 borrowCap);\\n\\n    /// @notice Retrieves the borrow LTV of the collateral, which is used to determine if the account is healthy during\\n    /// account status checks.\\n    /// @param collateral The address of the collateral to query\\n    /// @return Borrowing LTV in 1e4 scale\\n    function LTVBorrow(address collateral) external view returns (uint16);\\n\\n    /// @notice Retrieves the current liquidation LTV, which is used to determine if the account is eligible for\\n    /// liquidation\\n    /// @param collateral The address of the collateral to query\\n    /// @return Liquidation LTV in 1e4 scale\\n    function LTVLiquidation(address collateral) external view returns (uint16);\\n\\n    /// @notice Retrieves LTV configuration for the collateral\\n    /// @param collateral Collateral asset\\n    /// @return borrowLTV The current value of borrow LTV for originating positions\\n    /// @return liquidationLTV The value of fully converged liquidation LTV\\n    /// @return initialLiquidationLTV The initial value of the liquidation LTV, when the ramp began\\n    /// @return targetTimestamp The timestamp when the liquidation LTV is considered fully converged\\n    /// @return rampDuration The time it takes for the liquidation LTV to converge from the initial value to the fully\\n    /// converged value\\n    function LTVFull(address collateral)\\n        external\\n        view\\n        returns (\\n            uint16 borrowLTV,\\n            uint16 liquidationLTV,\\n            uint16 initialLiquidationLTV,\\n            uint48 targetTimestamp,\\n            uint32 rampDuration\\n        );\\n\\n    /// @notice Retrieves a list of collaterals with configured LTVs\\n    /// @return List of asset collaterals\\n    /// @dev Returned assets could have the ltv disabled (set to zero)\\n    function LTVList() external view returns (address[] memory);\\n\\n    /// @notice Retrieves the maximum liquidation discount\\n    /// @return The maximum liquidation discount in 1e4 scale\\n    /// @dev The default value, which is zero, is deliberately bad, as it means there would be no incentive to liquidate\\n    /// unhealthy users. The vault creator must take care to properly select the limit, given the underlying and\\n    /// collaterals used.\\n    function maxLiquidationDiscount() external view returns (uint16);\\n\\n    /// @notice Retrieves liquidation cool-off time, which must elapse after successful account status check before\\n    /// account can be liquidated\\n    /// @return The liquidation cool off time in seconds\\n    function liquidationCoolOffTime() external view returns (uint16);\\n\\n    /// @notice Retrieves a hook target and a bitmask indicating which operations call the hook target\\n    /// @return hookTarget Address of the hook target contract\\n    /// @return hookedOps Bitmask with operations that should call the hooks. See Constants.sol for a list of operations\\n    function hookConfig() external view returns (address hookTarget, uint32 hookedOps);\\n\\n    /// @notice Retrieves a bitmask indicating enabled config flags\\n    /// @return Bitmask with config flags enabled\\n    function configFlags() external view returns (uint32);\\n\\n    /// @notice Address of EthereumVaultConnector contract\\n    /// @return The EVC address\\n    function EVC() external view returns (address);\\n\\n    /// @notice Retrieves a reference asset used for liquidity calculations\\n    /// @return The address of the reference asset\\n    function unitOfAccount() external view returns (address);\\n\\n    /// @notice Retrieves the address of the oracle contract\\n    /// @return The address of the oracle\\n    function oracle() external view returns (address);\\n\\n    /// @notice Retrieves the Permit2 contract address\\n    /// @return The address of the Permit2 contract\\n    function permit2Address() external view returns (address);\\n\\n    /// @notice Splits accrued fees balance according to protocol fee share and transfers shares to the governor fee\\n    /// receiver and protocol fee receiver\\n    function convertFees() external;\\n\\n    /// @notice Set a new governor address\\n    /// @param newGovernorAdmin The new governor address\\n    /// @dev Set to zero address to renounce privileges and make the vault non-governed\\n    function setGovernorAdmin(address newGovernorAdmin) external;\\n\\n    /// @notice Set a new governor fee receiver address\\n    /// @param newFeeReceiver The new fee receiver address\\n    function setFeeReceiver(address newFeeReceiver) external;\\n\\n    /// @notice Set a new LTV config\\n    /// @param collateral Address of collateral to set LTV for\\n    /// @param borrowLTV New borrow LTV, for assessing account's health during account status checks, in 1e4 scale\\n    /// @param liquidationLTV New liquidation LTV after ramp ends in 1e4 scale\\n    /// @param rampDuration Ramp duration in seconds\\n    function setLTV(address collateral, uint16 borrowLTV, uint16 liquidationLTV, uint32 rampDuration) external;\\n\\n    /// @notice Set a new maximum liquidation discount\\n    /// @param newDiscount New maximum liquidation discount in 1e4 scale\\n    /// @dev If the discount is zero (the default), the liquidators will not be incentivized to liquidate unhealthy\\n    /// accounts\\n    function setMaxLiquidationDiscount(uint16 newDiscount) external;\\n\\n    /// @notice Set a new liquidation cool off time, which must elapse after successful account status check before\\n    /// account can be liquidated\\n    /// @param newCoolOffTime The new liquidation cool off time in seconds\\n    /// @dev Setting cool off time to zero allows liquidating the account in the same block as the last successful\\n    /// account status check\\n    function setLiquidationCoolOffTime(uint16 newCoolOffTime) external;\\n\\n    /// @notice Set a new interest rate model contract\\n    /// @param newModel The new IRM address\\n    /// @dev If the new model reverts, perhaps due to governor error, the vault will silently use a zero interest\\n    /// rate. Governor should make sure the new interest rates are computed as expected.\\n    function setInterestRateModel(address newModel) external;\\n\\n    /// @notice Set a new hook target and a new bitmap indicating which operations should call the hook target.\\n    /// Operations are defined in Constants.sol.\\n    /// @param newHookTarget The new hook target address. Use address(0) to simply disable hooked operations\\n    /// @param newHookedOps Bitmask with the new hooked operations\\n    /// @dev All operations are initially disabled in a newly created vault. The vault creator must set their\\n    /// own configuration to make the vault usable\\n    function setHookConfig(address newHookTarget, uint32 newHookedOps) external;\\n\\n    /// @notice Set new bitmap indicating which config flags should be enabled. Flags are defined in Constants.sol\\n    /// @param newConfigFlags Bitmask with the new config flags\\n    function setConfigFlags(uint32 newConfigFlags) external;\\n\\n    /// @notice Set new supply and borrow caps in AmountCap format\\n    /// @param supplyCap The new supply cap in AmountCap fromat\\n    /// @param borrowCap The new borrow cap in AmountCap fromat\\n    function setCaps(uint16 supplyCap, uint16 borrowCap) external;\\n\\n    /// @notice Set a new interest fee\\n    /// @param newFee The new interest fee\\n    function setInterestFee(uint16 newFee) external;\\n}\\n\\n/// @title IEVault\\n/// @custom:security-contact security@euler.xyz\\n/// @author Euler Labs (https://www.eulerlabs.com/)\\n/// @notice Interface of the EVault, an EVC enabled lending vault\\ninterface IEVault is\\n    IInitialize,\\n    IToken,\\n    IVault,\\n    IBorrowing,\\n    ILiquidation,\\n    IRiskManager,\\n    IBalanceForwarder,\\n    IGovernance\\n{\\n    /// @notice Fetch address of the `Initialize` module\\n    function MODULE_INITIALIZE() external view returns (address);\\n    /// @notice Fetch address of the `Token` module\\n    function MODULE_TOKEN() external view returns (address);\\n    /// @notice Fetch address of the `Vault` module\\n    function MODULE_VAULT() external view returns (address);\\n    /// @notice Fetch address of the `Borrowing` module\\n    function MODULE_BORROWING() external view returns (address);\\n    /// @notice Fetch address of the `Liquidation` module\\n    function MODULE_LIQUIDATION() external view returns (address);\\n    /// @notice Fetch address of the `RiskManager` module\\n    function MODULE_RISKMANAGER() external view returns (address);\\n    /// @notice Fetch address of the `BalanceForwarder` module\\n    function MODULE_BALANCE_FORWARDER() external view returns (address);\\n    /// @notice Fetch address of the `Governance` module\\n    function MODULE_GOVERNANCE() external view returns (address);\\n}\\n\"},\"src/CowEvcBaseWrapper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity ^0.8;\\n\\nimport {IEVC} from \\\"evc/EthereumVaultConnector.sol\\\";\\n\\nimport {CowWrapper, ICowSettlement} from \\\"./CowWrapper.sol\\\";\\nimport {PreApprovedHashes} from \\\"./PreApprovedHashes.sol\\\";\\n\\n/// @title CowEvcBaseWrapper\\n/// @notice Shared components for implementing Euler wrappers.\\nabstract contract CowEvcBaseWrapper is CowWrapper, PreApprovedHashes {\\n    /// @dev location in memory of the parameters describing the wrapper implementation.\\n    type ParamsLocation is bytes32;\\n\\n    IEVC public immutable EVC;\\n\\n    /// @dev The EIP-712 domain type hash used for computing the domain\\n    /// separator.\\n    bytes32 public constant DOMAIN_TYPE_HASH =\\n        keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\");\\n\\n    /// @dev The marker value for a sell order for computing the order struct\\n    /// hash. This allows the EIP-712 compatible wallets to display a\\n    /// descriptive string for the order kind (instead of 0 or 1).\\n    bytes32 internal constant KIND_SELL = keccak256(\\\"sell\\\");\\n\\n    /// @dev The OrderKind marker value for a buy order for computing the order\\n    /// struct hash.\\n    bytes32 internal constant KIND_BUY = keccak256(\\\"buy\\\");\\n\\n    /// @dev Used by EIP-712 signing to prevent signatures from being replayed\\n    bytes32 public immutable DOMAIN_SEPARATOR;\\n\\n    /// @dev The EVC nonce namespace to use when calling `EVC.permit` to authorize this contract.\\n    /// See: https://evc.wtf/docs/concepts/internals/permit/#nonce-namespaces\\n    uint256 public immutable NONCE_NAMESPACE;\\n\\n    /// @dev The length of the parameters consumed by this wrapper. Used in order to know how much data to read after the ParamsLocation for the hash.\\n    /// Ideally this should be computed by creating the parameters struct and then `abi.encode().length` to ensure its always the correct size.\\n    uint256 internal immutable PARAMS_SIZE;\\n\\n    /// @dev The EIP-712 type hash of the parameters structure used by this wrapper.\\n    bytes32 public immutable PARAMS_TYPE_HASH;\\n\\n    /// @dev How long to make the `items` array without calculating it. Determines the maximum number of EVC operations that can be batched.\\n    /// This value depends on the each concrete wrapper implementation. It should include the settlement and any operations before and after it.\\n    uint256 internal immutable MAX_BATCH_OPERATIONS;\\n\\n    /// @dev Indicates that the current operation cannot be completed with the given msgSender\\n    error Unauthorized(address msgSender);\\n\\n    /// @dev Indicates that the pre-approved hash is no longer able to be executed because the block timestamp is too old\\n    error OperationDeadlineExceeded(uint256 validToTimestamp, uint256 currentTimestamp);\\n\\n    /// @dev Indicates that a user attempted to interact with an account that is not their own\\n    error SubaccountMustBeControlledByOwner(address subaccount, address owner);\\n\\n    /// @dev Indicates that the EVC called `evcInternalSettle` in an invalid way\\n    error InvalidCallback();\\n\\n    /// @dev Indicates that neither `_encodeBatchItemsBefore` nor `_encodeBatchItemsAfter` requested permission, meaning the provided permit signature is unused.\\n    error UnusedPermitSignature();\\n\\n    /// @dev Used to ensure that the EVC is calling back this contract with the correct data\\n    bytes32 internal transient expectedEvcInternalSettleCallHash;\\n\\n    constructor(address _evc, ICowSettlement _settlement, bytes32 _domainName, bytes32 _domainVersion)\\n        CowWrapper(_settlement)\\n    {\\n        require(_evc.code.length > 0, \\\"EVC address is invalid\\\");\\n        EVC = IEVC(_evc);\\n        NONCE_NAMESPACE = uint256(uint160(address(this)));\\n        DOMAIN_SEPARATOR =\\n            keccak256(abi.encode(DOMAIN_TYPE_HASH, _domainName, _domainVersion, block.chainid, address(this)));\\n    }\\n\\n    /// @notice Encode batch items to execute before the settlement\\n    /// @dev By default we return the default value (empty array, false).\\n    /// At least one between this function and `_encodeBatchItemsAfter` should need permission (i.e., use the permit signature) for the permit flow to be secure.\\n    /// @param location The memory storage position where the parameters needed to encode the batch items have been saved\\n    /// @return items Array of batch items to execute\\n    /// @return needsPermission Whether these items require user signature or prior authorization as an operator\\n    function _encodeBatchItemsBefore(ParamsLocation location)\\n        internal\\n        view\\n        virtual\\n        returns (IEVC.BatchItem[] memory items, bool needsPermission)\\n    {}\\n\\n    /// @notice Encode batch items to execute after the settlement\\n    /// @dev By default we return the default value (empty array, false).\\n    /// At least one between this function and `_encodeBatchItemsBefore` should need permission (i.e., use the permit signature) for the permit flow to be secure.\\n    /// @param location The memory storage position where the parameters needed to encode the batch items have been saved\\n    /// @return items Array of batch items to execute\\n    /// @return needsPermission Whether these items require user signature or prior authorization as an operator\\n    function _encodeBatchItemsAfter(ParamsLocation location)\\n        internal\\n        view\\n        virtual\\n        returns (IEVC.BatchItem[] memory items, bool needsPermission)\\n    {}\\n\\n    /// @dev This function makes strong assumptions on the memory layout of the struct in memory.\\n    /// It assumes:\\n    ///  - The struct itself doesn't contain any dynamic-length types.\\n    ///  - The struct is encoded in memory with zero padding.\\n    /// @param params The memory location of the struct data\\n    /// @return digest The EIP-712 compliant digest\\n    function _getApprovalHash(ParamsLocation params) internal view returns (bytes32 digest) {\\n        bytes32 structHash;\\n        bytes32 separator = DOMAIN_SEPARATOR;\\n        bytes32 typeHash = PARAMS_TYPE_HASH;\\n        uint256 paramsSize = PARAMS_SIZE;\\n        assembly {\\n            // Build structHash = keccak256(typeHash || encodeData(params))\\n            let wordBeforeParamPtr := sub(params, 0x20)\\n            // Subtraction overflow causes the next line to revert with out of gas if params isn't allocated\\n            let wordBeforeParam := mload(wordBeforeParamPtr)\\n            mstore(wordBeforeParamPtr, typeHash)\\n            structHash := keccak256(wordBeforeParamPtr, add(0x20, paramsSize))\\n            // Restore original content\\n            mstore(wordBeforeParamPtr, wordBeforeParam)\\n\\n            // Build digest = keccak256(\\\"\\\\x19\\\\x01\\\" || domainSeparator || structHash)\\n            let ptr := mload(0x40)\\n            mstore(ptr, \\\"\\\\x19\\\\x01\\\")\\n            mstore(add(ptr, 0x02), separator)\\n            mstore(add(ptr, 0x22), structHash)\\n            digest := keccak256(ptr, 0x42)\\n        }\\n    }\\n\\n    /// @notice Generates the permit data that would be used for the given EVC batch items (presumably generated from params)\\n    function _encodePermitData(IEVC.BatchItem[] memory items, ParamsLocation params)\\n        internal\\n        view\\n        returns (bytes memory)\\n    {\\n        // The abi.encodeCall() part consists of the batch call that we want to execute. The additional data tacked on the end is to ensure\\n        // the provided parameters are all validated against the user signature, even if `items` doesn't completely use the parameters in effect.\\n        return abi.encodePacked(abi.encodeCall(IEVC.batch, items), _getApprovalHash(params));\\n    }\\n\\n    /// @notice This function is called by EVC and continues the CoW settlement process inside an EVC batch while including any necessary security check.\\n    function evcInternalSettle(\\n        bytes calldata settleData,\\n        bytes calldata wrapperData,\\n        bytes calldata remainingWrapperData\\n    ) external {\\n        require(msg.sender == address(EVC), Unauthorized(msg.sender));\\n        require(expectedEvcInternalSettleCallHash == keccak256(msg.data), InvalidCallback());\\n        expectedEvcInternalSettleCallHash = bytes32(0);\\n\\n        _evcInternalSettle(settleData, wrapperData, remainingWrapperData);\\n    }\\n\\n    function _makeInternalSettleCallbackData(\\n        bytes calldata settleData,\\n        bytes calldata wrapperData,\\n        bytes calldata remainingWrapperData\\n    ) internal pure returns (bytes memory) {\\n        return abi.encodeCall(CowEvcBaseWrapper.evcInternalSettle, (settleData, wrapperData, remainingWrapperData));\\n    }\\n\\n    function _invokeEvc(\\n        bytes memory evcInternalSettleCallback,\\n        ParamsLocation param,\\n        bytes memory signature,\\n        address owner,\\n        address account,\\n        uint256 deadline\\n    ) internal {\\n        // Subaccounts in the EVC can be any account that shares the highest 19 bits as the owner.\\n        // Here we verify that the subaccount address has been specified is, in fact, a subaccount of the owner.\\n        // Otherwise its concievably possible that a transfer could happen between an owner with an unauthorized subaccount.\\n        require(bytes19(bytes20(owner)) == bytes19(bytes20(account)), SubaccountMustBeControlledByOwner(account, owner));\\n\\n        // There are 2 ways that this contract can validate user operations: 1) the user pre-approves a hash with an on-chain call and grants this contract ability to operate on the user's behalf, or 2) they issue a signature which can be used to call EVC.permit()\\n        // The choice of the flow is based on whether `signature` has length zero. If so, then we use the hash approval flow (1).\\n        // Otherwise, the signature is assumed to be one for EVC.permit (2).\\n        // The permit signature is verified against the permit generated by `_encodePermitData`; the parameters are validated because they are unequivocally encoded in the signed permit.\\n        if (signature.length == 0) {\\n            _consumePreApprovedHash(owner, _getApprovalHash(param));\\n            // The deadline is checked by `EVC.permit()`, so we only check it here if we are using a pre-approved hash (aka, no signature) which would bypass that call\\n            require(deadline >= block.timestamp, OperationDeadlineExceeded(deadline, block.timestamp));\\n        }\\n\\n        // Build the EVC batch items for swapping collateral\\n        IEVC.BatchItem[] memory items = new IEVC.BatchItem[](MAX_BATCH_OPERATIONS);\\n\\n        uint256 itemIndex = 0;\\n\\n        {\\n            // add any EVC actions that have to be performed before\\n            IEVC.BatchItem[] memory partialItems;\\n            bool needsPermission;\\n            bool permissionRequested = false;\\n\\n            (partialItems, needsPermission) = _encodeBatchItemsBefore(param);\\n            permissionRequested = permissionRequested || needsPermission;\\n            itemIndex = _addEvcBatchItems(\\n                items, partialItems, itemIndex, owner, deadline, needsPermission ? signature : new bytes(0), param\\n            );\\n\\n            // add the EVC callback to this (which calls settlement)\\n            expectedEvcInternalSettleCallHash = keccak256(evcInternalSettleCallback);\\n            items[itemIndex++] = IEVC.BatchItem({\\n                onBehalfOfAccount: address(this),\\n                targetContract: address(this),\\n                value: 0,\\n                data: evcInternalSettleCallback\\n            });\\n\\n            // add the EVC actions that have to be performed after\\n            (partialItems, needsPermission) = _encodeBatchItemsAfter(param);\\n            permissionRequested = permissionRequested || needsPermission;\\n            itemIndex = _addEvcBatchItems(\\n                items, partialItems, itemIndex, owner, deadline, needsPermission ? signature : new bytes(0), param\\n            );\\n\\n            require(permissionRequested, UnusedPermitSignature());\\n        }\\n\\n        // shorten the length of the generated array to its actual length\\n        // We assume as an a invariant that the code above will not generate a `itemIndex` greater than `MAX_BATCH_OPERATIONS` at this point\\n        // because we always add an item to the items array when we increment `itemIndex`, and if the itemIndex goes out of bounds,\\n        // solidity will revert\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(items, itemIndex)\\n        }\\n\\n        // 3. Account status check (automatically done by EVC at end of batch)\\n        // For more info, see: https://evc.wtf/docs/concepts/internals/account-status-checks\\n        // No explicit item needed - EVC handles this\\n\\n        // Execute all items in a single batch\\n        EVC.batch(items);\\n\\n        // The pre approved hash flow needs the user to set this contract as an operator for both the owner address itself and the subaccount.\\n        // The EVC treats owner and subaccount operator authorizations separately, so we need to relinquish them separately\\n        if (signature.length == 0) {\\n            // This function returns both account and subaccount operator authorizations as a bitmask.\\n            // So we can do one call to find out what accounts are authorized, and then remove them as needed.\\n            uint256 mask = EVC.getOperator(bytes19(bytes20(owner)), address(this));\\n\\n            // check subaccount control\\n            // despite the lint, the shift is correct. This is the same way\\n            // the calculation is done in the EthereumVaultConnector contract.\\n            // https://github.com/euler-xyz/ethereum-vault-connector/blob/v1.0.1/src/EthereumVaultConnector.sol#L387\\n            /// forge-lint: disable-next-line(incorrect-shift)\\n            if ((mask & (1 << (uint160(owner) ^ uint160(account)))) > 0) {\\n                EVC.setAccountOperator(account, address(this), false);\\n            }\\n\\n            // check owner account control. If the owner is the subaccount, there is no need to set the operator again.\\n            if (owner != account && mask & 1 > 0) {\\n                EVC.setAccountOperator(owner, address(this), false);\\n            }\\n        }\\n    }\\n\\n    /// @dev Helper function to add IEVC.BatchItem to the EVC.batch call with any authorization that may be required.\\n    /// Depending on whether a signature is provided, this function will either copy `addItems` into `fullItems` at the given position,\\n    /// or `addItems` will be condensed into a single `EVC.permit` call and then added to the batch as a single item.\\n    /// @param fullItems The items which will ultimately be executed by EVC.batch\\n    /// @param addItems The items which need to be added to fullItems with appropriate authorization wrapping as needed\\n    /// @param itemIndex The index in `fullItems` starting from which `addItems` should be written\\n    /// @param owner The owner who is granting permission to execute the operations. Needed to construct the `EVC.permit`\\n    /// @param deadline The time at which the permit signature would expire. needed to construct the `EVC.permit`\\n    /// @param signature The signature used to validate the EVC.permit. If this is set to `new bytes(0)`, no permit will be used, and the items will be copied directly instead.\\n    /// @param param The input parameters for this trade. Needed to construct the `EVC.permit`, as the params data hash is appended to the end of the batch to ensure the signed `EVC.permit` can't be used with parameters that the user didn't sign.\\n    /// @return The index immediately after the last item written to `fullItems`\\n    function _addEvcBatchItems(\\n        IEVC.BatchItem[] memory fullItems,\\n        IEVC.BatchItem[] memory addItems,\\n        uint256 itemIndex,\\n        address owner,\\n        uint256 deadline,\\n        bytes memory signature,\\n        ParamsLocation param\\n    ) internal view returns (uint256) {\\n        // There are two ways this contract can be executed: either the user approves this contract as\\n        // an operator and supplies a pre-approved hash for the operation to take, or they submit a permit hash\\n        // for this specific instance. If its the permit hash route, here we call `permit` instead of `batch` raw so that the EVC can authorize it.\\n        // If there is an issue with the signature, the EVC will revert the batch call, which will bubble up through this contract to revert the entire wrappedSettle call.\\n        if (signature.length > 0) {\\n            fullItems[itemIndex++] = IEVC.BatchItem({\\n                onBehalfOfAccount: address(0),\\n                targetContract: address(EVC),\\n                value: 0,\\n                data: abi.encodeCall(\\n                    IEVC.permit,\\n                    (\\n                        owner,\\n                        address(this),\\n                        uint256(NONCE_NAMESPACE),\\n                        EVC.getNonce(bytes19(bytes20(owner)), NONCE_NAMESPACE),\\n                        deadline,\\n                        0, // value field (no ETH transferred to the EVC)\\n                        _encodePermitData(addItems, param),\\n                        signature\\n                    )\\n                )\\n            });\\n        } else {\\n            // copy the operations to execute. this contract can operate on behalf of the user directly\\n            for (uint256 i; i < addItems.length; i++) {\\n                fullItems[itemIndex + i] = addItems[i];\\n            }\\n\\n            itemIndex += addItems.length;\\n        }\\n\\n        return itemIndex;\\n    }\\n\\n    function _evcInternalSettle(\\n        bytes calldata settleData,\\n        bytes calldata wrapperData,\\n        bytes calldata remainingWrapperData\\n    ) internal virtual;\\n}\\n\"},\"src/CowEvcOpenPositionWrapper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity ^0.8;\\n\\nimport {IEVC} from \\\"evc/EthereumVaultConnector.sol\\\";\\n\\nimport {ICowSettlement, CowWrapper} from \\\"./CowWrapper.sol\\\";\\nimport {IERC4626, IBorrowing} from \\\"euler-vault-kit/src/EVault/IEVault.sol\\\";\\nimport {CowEvcBaseWrapper} from \\\"./CowEvcBaseWrapper.sol\\\";\\n\\n/// @title CowEvcOpenPositionWrapper\\n/// @notice A specialized wrapper for opening leveraged positions with EVC\\n/// @dev This wrapper hardcodes the EVC operations needed to open a position:\\n///      1. Enable collateral vault\\n///      2. Enable controller (borrow vault)\\n///      3. Deposit collateral\\n///      4. Borrow assets\\n/// @dev The settle call by this order should be performing the necessary swap\\n/// from IERC20(borrowVault.asset()) -> collateralVault. See below for more information\\n/// on how to set the CoW order params.\\ncontract CowEvcOpenPositionWrapper is CowEvcBaseWrapper {\\n    /// @dev The EIP-712 domain name used for computing the domain separator.\\n    bytes32 constant DOMAIN_NAME = keccak256(\\\"CowEvcOpenPositionWrapper\\\");\\n\\n    /// @dev The EIP-712 domain version used for computing the domain separator.\\n    bytes32 constant DOMAIN_VERSION = keccak256(\\\"1\\\");\\n\\n    /// @dev A descriptive label for this contract, as required by CowWrapper\\n    string public override name = \\\"Euler EVC - Open Position\\\";\\n\\n    /// @dev Emitted when a position is opened via this wrapper\\n    event CowEvcPositionOpened(\\n        address indexed owner,\\n        address account,\\n        address indexed collateralVault,\\n        address indexed borrowVault,\\n        uint256 collateralAmount,\\n        uint256 borrowAmount\\n    );\\n\\n    constructor(address _evc, ICowSettlement _settlement)\\n        CowEvcBaseWrapper(_evc, _settlement, DOMAIN_NAME, DOMAIN_VERSION)\\n    {\\n        PARAMS_SIZE =\\n        abi.encode(\\n            OpenPositionParams({\\n                owner: address(0),\\n                account: address(0),\\n                deadline: 0,\\n                collateralVault: address(0),\\n                borrowVault: address(0),\\n                collateralAmount: 0,\\n                borrowAmount: 0\\n            })\\n        )\\n        .length;\\n\\n        MAX_BATCH_OPERATIONS = 5;\\n\\n        PARAMS_TYPE_HASH = keccak256(\\n            \\\"OpenPositionParams(address owner,address account,uint256 deadline,address collateralVault,address borrowVault,uint256 collateralAmount,uint256 borrowAmount)\\\"\\n        );\\n    }\\n\\n    /// @notice The information necessary to open a debt position against an euler vault using collateral as backing.\\n    /// @dev This structure is used, combined with domain separator, to indicate a pre-approved hash.\\n    /// the `deadline` is used for deduplication checking, so be careful to ensure this value is unique.\\n    struct OpenPositionParams {\\n        /// @dev The ethereum address that has permission to operate upon the account.\\n        /// The CoW order should be signed or otherwise authorized by this address.\\n        address owner;\\n\\n        /// @dev The subaccount to open the position on. Learn more about Euler subaccounts https://evc.wtf/docs/concepts/internals/sub-accounts\\n        /// The CoW order `receiver` should be equal to this value.\\n        address account;\\n\\n        /// @dev A date by which this operation must be completed.\\n        uint256 deadline;\\n\\n        /// @dev The Euler vault to use as collateral.\\n        /// The CoW order `buyToken` should be equal to this value.\\n        address collateralVault;\\n\\n        /// @dev The Euler vault to use as leverage.\\n        /// The CoW order `sellToken` should be equal to `IERC4626(borrowVault).asset()`.\\n        address borrowVault;\\n\\n        /// @dev The amount of collateral to import as margin. Set this to `0` if the vault already has margin collateral.\\n        /// Contrary to how this looks, this value is *not* the same as `buyAmount` in the CoW order. It only defines how much collateral to deposit into the vault prior to borrowing.\\n        uint256 collateralAmount;\\n\\n        /// @dev The amount of debt to take out. The borrowed tokens will be converted to `collateralVault` tokens and deposited into the account.\\n        /// The CoW order `sellAmount` should be equal to this value.\\n        uint256 borrowAmount;\\n    }\\n\\n    function _parseOpenPositionParams(bytes calldata wrapperData)\\n        internal\\n        pure\\n        returns (OpenPositionParams memory params, bytes memory signature)\\n    {\\n        (params, signature) = abi.decode(wrapperData, (OpenPositionParams, bytes));\\n    }\\n\\n    /// @notice Helper function to compute the hash that would be approved\\n    /// @param params The OpenPositionParams to hash\\n    /// @return The hash of the signed calldata for these params\\n    function getApprovalHash(OpenPositionParams memory params) external view returns (bytes32) {\\n        return _getApprovalHash(memoryLocation(params));\\n    }\\n\\n    /// @inheritdoc CowWrapper\\n    function validateWrapperData(bytes calldata wrapperData) external pure override {\\n        // Validate by attempting to parse the wrapper data\\n        // Will revert if the data is malformed\\n        _parseOpenPositionParams(wrapperData);\\n    }\\n\\n    /// @notice Implementation of CowWrapper._wrap - executes EVC operations to open a position\\n    /// @param settleData Data which will be used for the parameters in a call to `CowSettlement.settle`\\n    /// @param wrapperData Additional data containing OpenPositionParams\\n    function _wrap(bytes calldata settleData, bytes calldata wrapperData, bytes calldata remainingWrapperData)\\n        internal\\n        override\\n    {\\n        // Decode wrapper data into OpenPositionParams\\n        (OpenPositionParams memory params, bytes memory signature) = _parseOpenPositionParams(wrapperData);\\n\\n        _invokeEvc(\\n            _makeInternalSettleCallbackData(settleData, wrapperData, remainingWrapperData),\\n            memoryLocation(params),\\n            signature,\\n            params.owner,\\n            params.account,\\n            params.deadline\\n        );\\n\\n        emit CowEvcPositionOpened(\\n            params.owner,\\n            params.account,\\n            params.collateralVault,\\n            params.borrowVault,\\n            params.collateralAmount,\\n            params.borrowAmount\\n        );\\n    }\\n\\n    /// @notice Called by an offchain process to determine what data should be signed by users in case they choose to use the permit flow for authentication.\\n    /// @param params The parameters object provided as input to the wrapper\\n    /// @return The `EVC` call that would be submitted to `EVC.permit`. This would need to be signed as documented https://evc.wtf/docs/concepts/internals/permit.\\n    function encodePermitData(OpenPositionParams memory params) external view returns (bytes memory) {\\n        (IEVC.BatchItem[] memory items,) = _encodeBatchItemsBefore(memoryLocation(params));\\n        return _encodePermitData(items, memoryLocation(params));\\n    }\\n\\n    function _encodeBatchItemsBefore(ParamsLocation paramsLocation)\\n        internal\\n        view\\n        override\\n        returns (IEVC.BatchItem[] memory items, bool needsPermission)\\n    {\\n        OpenPositionParams memory params = paramsFromMemory(paramsLocation);\\n        items = new IEVC.BatchItem[](MAX_BATCH_OPERATIONS - 1);\\n\\n        // 1. Enable collateral\\n        items[0] = IEVC.BatchItem({\\n            onBehalfOfAccount: address(0),\\n            targetContract: address(EVC),\\n            value: 0,\\n            data: abi.encodeCall(IEVC.enableCollateral, (params.account, params.collateralVault))\\n        });\\n\\n        // 2. Enable controller (borrow vault)\\n        items[1] = IEVC.BatchItem({\\n            onBehalfOfAccount: address(0),\\n            targetContract: address(EVC),\\n            value: 0,\\n            data: abi.encodeCall(IEVC.enableController, (params.account, params.borrowVault))\\n        });\\n\\n        // 3. Deposit collateral\\n        items[2] = IEVC.BatchItem({\\n            onBehalfOfAccount: params.owner,\\n            targetContract: params.collateralVault,\\n            value: 0,\\n            data: abi.encodeCall(IERC4626.deposit, (params.collateralAmount, params.account))\\n        });\\n\\n        // 4. Borrow assets\\n        items[3] = IEVC.BatchItem({\\n            onBehalfOfAccount: params.account,\\n            targetContract: params.borrowVault,\\n            value: 0,\\n            data: abi.encodeCall(IBorrowing.borrow, (params.borrowAmount, params.owner))\\n        });\\n\\n        needsPermission = true;\\n    }\\n\\n    function _evcInternalSettle(bytes calldata settleData, bytes calldata, bytes calldata remainingWrapperData)\\n        internal\\n        override\\n    {\\n        // Use CowWrapper's _next to proceed with the wrapper chain/settlement\\n        _next(settleData, remainingWrapperData);\\n    }\\n\\n    function memoryLocation(OpenPositionParams memory params) internal pure returns (ParamsLocation location) {\\n        assembly (\\\"memory-safe\\\") {\\n            location := params\\n        }\\n    }\\n\\n    function paramsFromMemory(ParamsLocation location) internal pure returns (OpenPositionParams memory params) {\\n        assembly {\\n            params := location\\n        }\\n    }\\n}\\n\"},\"src/CowWrapper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity ^0.8;\\n\\n/**\\n * Title: CoW Wrapper all-in-one integration file\\n * Author: CoW DAO\\n * This file is completely self-contained (ie no dependencies) and can be portably copied to whatever projects it is needed.\\n * It contains:\\n * * CowWrapper -- an abstract base contract which should be inherited by all wrappers\\n * * ICowWrapper -- the required interface for all wrappers\\n * * ICowSettlement -- A minimized interface and base structures for CoW Protocol settlement contract. From https://github.com/cowprotocol/contracts/blob/main/src/contracts/GPv2Settlement.sol\\n * * ICowAuthentication -- The authentication interface used by ICowSettlement. From https://github.com/cowprotocol/contracts/blob/main/src/contracts/interfaces/GPv2Authentication.sol\\n */\\n\\n/// @title CoW Protocol Authentication Interface\\n/// @author CoW DAO developers\\ninterface ICowAuthentication {\\n    /// @dev determines whether the provided address is an authenticated solver.\\n    /// @param prospectiveSolver the address of prospective solver.\\n    /// @return true when prospectiveSolver is an authenticated solver, otherwise false.\\n    function isSolver(address prospectiveSolver) external view returns (bool);\\n}\\n\\n/// @title CoW Protocol Settlement Interface\\n/// @notice Minimal interface for CoW Protocol's settlement contract\\n/// @dev Used for type-safe calls to the settlement contract's settle function\\ninterface ICowSettlement {\\n    /// @notice Trade data structure matching GPv2Settlement\\n    struct Trade {\\n        uint256 sellTokenIndex;\\n        uint256 buyTokenIndex;\\n        address receiver;\\n        uint256 sellAmount;\\n        uint256 buyAmount;\\n        uint32 validTo;\\n        bytes32 appData;\\n        uint256 feeAmount;\\n        uint256 flags;\\n        uint256 executedAmount;\\n        bytes signature;\\n    }\\n\\n    /// @notice Interaction data structure for pre/intra/post-settlement actions which are supplied by the solver to complete the user request\\n    struct Interaction {\\n        address target;\\n        uint256 value;\\n        bytes callData;\\n    }\\n\\n    /// @notice Returns the authentication contract used by the settlement contract.\\n    function authenticator() external view returns (ICowAuthentication);\\n\\n    /// @notice Returns the address of the vaultRelayer, the target for approvals for funds entering the settlement contract.\\n    function vaultRelayer() external view returns (address);\\n\\n    /// @notice Returns the domain separator for EIP-712 signing\\n    function domainSeparator() external view returns (bytes32);\\n\\n    /// @notice Allows for approval of orders by submitting an authorized hash on-chain prior to order execution.\\n    function setPreSignature(bytes calldata orderUid, bool signed) external;\\n\\n    /// @notice Settles a batch of trades atomically\\n    /// @param tokens Array of token addresses involved in the settlement\\n    /// @param clearingPrices Array of clearing prices for each token\\n    /// @param trades Array of trades to execute\\n    /// @param interactions Array of three interaction arrays (pre, intra, post-settlement)\\n    function settle(\\n        address[] calldata tokens,\\n        uint256[] calldata clearingPrices,\\n        Trade[] calldata trades,\\n        Interaction[][3] calldata interactions\\n    ) external;\\n}\\n\\n/// @title CoW Protocol Wrapper Interface\\n/// @notice Interface for wrapper contracts that add custom logic around CoW settlements\\n/// @dev Wrappers can be chained together to compose multiple settlement operations\\ninterface ICowWrapper {\\n    /// @notice A human readable label for this wrapper. Used for display in explorer/analysis UIs\\n    function name() external view returns (string memory);\\n\\n    /// @notice The settlement contract used by this wrapper\\n    /// @return The CowSettlement contract address\\n    function SETTLEMENT() external view returns (ICowSettlement);\\n\\n    /// @notice Initiates a wrapped settlement call\\n    /// @dev This is the entry point for wrapped settlements. The wrapper will execute custom logic\\n    ///      before calling the next wrapper or settlement contract in the chain.\\n    /// @dev SECURITY: `settleData` is NOT guaranteed to remain unchanged through the wrapper chain.\\n    ///      Intermediate wrappers could modify it before passing it along. Do not rely on\\n    ///      `settleData` validation for security-critical checks.\\n    /// @param settleData ABI-encoded call to ICowSettlement.settle() containing trade data\\n    /// @param chainedWrapperData Encoded wrapper chain with the following format:\\n    ///        Structure: [uint16 len1][bytes data1][address wrapper2][uint16 len2][bytes data2][address wrapper3]...\\n    ///\\n    ///        Each wrapper in the chain consists of:\\n    ///        - 2 bytes: uint16 length of wrapper-specific data\\n    ///        - `length` bytes: wrapper-specific data for this wrapper\\n    ///        - 20 bytes: address of next wrapper (omitted for the final wrapper)\\n    ///\\n    ///        The final wrapper in the chain omits the next wrapper address and calls SETTLEMENT directly.\\n    ///\\n    ///        Example: [0x0005][0xAABBCCDDEE][0x1234...ABCD][0x0003][0x112233]\\n    ///                 len   data         next wrapper  len   data (final, no next address)\\n    ///\\n    function wrappedSettle(bytes calldata settleData, bytes calldata chainedWrapperData) external;\\n\\n    /// @notice Confirms validity of wrapper-specific data\\n    /// @dev Used by CowWrapperHelpers to validate wrapper data before execution. Reverts if the wrapper data is not valid for some reason.\\n    /// @param wrapperData The wrapper-specific data to parse\\n    function validateWrapperData(bytes calldata wrapperData) external view;\\n}\\n\\n/// @title CoW Protocol Wrapper Base Contract\\n/// @notice Abstract base contract for creating wrapper contracts around CoW Protocol settlements\\n/// @dev A wrapper enables custom pre/post-settlement and context-setting logic and can be chained with other wrappers.\\n///      Wrappers must:\\n///      - Be approved by the ICowAuthentication contract\\n///      - Verify the caller is an authenticated solver\\n///      - Eventually call settle() on the approved ICowSettlement contract\\n///      - Implement _wrap() for custom logic\\nabstract contract CowWrapper is ICowWrapper {\\n    /// @notice Thrown when the caller is not an authenticated solver\\n    /// @param unauthorized The address that attempted to call wrappedSettle\\n    error NotASolver(address unauthorized);\\n\\n    /// @notice Thrown when settle data doesn't contain the correct function selector\\n    /// @param invalidSettleData The invalid settle data that was provided\\n    error InvalidSettleData(bytes invalidSettleData);\\n\\n    /// @notice The settlement contract\\n    ICowSettlement public immutable SETTLEMENT;\\n\\n    /// @notice The authentication contract used to verify solvers\\n    /// @dev This is derived from `SETTLEMENT.authenticator()`.\\n    ICowAuthentication public immutable AUTHENTICATOR;\\n\\n    /// @notice Constructs a new CowWrapper\\n    /// @param settlement_ The ICowSettlement contract to use at the end of the wrapper chain. Also used for wrapper authentication.\\n    constructor(ICowSettlement settlement_) {\\n        SETTLEMENT = settlement_;\\n        AUTHENTICATOR = settlement_.authenticator();\\n    }\\n\\n    /// @inheritdoc ICowWrapper\\n    function wrappedSettle(bytes calldata settleData, bytes calldata chainedWrapperData) external {\\n        // Revert if not a valid solver\\n        require(AUTHENTICATOR.isSolver(msg.sender), NotASolver(msg.sender));\\n\\n        // Find out how long the next wrapper data is supposed to be\\n        // We use 2 bytes to decode the length of the wrapper data because it allows for up to 64KB of data for each wrapper.\\n        // This should be plenty of length for all identified use-cases of wrappers in the forseeable future.\\n        uint256 nextWrapperDataLen = uint256(uint16(bytes2(chainedWrapperData[0:2])));\\n\\n        // Delegate to the wrapper's custom logic\\n        uint256 remainingWrapperDataStart = 2 + nextWrapperDataLen;\\n        _wrap(\\n            settleData, chainedWrapperData[2:remainingWrapperDataStart], chainedWrapperData[remainingWrapperDataStart:]\\n        );\\n    }\\n\\n    /// @inheritdoc ICowWrapper\\n    function validateWrapperData(bytes calldata wrapperData) external view virtual;\\n\\n    /// @notice Internal function containing the wrapper's custom logic\\n    /// @dev Must be implemented by concrete wrapper contracts. Should execute custom logic\\n    ///      then eventually call _next() to continue the wrapped settlement chain.\\n    /// @param settleData ABI-encoded call to ICowSettlement.settle()\\n    /// @param wrapperData The wrapper data which should be consumed by this wrapper\\n    /// @param remainingWrapperData The reminder bytes resulting from consuming the current's wrapper data from the original `chainedWrapperData` in the `wrappedSettle` call. This should be passed unaltered to `_next` that will call the settlement function if this remainder is empty, or delegate the settlement to the next wrapper\\n    function _wrap(bytes calldata settleData, bytes calldata wrapperData, bytes calldata remainingWrapperData)\\n        internal\\n        virtual;\\n\\n    /// @notice Continues the wrapped settlement chain by calling the next wrapper or settlement contract\\n    /// @dev Extracts the next target address from wrapperData and either:\\n    ///      - Calls ICowSettlement.settle() directly if no more wrappers remain, or\\n    ///      - Calls the next CowWrapper.wrappedSettle() to continue the chain\\n    /// @param settleData ABI-encoded call to ICowSettlement.settle()\\n    /// @param remainingWrapperData Remaining wrapper data starting with the next target address (20 bytes)\\n    function _next(bytes calldata settleData, bytes calldata remainingWrapperData) internal {\\n        if (remainingWrapperData.length == 0) {\\n            // No more wrapper data - we're calling the final settlement contract\\n            // Verify the settle data has the correct function selector\\n            require(bytes4(settleData[:4]) == ICowSettlement.settle.selector, InvalidSettleData(settleData));\\n\\n            // Call the settlement contract directly with the settle data\\n            (bool success, bytes memory returnData) = address(SETTLEMENT).call(settleData);\\n\\n            if (!success) {\\n                // Bubble up the revert reason from the settlement contract\\n                assembly (\\\"memory-safe\\\") {\\n                    revert(add(returnData, 0x20), mload(returnData))\\n                }\\n            }\\n        } else {\\n            // Extract the next wrapper address from the first 20 bytes of wrapperData\\n            address nextWrapper = address(bytes20(remainingWrapperData[:20]));\\n\\n            // Skip past the address we just read\\n            remainingWrapperData = remainingWrapperData[20:];\\n\\n            // More wrapper data remains - call the next wrapper in the chain\\n            CowWrapper(nextWrapper).wrappedSettle(settleData, remainingWrapperData);\\n        }\\n    }\\n}\\n\"},\"src/PreApprovedHashes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity ^0.8;\\n\\n/// @title PreApprovedHashes\\n/// @notice Abstract contract for managing pre-approved operation hashes\\n/// @dev Allows users to pre-approve specific operations without requiring signatures each time\\nabstract contract PreApprovedHashes {\\n    /// @dev Marker value indicating a hash is pre-approved\\n    uint256 internal constant PRE_APPROVED = uint256(keccak256(\\\"PreApprovedHashes.PreApproved\\\"));\\n    uint256 internal constant CONSUMED = uint256(keccak256(\\\"PreApprovedHashes.Consumed\\\"));\\n\\n    /// @notice Storage indicating whether or not a signed calldata hash has been approved by an owner\\n    /// @dev Maps owner -> hash(orderParameters) -> approval status\\n    mapping(address => mapping(bytes32 => uint256)) public preApprovedHashes;\\n\\n    /// @notice Event emitted when an owner pre-approves or revokes a hash\\n    event PreApprovedHash(address indexed owner, bytes32 indexed hash, bool approved);\\n\\n    /// @notice Event emitted when a pre-approved hash is used and is no longer valid because its consumed\\n    event PreApprovedHashConsumed(address indexed owner, bytes32 indexed hash);\\n\\n    /// @notice Revert reason given when a hash has already been consumed, and therefore cannot be used\\n    /// @dev If the hash had simply never been approved in the first place, the error will be HashNotApproved\\n    error AlreadyConsumed(address owner, bytes32 hash);\\n\\n    /// @notice Revert reason given when a pre approved hash is being consumed, but it hasnt actually been approved.\\n    /// @dev If the hash has been approved in the past, but it was consumed, the error will be AlreadyConsumed\\n    error HashNotApproved(address owner, bytes32 hash);\\n\\n    /// @notice Pre-approve a hash of signed calldata for future execution\\n    /// @dev Once a hash is pre-approved, it can only be consumed once. This prevents replay attacks.\\n    /// @param hash The keccak256 hash of the order parameters\\n    /// @param approved True to approve the hash, false to revoke approval\\n    function setPreApprovedHash(bytes32 hash, bool approved) external {\\n        require(preApprovedHashes[msg.sender][hash] != CONSUMED, AlreadyConsumed(msg.sender, hash));\\n\\n        if (approved) {\\n            preApprovedHashes[msg.sender][hash] = PRE_APPROVED;\\n        } else {\\n            preApprovedHashes[msg.sender][hash] = CONSUMED;\\n        }\\n        emit PreApprovedHash(msg.sender, hash, approved);\\n    }\\n\\n    /// @notice Check if a hash is pre-approved for an owner\\n    /// @param owner The owner address\\n    /// @param hash The hash to check\\n    /// @return True if the hash is pre-approved, false otherwise\\n    function isHashPreApproved(address owner, bytes32 hash) external view returns (bool) {\\n        return preApprovedHashes[owner][hash] == PRE_APPROVED;\\n    }\\n\\n    /// @notice Check if a hash is pre-approved for an owner. If it is, changes it to be consumed.\\n    /// @param owner The owner address\\n    /// @param hash The hash to check\\n    function _consumePreApprovedHash(address owner, bytes32 hash) internal {\\n        if (preApprovedHashes[owner][hash] == PRE_APPROVED) {\\n            preApprovedHashes[owner][hash] = CONSUMED;\\n            emit PreApprovedHashConsumed(owner, hash);\\n        } else if (preApprovedHashes[owner][hash] == CONSUMED) {\\n            revert AlreadyConsumed(owner, hash);\\n        } else {\\n            revert HashNotApproved(owner, hash);\\n        }\\n    }\\n}\\n\"}},\"settings\":{\"remappings\":[\"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\"cow/=lib/cow/src/contracts/\",\"ds-test/=lib/evc/lib/forge-std/lib/ds-test/src/\",\"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\"ethereum-vault-connector/=lib/euler-vault-kit/lib/ethereum-vault-connector/src/\",\"euler-vault-kit/=lib/euler-vault-kit/\",\"evc/=lib/euler-vault-kit/lib/ethereum-vault-connector/src/\",\"forge-gas-snapshot/=lib/euler-vault-kit/lib/permit2/lib/forge-gas-snapshot/src/\",\"forge-std/=lib/forge-std/src/\",\"halmos-cheatcodes/=lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/\",\"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\"openzeppelin/=lib/euler-vault-kit/lib/ethereum-vault-connector/lib/openzeppelin-contracts/contracts/\",\"permit2/=lib/euler-vault-kit/lib/permit2/\",\"solmate/=lib/euler-vault-kit/lib/permit2/lib/solmate/\"],\"optimizer\":{\"enabled\":true,\"runs\":200},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"compilationTarget\":{\"src/CowEvcOpenPositionWrapper.sol\":\"CowEvcOpenPositionWrapper\"},\"evmVersion\":\"prague\",\"libraries\":{},\"viaIR\":true,\"outputSelection\":{\"*\":{\"*\":[\"*\"]}}}}"
      }
    }
  }
}